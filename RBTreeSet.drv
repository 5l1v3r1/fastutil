/*		 
 * fastUtil 2.0: Fast & compact specialized utility classes for Java
 *
 * Copyright (C) 2002 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package it.unimi.dsi.fastUtil;

import java.util.*;
import java.io.*;

/** A type-specific red-black tree set with a fast, small-footprint implementation.
 */

public final class RBTREESET extends ABSTRACT_SET implements Serializable, SORTEDSET {

	 /** A reference to the root entry. */
	 public transient Entry tree;

	 /** Number of elements in this set. */
	 private int count;

	 /** The entry of the first element of this set. */
	 private transient Entry firstEntry;

	 /** The entry of the last element of this set. */
	 private transient Entry lastEntry;

	 /** This set's comparator, as provided in the constructor. */
	 private Comparator storedComparator;

	 /** This set's actual comparator; it may differ from {@link #storedComparator} because it is
		  always a type-specific comparator, so it could be derived from the former by wrapping. */
	 private transient KEY_COMPARATOR actualComparator;

	 {
		  allocatePaths();
	 }

	 /** Creates a new empty tree set. 
	  */

	 public RBTREESET() {
		  tree = null;
		  count = 0;
	 }

	 /** Generates the comparator that will be actually used.
	  *
	  * <P>When a specific {@link Comparator} is specified and stored in {@link
	  * #storedComparator}, we must check whether it is type-specific.  If it is
	  * so, we can used directly, and we store it in {@link #actualComparator}. Otherwise,
	  * we generate on-the-fly an anonymous class that wraps the non-specific {@link Comparator}
	  * and makes it into a type-specific one.
	  */
	 private void setActualComparator() {
#if #keyclass(Object)
		  actualComparator = storedComparator;
#else
		  /* If the provided comparator is already type-specific, we use it. Otherwise,
			  we use a wrapper anonymous class to fake that it is type-specific. */
		  if ( storedComparator == null || storedComparator instanceof KEY_COMPARATOR ) actualComparator = (KEY_COMPARATOR)storedComparator;
		  else actualComparator =	new KEY_COMPARATOR() {
				public int compare( KEY_TYPE k1, KEY_TYPE k2 ) {
					 return storedComparator.compare( KEY2OBJ( k1 ), KEY2OBJ( k2 ) );
				}
				public int compare( Object ok1, Object ok2 ) {
					 return storedComparator.compare( ok1, ok2 );
				}
		  };
#endif
	 }
	 

	 /** Creates a new empty tree set with the given comparator.
	  *
	  * @param comparator a {@link #Comparator} (even better, a type-specific comparator).
	  */

	 public RBTREESET( final Comparator c ) {
		  this();
		  storedComparator = c;
		  setActualComparator();
	 }


	 /** Creates a new tree set copying a given set.
	  *
	  * @param m a {@link Set} to be copied into the new tree set. 
	  */
	 
	 public RBTREESET( Set m ) {
		  this();
		  addAll( m );
	 }

	 /** Creates a new tree set copying a given sorted set (and its {@link Comparator}).
	  *
	  * @param m a {@link SortedSet} to be copied into the new tree set. 
	  */
	 
	 public RBTREESET( SortedSet m ) {
		  this( m.comparator() );
		  addAll( m );
	 }


	 /*
	  * The following private methods implements some basic building blocks used by
	  * all accessors.  They are (and should be maintained) identical to those used in TreeMap.drv.
	  */


	 /** Compares two keys in the right way. 
	  *
	  * <P>This method uses the {@link #actualComparator} if it is non-<code>null</code>.
	  * Otherwise, it resorts to primitive type comparisons or to {@link Comparable#compareTo(Object)}.
	  *
	  * @param k1 the first key.
	  * @param k2 the second key.
	  * @return a number smaller than, equal to or greater than 0, as usual
	  * (i.e., when k1 &lt; k2, k1 = k2 or k1 &gt; k2, respectively).
	  */
	 
	 private int compare( KEY_TYPE k1, KEY_TYPE k2 ) {
		  return actualComparator == null ? KEY_CMP( k1, k2 ) : actualComparator.compare( k1, k2 );
    }



	 /** Returns the entry corresponding to the given key, if it is in the tree; <code>null</code>, otherwise.
	  *
	  * @param k the key to search for.
	  * @return the corresponding entry, or <code>null</code> if no entry with the given key exists.
	  */

   private Entry findKey( KEY_TYPE k ) {
		 Entry e = tree;
		 int cmp;

		 while ( e != null && ( cmp = compare( k, e.key ) ) != 0 ) 
			  e = cmp < 0 ? e.left() : e.right();
		 
		 return e;
   }

	 /** This vector remembers the path and the direction followed during the
	  *  current insertion. It suffices for about 2<sup>32</sup> entries. */
	 private transient boolean dirPath[];
	 private transient Entry nodePath[];

	 private void allocatePaths() {
		  dirPath = new boolean[ 64 ];
		  nodePath = new Entry[ 64 ];
	 }


	 /** Inserts a new element in the set.
	  *
	  * @param k a key.
	  * @return true if the insertion modified the set.
	  */

	 
	 private boolean insert( final KEY_TYPE k ) {

		  if ( tree == null ) { // The case of the empty tree is treated separately.
				count++;
				tree = lastEntry = firstEntry = new Entry( k );
		  }
		  else {
				Entry p = tree, e;
				int cmp, i = 1;

				dirPath[ 0 ]  = false;
				nodePath[ 0 ] = null;

				while( true ) {
					 if ( ( cmp = compare( k, p.key ) ) == 0 ) return false;
					 
					 nodePath[ i ] = p;
					 
					 if ( dirPath[ i++ ] = cmp > 0 ) {
						  if ( p.succ() ) {
								count++;
								e = new Entry( k );
								
								if ( p.right == null ) lastEntry = e;
								
								e.left = p;
								e.right = p.right;
								
								p.right( e );
								
								break;
						  }

						  p = p.right;
					 }
					 else {
						  if ( p.pred() ) {
								count++;
								e = new Entry( k );
								
								if ( p.left == null ) firstEntry = e;
								
								e.right = p;
								e.left = p.left;
								
								p.left( e );

								break;
						  }

						  p = p.left;
					 }
				}

				while( i >= 3 && ! nodePath[ i - 1 ].black() ) {
					 if ( ! dirPath[ i - 2 ] ) {
						  Entry y = nodePath[ i - 2 ].right;

						  if ( ! nodePath[ i - 2 ].succ() && ! y.black() ) {
								nodePath[ i - 1 ].black( true );
								y.black( true );
								nodePath[ i - 2 ].black( false );
								i -= 2;
						  }
						  else {
								Entry x;

								if ( ! dirPath[ i - 1 ] ) y = nodePath[ i - 1 ];
								else {
									 x = nodePath[ i - 1 ];
									 y = x.right;
									 x.right = y.left;
									 y.left = x;
									 nodePath[ i - 2 ].left = y;

									 if ( y.pred() ) {
										  y.pred( false );
										  x.succ( y );
									 }
								}
								
								x = nodePath[ i - 2 ];
								x.black( false );
								y.black( true );
								
								x.left = y.right;
								y.right = x;
								if ( nodePath[ i - 3 ] == null ) tree = y;
								else {
									 if ( dirPath[ i - 3 ] ) nodePath[ i - 3 ].right = y;
									 else nodePath[ i - 3 ].left = y;
								}

								if ( y.succ() ) {
									 y.succ( false );
									 x.pred( y );
								}
								break;
						  }
					 }
					 else {
						  Entry y = nodePath[ i - 2 ].left;
						  
						  if ( ! nodePath[ i - 2 ].pred() && ! y.black() ) {
								nodePath[ i - 1 ].black( true );
								y.black( true );
								nodePath[ i - 2 ].black( false );
								i -= 2;
						  }
						  else {
								Entry x;

								if ( dirPath[ i - 1 ] ) y = nodePath[ i - 1 ];
								else {
									 x = nodePath[ i - 1 ];
									 y = x.left;
									 x.left = y.right;
									 y.right = x;
									 nodePath[ i - 2 ].right = y;
	 
									 if ( y.succ() ) {
										  y.succ( false );
										  x.pred( y );
									 }
	 
								}

								x = nodePath[ i - 2 ];
								x.black( false );
								y.black( true );

								x.right = y.left;
								y.left = x;
								if ( nodePath[ i - 3 ] == null ) tree = y;
								else {
									 if ( dirPath[ i - 3 ] ) nodePath[ i - 3 ].right = y;
									 else nodePath[ i - 3 ].left = y;
								}

								if ( y.pred() ){
									 y.pred( false );
									 x.succ( y );
								}

								break;
						  }
					 }
				}
		  }
		  tree.black( true );
		  return true;
	 }

	 
	 /** Deletes an entry from the set.
	  *
	  * @param k a key.
	  * @return true if the deletion modified the set.
	  */
	 
	 private boolean delete( final KEY_TYPE k ) {
		  if ( tree == null ) return false;

		  Entry p = tree;
		  int cmp;
		  int i = 1;

		  nodePath[ 0 ] = null;
		  dirPath[ 0 ] = false;

		  while( true ) {
				if ( ( cmp = compare( k, p.key ) ) == 0 ) break;

				dirPath[ i ] = cmp > 0;
				nodePath[ i ] = p;

				if ( dirPath[ i++ ] ) {
					 if ( ( p = p.right() ) == null ) return false;
				}
				else {
					 if ( ( p = p.left() ) == null ) return false;
				}

		  }

		  if ( p.left == null ) {
				firstEntry = p.right;
				if ( ! p.succ()  ) while( ! firstEntry.pred() ) firstEntry = firstEntry.left;
		  }

		  if ( p.right == null ) {
				lastEntry = p.left;
				if ( ! p.pred() ) while( ! lastEntry.succ() ) lastEntry = lastEntry.right;
		  }

		  if ( p.succ() ) {
				if ( p.pred() ) {
					 if ( nodePath[ i - 1 ] != null ) {
						  if ( dirPath[ i - 1 ] ) nodePath[ i - 1 ].succ( p.right );
						  else nodePath[ i - 1 ].pred( p.left );
					 }
					 else tree = dirPath[ i - 1 ] ? p.right : p.left;
				}
				else {
					 Entry l = p.left;
					 while( ! l.succ() ) l = l.right;

					 l.right = p.right;

					 if ( nodePath[ i - 1 ] != null ) {
						  if ( dirPath[ i - 1 ] ) nodePath[ i - 1 ].right = p.left;
						  else nodePath[ i - 1 ].left = p.left;
					 }
					 else tree = p.left;
				}
		  }
		  else {
				boolean colour;
				Entry r = p.right;

				if ( r.pred() ) {
					 r.left = p.left;
					 r.pred( p.pred() );
					 if ( ! r.pred() ) {
						  Entry l = r.left;
						  while( ! l.succ() ) l = l.right;
						  l.right = r;
					 }
					 if ( nodePath[ i - 1 ] != null ) {
						  if ( dirPath[ i - 1 ] ) nodePath[ i - 1 ].right = r;
						  else nodePath[ i - 1 ].left = r;
					 }
					 else tree = r;

					 colour = r.black();
					 r.black( p.black() );
					 p.black( colour );
					 dirPath[ i ] = true;
					 nodePath[ i++ ] = r;
				}
				else {
					 Entry s;
					 int j = i++;

					 while( true ) {
						  dirPath[ i ] = false;
						  nodePath[ i++ ] = r;
						  s = r.left;
						  if ( s.pred() ) break;
						  r = s;
					 }

					 dirPath[ j ] = true;
					 nodePath[ j ] = s;

					 if ( s.succ() ) r.pred( s );
					 else r.left = s.right;

					 s.left = p.left;

					 if ( ! p.pred() ) {
						  Entry l = p.left;
						  while( ! l.succ() ) l = l.right;
						  l.right = s;

						  s.pred( false );
					 }

					 s.right( p.right );
							
					 colour = s.black();
					 s.black( p.black() );
					 p.black( colour );
	
					 if ( nodePath[ j - 1 ] != null ) {
						  if ( dirPath[ j - 1 ] ) nodePath[ j - 1 ].right = s;
						  else nodePath[ j - 1 ].left = s;
					 }
					 else tree = s;
				}
		  }

		  if ( p.black() ) {
				for( ; i > 1; i-- ) {
					 if ( dirPath[ i - 1 ] && ! nodePath[ i - 1 ].succ() ||
							! dirPath[ i - 1 ] && ! nodePath[ i - 1 ].pred() ) {
						  Entry x = dirPath[ i - 1 ] ? nodePath[ i - 1 ].right : nodePath[ i - 1 ].left;

						  if ( ! x.black() ) {
								x.black( true );
								break;
						  }
					 }

					 if ( ! dirPath[ i - 1 ] ) {
						  Entry w = nodePath[ i - 1 ].right;

						  if ( ! w.black() ) {
								w.black( true );
								nodePath[ i - 1 ].black( false );

								nodePath[ i - 1 ].right = w.left;
								w.left = nodePath[ i - 1 ];

								if ( nodePath[ i - 2 ] != null ) {
									 if ( dirPath[ i - 2 ] ) nodePath[ i - 2 ].right = w;
									 else nodePath[ i - 2 ].left = w;
								}
								else tree = w;

								nodePath[ i ] = nodePath[ i - 1 ];
								dirPath[ i ] = false;
								nodePath[ i - 1 ] = w;
								i++;

								w = nodePath[ i - 1 ].right;
						  }

						  if ( ( w.pred() || w.left.black() ) &&
								 ( w.succ() || w.right.black() ) ) {
								w.black( false );
						  }
						  else {
								if ( w.succ() || w.right.black() ) {
									 Entry y = w.left;
									 
									 y.black ( true );
									 w.black( false );
									 w.left = y.right;
									 y.right = w;
									 w = nodePath[ i - 1 ].right = y;

									 if ( w.succ() ) {
										  w.succ( false );
										  w.right.pred( w );
									 }
								}

								w.black( nodePath[ i - 1 ].black() );
								nodePath[ i - 1 ].black( true );
								w.right.black( true );

								nodePath[ i - 1 ].right = w.left;
								w.left = nodePath[ i - 1 ];

								if ( nodePath[ i - 2 ] != null ) {
									 if ( dirPath[ i - 2 ] ) nodePath[ i - 2 ].right = w;
									 else nodePath[ i - 2 ].left = w;
								}
								else tree = w;

								if ( w.pred() ) {
									 w.pred( false );
									 nodePath[ i - 1 ].succ( w );
								}
								break;
						  }
					 }
					 else {
						  Entry w = nodePath[ i - 1 ].left;

						  if ( ! w.black() ) {
								w.black ( true );
								nodePath[ i - 1 ].black( false );

								nodePath[ i - 1 ].left = w.right;
								w.right = nodePath[ i - 1 ];

								if ( nodePath[ i - 2 ] != null ) {
									 if ( dirPath[ i - 2 ] ) nodePath[ i - 2 ].right = w;
									 else nodePath[ i - 2 ].left = w;
								}
								else tree = w;

								nodePath[ i ] = nodePath[ i - 1 ];
								dirPath[ i ] = true;
								nodePath[ i - 1 ] = w;
								i++;

								w = nodePath[ i - 1 ].left;
						  }
						  
						  if ( ( w.pred() || w.left.black() ) &&
								 ( w.succ() || w.right.black() ) ) {
								w.black( false );
						  }
						  else {
								if ( w.pred() || w.left.black() ) {
									 Entry y = w.right;

									 y.black( true );
									 w.black ( false );
									 w.right = y.left;
									 y.left = w;
									 w = nodePath[ i - 1 ].left = y;

									 if ( w.pred() ) {
										  w.pred( false );
										  w.left.succ( w );
									 }
								}

								w.black( nodePath[ i - 1 ].black() );
								nodePath[ i -1 ].black( true );
								w.left.black( true );

								nodePath[ i - 1 ].left = w.right;
								w.right = nodePath[ i - 1 ];
									  
								if ( nodePath[ i - 2 ] != null ) {
									 if ( dirPath[ i - 2 ] ) nodePath[ i - 2 ].right = w;
									 else nodePath[ i - 2 ].left = w;
								}
								else tree = w;

								if ( w.succ() ) {
									 w.succ( false );
									 nodePath[ i - 1 ].pred( w );
								}
								break;
						  }
					 }
				}

				if ( tree != null ) tree.black( true );
		  }

		  count--;
		  return true;
	 }

	 

#if ! #keyclass(Object)
	 public boolean add( final KEY_TYPE k ) {
		  return insert( k );
	 }

   public boolean remove( final KEY_TYPE k ) {
		 return delete( k );
   }

	 public boolean contains( final KEY_TYPE k ) {
		  return findKey( k ) != null;
	 }
#endif

	 public boolean add( final Object ok ) {
		  return insert( KEY2TYPE(ok) );
	 }
	 
	 public boolean remove( final Object ok ) {
		  return delete( KEY2TYPE( ok ) );
	 }
	 
	 public boolean contains( final Object ok ) {
		  return findKey( KEY2TYPE( ok ) ) != null;
	 }


	 public void clear() {
		  count = 0;
		  tree = null;
		  firstEntry = lastEntry = null;
	 }

	 
	 /** This class represent an entry in a tree set.
	  *
	  * <P>We use the only "metadata", i.e., {@link Entry#info}, to store
	  * information about level, predecessor status and successor status.
	  *
	  * <P>Note that since the class is recursive, it can be
	  * considered equivalently a tree.
	  */

    private static final class Entry {
		  /** The the bit in this mask is true, the node is black. */
		  private final static int BLACK_MASK = 1;
		  /** If the bit in this mask is true, {@link #right} points to a successor. */
		  private final static int SUCC_MASK = 1 << 31;
		  /** If the bit in this mask is true, {@link #left} points to a predecessor. */
		  private final static int PRED_MASK = 1 << 30;
		  /** The key of this entry. */
		  protected KEY_TYPE key;
		  /** The pointers to the left and right subtrees. */
		  protected Entry left, right;
		  /** This integers holds different information in different bits (see {@link #SUCC_MASK}, {@link #PRED_MASK} and {@link #BLACK_MASK}). */
		  private int info;

		  /** Creates a new red entry with the given key.
			*
			* @param k a key.
			*/
		  protected Entry( Object k ) {
				this.key = KEY2TYPE( k );
				info = SUCC_MASK | PRED_MASK;
		  }

#if ! #keyclass(Object)  
		  
		  /** Creates a new red entry with the given key.
			*
			* @param k a key.
			*/
		  protected Entry( KEY_TYPE k ) {
				this.key = k;
				info = SUCC_MASK | PRED_MASK;
		  }
		  
#endif

		  /** Returns the left subtree. 
			*
			* @return the left subtree (<code>null</code> if the left
			* subtree is empty).
			*/
		  protected Entry left() {
				return ( info & PRED_MASK ) != 0 ? null : left;
		  }
		  
		  /** Returns the right subtree. 
			*
			* @return the right subtree (<code>null</code> if the right
			* subtree is empty).
			*/
		  protected Entry right() {
				return ( info & SUCC_MASK ) != 0 ? null : right;
		  }
		  
		  /** Checks whether the left pointer is really a predecessor.
			* @return true if the left pointer is a predecessor.
			*/
		  protected boolean pred() {
				return ( info & PRED_MASK ) != 0;
		  }
		  
		  /** Checks whether the right pointer is really a successor.
			* @return true if the right pointer is a successor.
			*/
		  protected boolean succ() {
				return ( info & SUCC_MASK ) != 0;
		  }
		  
		  /** Sets whether the left pointer is really a predecessor.
			* @param pred if true then the left pointer will be considered a predecessor.
			*/
		  protected void pred( boolean pred ) {
				if ( pred ) info |= PRED_MASK;
				else info &= ~PRED_MASK;
		  }
		  
		  /** Sets whether the right pointer is really a successor.
			* @param succ if true then the right pointer will be considered a successor.
			*/
		  protected void succ( boolean succ ) {
				if ( succ ) info |= SUCC_MASK;
				else info &= ~SUCC_MASK;
		  }
		  
		  /** Sets the left pointer to a predecessor.
			* @param pred the predecessr.
			*/
		  protected void pred( Entry pred ) {
				info |= PRED_MASK;
				left = pred;
		  }
		  
		  /** Sets the right pointer to a successor.
			* @param succ the successor.
			*/
		  protected void succ( Entry succ ) {
				info |= SUCC_MASK;
				right = succ;
		  }
		  
		  /** Sets the left pointer to the given subtree.
			* @param left the new left subtree.
			*/
		  protected void left( Entry left ) {
				info &= ~PRED_MASK;
				this.left = left;
		  }
		  
		  /** Sets the right pointer to the given subtree.
			* @param right the new right subtree.
			*/
		  protected void right( Entry right ) {
				info &= ~SUCC_MASK;
				this.right = right;
		  }
		  
		  /** Returns whether this node is black.
			* @return true iff this node is black.
			*/
		  protected boolean black() {
				return ( info & BLACK_MASK ) != 0;
		  }

		  /** Sets whether this node is black.
			* @param black if true, then this node becomes black; otherwise, it becomes red..
			*/
		  protected void black( boolean black ) {
				if ( black ) info |= BLACK_MASK;
				else info &= ~BLACK_MASK;
		  }

		  public Object getKey() {
				return KEY2OBJ(key);
		  }
		  
#if ! #keyclass(Object)
		  public KEY_TYPE ENTRY_GET_KEY() {
				return key;
		  }
#endif
		  
		  public boolean equals(Object o) {
				if (!(o instanceof Entry)) return false;
				Entry e = (Entry)o;
				
				return KEY_EQUAL(key, e.key);
		  }
		  
		  public int hashCode() {
				return KEY2INT(key);
		  }
		  
		  
		  public String toString() {
				return "" + key;
		  }
		  
		  /*
		  public void prettyPrint() {
				prettyPrint(0);
		  }


		  public void prettyPrint(int level) {
				if ( pred() ) {
					 for (int i = 0; i < level; i++)
						  System.err.print("  ");
					 System.err.println("pred: " + left );
				}
				else if (left != null)
					 left.prettyPrint(level +1 );
				for (int i = 0; i < level; i++)
					 System.err.print("  ");
				System.err.println(key + " (" + (black() ? "black" : "red") + ")");
				if ( succ() ) {
					 for (int i = 0; i < level; i++)
						  System.err.print("  ");
					 System.err.println("succ: " + right );
				}
				else if (right != null)
					 right.prettyPrint(level + 1);
					 }*/
    }
	 
	 /*
   public void prettyPrint() {
      System.err.println("size: " + count);
      if (tree != null) tree.prettyPrint();
   }
	 */
	
	 public int size() {
		  return count;
	 }
	 
	 public boolean isEmpty() {
		  return count == 0;
	 }
	 
	 public KEY_TYPE FIRST() {
		  if ( tree == null ) throw new NoSuchElementException();
		  return firstEntry.key;
	 }
	 
	 public KEY_TYPE LAST() {
		  if ( tree == null ) throw new NoSuchElementException();
		  return lastEntry.key;
	 }
	 
#if ! #keyclass(Object)
	 public Object first() {
		  return KEY2OBJ( FIRST() );
	 }
	 
	 public Object last() {
		  return KEY2OBJ( LAST() );
	 }
#endif

	 /** An iterator on the whole range.
	  *
	  * <P>This class can iterate in both directions on a threaded tree.
	  */

	 private class SetIterator implements KEY_LIST_ITERATOR {
		  /** The entry that will be returned by the next call to {@link #previous()} (or <code>null</code> if no previous entry exists). */
		  protected Entry prev;
		  /** The entry that will be returned by the next call to {@link #next()} (or <code>null</code> if no next entry exists). */
		  protected Entry next;
		  /** The last entry that was returned (or <code>null</code> if we did not iterate or used {@link #remove()}). */
		  protected Entry curr;
		  /** The current index (in the sense of a {@link ListIterator}). */
		  protected int index = 0;
		  
		  protected SetIterator() {
				next = firstEntry;
		  }

		  public boolean hasNext() { return next != null; }
		  public boolean hasPrevious() { return prev != null; }

		  protected void updateNext() {
				next = next.right;
				if ( next != null && ! curr.succ() ) while ( next.left() != null ) next = next.left;
		  }

		  protected Entry nextEntry() {
				if ( ! hasNext() ) throw new NoSuchElementException();
				curr = prev = next;
				index++;
				updateNext();
				return curr;
		  }

		  public KEY_TYPE NEXT_KEY() { return nextEntry().key; }
		  public KEY_TYPE PREV_KEY() { return previousEntry().key; }
#if !#keyclass(Object)
		  public Object next() { return KEY2OBJ( nextEntry().key ); }
		  public Object previous() { return KEY2OBJ( previousEntry().key ); }
#endif									

		  protected void updatePrevious() {
				prev = prev.left;
				if ( prev != null && ! curr.pred() ) while ( prev.right() != null ) prev = prev.right;
		  }

		  protected Entry previousEntry() {
				if ( ! hasPrevious() ) throw new NoSuchElementException();
				curr = next = prev;
				index--;
				updatePrevious();
				return curr;
		  }

		  public int nextIndex() {
				return index;
		  }

		  public int previousIndex() {
				return index - 1;
		  }

		  public void remove() {
				if ( curr == null ) throw new IllegalStateException();
				/* If the last operation was a next(), we are removing an entry that preceeds
					the current index, and thus we must decrement it. */
				if ( curr == prev ) index--;
				next = prev = curr;
				updatePrevious();
				updateNext();
				RBTREESET.this.delete( curr.key );
				curr = null;
		  }

		  public void set( Object o ) {
				throw new UnsupportedOperationException();
		  }

		  public void add( Object o ) {
				throw new UnsupportedOperationException();
		  }
	 }


	 public Iterator iterator() {
		  return new SetIterator();
	 }

	 public Comparator comparator() {
		  return storedComparator;
	 }

	 public SortedSet headSet( Object to  ) {
		  return new Subset( KEY_NULL, true, KEY2TYPE( to ), false );
	 }

	 public SortedSet tailSet( Object from ) {
		  return new Subset( KEY2TYPE( from ), false, KEY_NULL, true );
	 }

	 public SortedSet subSet( Object from, Object to ) {
		  return new Subset( KEY2TYPE( from ), false, KEY2TYPE( to ), false );
	 }

#if !#keyclass(Object)
	 public SORTEDSET headSet( KEY_TYPE to ) {
		  return new Subset( KEY_NULL, true, to, false );
	 }

	 public SORTEDSET tailSet( KEY_TYPE from ) {
		  return new Subset( from, false, KEY_NULL, true );
	 }

	 public SORTEDSET subSet( KEY_TYPE from, KEY_TYPE to ) {
		  return new Subset( from, false, to, false );
	 }
#endif

	 /** A subset with given range.
	  *
	  * <P>This class represents a subset. One has to specify the left/right
	  * limits (which can be set to -&infin; or &infin;). Since the subset is a
	  * view on the set, at a given moment it could happen that the limits of
	  * the range are not any longer in the main set. Thus, things such as
	  * {@link #first()} or {@link #size()} must be always computed
	  * on-the-fly.  
	  */
	 private class Subset extends ABSTRACT_SET implements Serializable, SORTEDSET {
		  /** The start of the subset range, unless {@link #bottom} is true. */
		  private KEY_TYPE from;
		  /** The end of the subset range, unless {@link #top} is true. */
		  private KEY_TYPE to;
		  /** If true, the subset range starts from -&infin;. */
		  private boolean bottom;
		  /** If true, the subset range goes to &infin;. */
		  private boolean top;
		  
		  /** Creates a new subset with given key range.
			*
			* @param from the start of the subset range.
			* @param bottom if true, the first parameter is ignored and the range starts from -&infin;.
			* @param to the end of the subset range.
			* @param top if true, the third parameter is ignored and the range goes to &infin;.
			*/
		  public Subset( KEY_TYPE from, boolean bottom, KEY_TYPE to, boolean top ) {
				if ( ! bottom && ! top && RBTREESET.this.compare( from, to ) > 0 ) {
					 throw new IllegalArgumentException( "fromKey > toKey" );
				}

				this.from = from;
				this.bottom = bottom;
				this.to = to;
				this.top = top;
		  }

		  public void clear() {
				final SubsetIterator i = new SubsetIterator();
				while( i.hasNext() ) {
					 i.next();
					 i.remove();
				}
		  }

		  /** Checks whether a key is in the subset range.
			* @param k a key.
			* @return true if is the key is in the subset range.
			*/
		  private boolean in( KEY_TYPE k ) {
				return ( bottom || RBTREESET.this.compare( k, from ) >= 0 ) &&
					 ( top || RBTREESET.this.compare( k, to ) < 0 );
		  }

		  public boolean contains( final KEY_TYPE k ) {
				return in( k ) && RBTREESET.this.contains( k );
		  }

#if !#keyclass(Object) 
		  public boolean contains( final Object ok ) {
				return contains( KEY2TYPE( ok ) );
		  }
#endif


		  public boolean add( final Object ok ) {
				if ( ! in( KEY2TYPE( ok ) ) ) throw new IllegalArgumentException(); 
				return insert( KEY2TYPE(ok) );
		  }

		  
#if ! #keyclass(Object)
		  public boolean add( final KEY_TYPE  k ) {
				if ( ! in( k ) ) throw new IllegalArgumentException(); 
				return insert( k );
		  }
#endif


		  public boolean remove( final Object ok ) {
				if ( ! in( KEY2TYPE( ok ) ) ) return false;
				return delete( KEY2TYPE( ok ) );
		  }

#if ! #keyclass(Object)
		  public boolean remove( final KEY_TYPE k ) {
				if ( ! in( k ) ) return false;
				return delete( k );
		  }
#endif

		  public int size() {
				final SubsetIterator i = new SubsetIterator();
				int n = 0;
				
				while( i.hasNext() ) {
					 n++;
					 i.next();
				}
				
				return n;
		  }


		  public boolean isEmpty() {
				return ! new SubsetIterator().hasNext();
		  }
		  
		  public Comparator comparator() {
				return storedComparator;
		  }

		  public Iterator iterator() {
				return new SubsetIterator();
		  }
		  
		  public SortedSet headSet( final Object oto ) {
				final KEY_TYPE to = KEY2TYPE( oto );

				if ( top ) return new Subset( from, bottom, to, false );
				return compare( to, this.to ) < 0 ? new Subset( from, bottom, to, false ) : this;
		  }
		  
		  public SortedSet tailSet( final Object ofrom ) {
				final KEY_TYPE from = KEY2TYPE( ofrom );

				if ( bottom ) return new Subset( from, false, to, top );
				return compare( from, this.from ) > 0 ? new Subset( from, false, to, top ) : this;
		  }
		  
		  public SortedSet subSet( final Object ofrom, final Object oto ) {
				KEY_TYPE to = KEY2TYPE( oto );
				KEY_TYPE from = KEY2TYPE( ofrom );

				if ( top && bottom ) return new Subset( from, false, to, false );
				if ( ! top ) to = compare( to, this.to ) < 0 ? to : this.to;
				if ( ! bottom ) from = compare( from, this.from ) > 0 ? from : this.from;
				if ( from == this.from && to == this.to ) return this;
				return new Subset( from, false, to, false );
		  }

#if !#keyclass(Object)
		  public SORTEDSET headSet( final KEY_TYPE to ) {
				if ( top ) return new Subset( from, bottom, to, false );
				return compare( to, this.to ) < 0 ? new Subset( from, bottom, to, false ) : this;
		  }
		  
		  public SORTEDSET tailSet( final KEY_TYPE from ) {
				if ( bottom ) return new Subset( from, false, to, top );
				return compare( from, this.from ) > 0 ? new Subset( from, false, to, top ) : this;
		  }
		  
		  public SORTEDSET subSet( KEY_TYPE from, KEY_TYPE to ) {
				if ( top && bottom ) return new Subset( from, false, to, false );
				if ( ! top ) to = compare( to, this.to ) < 0 ? to : this.to;
				if ( ! bottom ) from = compare( from, this.from ) > 0 ? from : this.from;
				if ( from == this.from && to == this.to ) return this;
				return new Subset( from, false, to, false );
		  }
#endif

		  /** Locates a key.
			*
			* @param k a key.
			* @return the last entry on a search for the given key; this will be
			* the given key, if it present; otherwise, it will be either the smallest greater key or the greatest smaller key.
			*/
		  private RBTREESET.Entry locateKey( KEY_TYPE k ) {
				RBTREESET.Entry e = tree, last = tree;
				int cmp = 0;
				
				while ( e != null && ( cmp = compare( k, e.key ) ) != 0 ) {
					 last = e;
					 e = cmp < 0 ? e.left() : e.right();
				}
				
				return cmp == 0 ? e : last;
		  }


		  /** Locates the first entry.
			*
			* @param k a key.
			* @return the first entry of this subset, or <code>null</code> if the subset is empty.
			*/
		  public RBTREESET.Entry firstEntry() {
				if ( tree == null ) return null;
				// If this subset goes to -infinity, we return the main set first entry; otherwise, we locate the start of the set.
				RBTREESET.Entry e;
				if ( bottom ) e = firstEntry;
				else {
					 e = locateKey( from );
					 // If we find either the start or something greater we're OK.
					 if ( compare( e.key, from ) < 0 ) {
						  // Otherwise, we look for a successor.
						  boolean succ = e.succ();
						  e = e.right;
						  // Oops, it's already the last element.
						  if ( e == null ) return null;
						  // If we did not follow a thread we descend the tree on the left.
						  if ( ! succ ) while ( e.left() != null ) e = e.left;
					 }
				}
				// Finally, if this subset doesn't go to infinity, we check that the resulting key isn't greater than the end.
				if ( ! top && compare( e.key, to ) >= 0 ) return null;
				return e;
		  }
	 
		  /** Locates the last entry.
			*
			* @param k a key.
			* @return the last entry of this subset, or <code>null</code> if the subset is empty.
			*/
		  public RBTREESET.Entry lastEntry() {
				if ( tree == null ) return null;
				// If this subset goes to infinity, we return the main set last entry; otherwise, we locate the end of the set.
				RBTREESET.Entry e;
				if ( top ) e = lastEntry;
				else {
					 e = locateKey( to );
					 // If we find something smaller than the end we're OK.
					 if ( compare( e.key, to ) >= 0 ) {
						  // Otherwise, we look for a predecessor.
						  boolean pred = e.pred();
						  e = e.left;
						  // Oops, it's already the first element.
						  if ( e == null ) return null;
						  // If we did not follow a thread we descend the tree on the right.
						  if ( ! pred ) while ( e.right() != null ) e = e.right;
					 }
				}
				// Finally, if this subset doesn't go to -infinity, we check that the resulting key isn't smaller than the start.
				if ( ! bottom && compare( e.key, from ) < 0 ) return null;
				return e;
		  }


		  public KEY_TYPE FIRST() {
				RBTREESET.Entry e = firstEntry();
				if ( e == null ) throw new NoSuchElementException();
				return e.key;
		  }
		  public KEY_TYPE LAST() {
				RBTREESET.Entry e = lastEntry();
				if ( e == null ) throw new NoSuchElementException();
				return e.key;
		  }
	 
#if !#keyclass(Object)
		  public Object first() {
				RBTREESET.Entry e = firstEntry();
				if ( e == null ) throw new NoSuchElementException();
				return e.getKey();
		  }
	 
		  public Object last() {
				RBTREESET.Entry e = lastEntry();
				if ( e == null ) throw new NoSuchElementException();
				return e.getKey();
		  }

#endif

		  /** An iterator for subranges.
			* 
			* <P>This class inherits from {@link SetIterator}, but overrides the methods that
			* update the pointer after a {@link #next()} or {@link #previous()}. If we would
			* move out of the range of the subset we just overwrite the next or previous
			* entry with <code>null</code>.
			*/
		  private class SubsetIterator extends SetIterator {
				protected SubsetIterator() {
					 next = firstEntry();
				}
				protected void updatePrevious() {
					 super.updatePrevious();
					 if ( ! bottom && prev != null && RBTREESET.this.compare( prev.key, from ) < 0 ) prev = null;
				}
				
				protected void updateNext() {
					 super.updateNext();
					 if ( ! top && next != null && RBTREESET.this.compare( next.key, to ) >= 0 ) next = null;
				}
		  }
	 }
	 

    private void writeObject(java.io.ObjectOutputStream s) throws IOException {
		  int n = count;
		  SetIterator i = new SetIterator();

		  s.defaultWriteObject(); while( n-- != 0 ) s.WRITE_KEY( i.NEXT_KEY() );
		  }

    private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
		  s.defaultReadObject();
		  tree = null;
		  /* The storedComparator is now correctly set, but we must restore
			  on-the-fly the actualComparator. */
		  setActualComparator();
		  allocatePaths();

		  int count = this.count;
		  this.count = 0;

		  /* This is not very good. There are linear-time ways of rebuilding a
		  tree.  Maybe in the next release... */

		  while( count-- != 0 ) add( s.READ_KEY() );
    }



#ifdef TEST

	 private static long seed = System.currentTimeMillis(); 
	 private static Random r = new Random( seed );

	 private static KEY_TYPE genKey() {
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
		  return (KEY_TYPE)(r.nextInt());
#elif ! #keyclass(Object)
		  return r.NEXT_KEY(); 
#else
		  return Integer.toBinaryString( r.nextInt() );
#endif
	 }

	 private static java.text.NumberFormat format = new java.text.DecimalFormat( "#,###.00" );
	 private static java.text.FieldPosition p = new java.text.FieldPosition( 0 );

	 private static String format( double d ) {
		  StringBuffer s = new StringBuffer();
		  return format.format( d, s, p ).toString();
	 }

	 private static void speedTest( int n, boolean comp ) {
		  int i, j;
		  SORTEDSET m;
		  SortedSet t;
		  KEY_TYPE k[] = new KEY_TYPE[n];
		  KEY_TYPE nk[] = new KEY_TYPE[n];
		  long ms;

		  for( i = 0; i < n; i++ ) {
				k[i] = genKey();
				nk[i] = genKey();
		  }
		  
		  double totAdd = 0, totYes = 0, totNo = 0, totIterFor = 0, totIterBack = 0, totRemYes = 0, d, dd;

		  if ( comp ) {
		  for( j = 0; j < 20; j++ ) {

				t = new TreeSet();

				/* We first add all pairs to t. */
				for( i = 0; i < n;  i++ ) t.add( KEY2OBJ( k[i] ) );

				/* Then we remove the first half and put it back. */
				for( i = 0; i < n/2;  i++ ) t.remove( KEY2OBJ( k[i] ) );

				ms = System.currentTimeMillis();
				for( i = 0; i < n/2;  i++ ) t.add( KEY2OBJ( k[i] ) );
				d = System.currentTimeMillis() - ms;

				/* Then we remove the other half and put it back again. */
				ms = System.currentTimeMillis();
				for( i = n/2; i < n;  i++ ) t.remove( KEY2OBJ( k[i] ) );
				dd = System.currentTimeMillis() - ms ;

				ms = System.currentTimeMillis();
				for( i = n/2; i < n;  i++ ) t.add( KEY2OBJ( k[i] ) );
				d += System.currentTimeMillis() - ms;
				if ( j > 2 ) totAdd += n/d; 				
				System.out.print("Add: " + format( n/d ) +" K/s " );

				/* Then we remove again the first half. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n/2;  i++ ) t.remove( KEY2OBJ( k[i] ) );
				dd += System.currentTimeMillis() - ms ;
				if ( j > 2 ) totRemYes += n/dd; 				
				System.out.print("RemYes: " + format( n/dd ) +" K/s " );

				/* And then we put it back. */
				for( i = 0; i < n/2;  i++ ) t.add( KEY2OBJ( k[i] ) );

				/* We check for pairs in t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.contains( KEY2OBJ( k[i] ) );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totYes += d; 				
				System.out.print("Yes: " + format( d ) +" K/s " );

				/* We check for pairs not in t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.contains( KEY2OBJ( nk[i] ) );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totNo += d; 				
				System.out.print("No: " + format( d ) +" K/s " );

				/* We iterate on t. */
				ms = System.currentTimeMillis();
				for( Iterator it = t.iterator(); it.hasNext(); it.next() );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totIterFor += d; 				
				System.out.print("IterFor: " + format( d ) +" K/s " );
				
				System.out.println();
		  }

		  System.out.println();
		  System.out.println( "java.util Add: " + format( totAdd/(j-3) ) + " K/s RemYes: " + format( totRemYes/(j-3) ) + " K/s Yes: " + format( totYes/(j-3) ) + " K/s No: " + format( totNo/(j-3) ) + " K/s IterFor: " + format( totIterFor/(j-3) )  + " K/s"  );

		  System.out.println();

		  totAdd = totYes = totNo = totIterFor = totIterBack = totRemYes;

		  }

		  for( j = 0; j < 20; j++ ) {

				m = new RBTREESET();


				/* We first add all pairs to m. */
				for( i = 0; i < n;  i++ ) m.add( k[i] );

				/* Then we remove the first half and put it back. */
				for( i = 0; i < n/2;  i++ ) m.remove( k[i] );

				ms = System.currentTimeMillis();
				for( i = 0; i < n/2;  i++ ) m.add( k[i] );
				d = System.currentTimeMillis() - ms;

				/* Then we remove the other half and put it back again. */
				ms = System.currentTimeMillis();
				for( i = n/2; i < n;  i++ ) m.remove( k[i] );
				dd = System.currentTimeMillis() - ms ;

				ms = System.currentTimeMillis();
				for( i = n/2; i < n;  i++ ) m.add( k[i] );
				d += System.currentTimeMillis() - ms;
				if ( j > 2 ) totAdd += n/d; 				
				System.out.print("Add: " + format( n/d ) +" K/s " );

				/* Then we remove again the first half. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n/2;  i++ ) m.remove( k[i] );
				dd += System.currentTimeMillis() - ms ;
				if ( j > 2 ) totRemYes += n/dd; 				
				System.out.print("RemYes: " + format( n/dd ) +" K/s " );

				/* And then we put it back. */
				for( i = 0; i < n/2;  i++ ) m.add( k[i] );

				/* We check for pairs in m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.contains( k[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totYes += d; 				
				System.out.print("Yes: " + format( d ) +" K/s " );

				/* We check for pairs not in m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.contains( nk[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totNo += d; 				
				System.out.print("No: " + format( d ) +" K/s " );

				/* We iterate on m. */
				ListIterator it = (ListIterator)m.iterator();
				ms = System.currentTimeMillis();
				for( ; it.hasNext(); it.next() );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totIterFor += d; 				
				System.out.print("IterFor: " + format( d ) +" K/s " );
				
				/* We iterate back on m. */
				ms = System.currentTimeMillis();
				for( ; it.hasPrevious(); it.previous() );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totIterBack += d; 				
				System.out.print("IterBack: " + format( d ) +" K/s " );
				
				System.out.println();
		  }


		  System.out.println();
		  System.out.println( "fastUtil  Add: " + format( totAdd/(j-3) ) + " K/s RemYes: " + format( totRemYes/(j-3) ) + " K/s Yes: " + format( totYes/(j-3) ) + " K/s No: " + format( totNo/(j-3) ) + " K/s IterFor: " + format( totIterFor/(j-3) )  + " K/s IterBack: " + format( totIterBack/(j-3) ) + "K/s"  );

		  System.out.println();
	 }


	 private static boolean valEquals(Object o1, Object o2) {
		  return o1 == null ? o2 == null : o1.equals(o2);
	 }

	 private static void fatal( String msg ) {
		  System.out.println( msg );
		  System.exit( 1 );
	 }

	 private static void ensure( boolean cond, String msg ) {
		  if ( cond ) return;
		  fatal( msg );
	 }

	 private static Object[] k, v, nk;
	 private static KEY_TYPE kt[];
	 private static KEY_TYPE nkt[];
	 private static RBTREESET topSet;

	 private static void testSets( SORTEDSET m, SortedSet t, int n, int level ) {
		  long ms;
		  boolean mThrowsIllegal, tThrowsIllegal, mThrowsNoElement, tThrowsNoElement;
		  boolean rt = false, rm = false;

		  if ( level > 4 ) return;
				

		  /* Now we check that both sets agree on first/last keys. */

		  mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		  try {
				m.first();
		  }
		  catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		  try {
				t.first();
		  }
		  catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		  ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): first() divergence at start in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
		  if ( ! mThrowsNoElement ) ensure( t.first().equals( m.first() ), "Error (" + level + ", " + seed + "): m and t differ at start on their first key (" + m.first() + ", " + t.first() +")" );

		  mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		  try {
				m.last();
		  }
		  catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		  try {
				t.last();
		  }
		  catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		  ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): last() divergence at start in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );


		  if ( ! mThrowsNoElement ) ensure( t.last().equals( m.last() ), "Error (" + level + ", " + seed + "): m and t differ at start on their last key (" + m.last() + ", " + t.last() +")");


		  /* Now we check that m and t are equal. */
		  if ( !m.equals( t ) || ! t.equals( m ) ) System.err.println("m: " + m + " t: " + t);

		  ensure( m.equals( t ), "Error (" + level + ", " + seed + "): ! m.equals( t ) at start" );
		  ensure( t.equals( m ), "Error (" + level + ", " + seed + "): ! t.equals( m ) at start" );



		  /* Now we check that m actually holds that data. */
		  for(Iterator i=t.iterator(); i.hasNext();  ) {
		      ensure( m.contains( i.next() ), "Error (" + level + ", " + seed + "): m and t differ on an entry after insertion (iterating on t)" );
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  for(Iterator i=m.iterator(); i.hasNext();  ) {
		      ensure( t.contains( i.next() ), "Error (" + level + ", " + seed + "): m and t differ on an entry after insertion (iterating on m)" );
		  }

		  /* Now we check that inquiries about random data give the same answer in m and t. For
			  m we use the polymorphic method. */

		  for(int i=0; i<n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 Integer.toBinaryString( r.nextInt() )
#endif
					 ;
				
				mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;

				try {
					 m.contains(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }

				try {
					 t.contains(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }

				ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): contains() divergence in NoSuchElementException (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
				ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): contains() divergence in IllegalArgumentException (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
				if ( !mThrowsNoElement && !mThrowsIllegal ) ensure( m.contains(KEY2OBJ(T)) == t.contains(KEY2OBJ(T)), "Error (" + level + ", " + seed + "): divergence in keys between t and m (polymorphic method)" );
		  }

		  /* Again, we check that inquiries about random data give the same answer in m and t, but
			  for m we use the standard method. */

		  for(int i=0; i<n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 Integer.toBinaryString( r.nextInt() )
#endif
					 ;

				mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;

				try {
					 m.contains(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }

				try {
					 t.contains(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }

				ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): contains() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
				ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): contains() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
				if ( !mThrowsNoElement && !mThrowsIllegal ) ensure( m.contains(KEY2OBJ(T)) ==  t.contains(KEY2OBJ(T)), "Error (" + level + ", " + seed + "): divergence between t and m (standard method)" );
		  }

		  /* Now we add and remove random data in m and t, checking that the result is the same. */

		  for(int i=0; i<20*n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 Integer.toBinaryString( r.nextInt() )
#endif
					 ;

				mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;

				try {
					 rm = m.add(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }

				try {
					 rt = t.add(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }


				ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): add() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
				ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): add() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
				if ( !mThrowsNoElement && !mThrowsIllegal ) ensure( rm == rt, "Error (" + level + ", " + seed + "): divergence in add() between t and m" );

				T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 Integer.toBinaryString( r.nextInt() )
#endif
					 ;


				mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;

				try {
					 rm = m.remove(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }

				try {
					 rt = t.remove(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }


				ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): remove() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
				ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): remove() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
				if ( !mThrowsNoElement && !mThrowsIllegal ) ensure( rm == rt, "Error (" + level + ", " + seed + "): divergence in remove() between t and m" );
		  }

		  ensure( m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals( t ) after removal" );
		  ensure( t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals( m ) after removal" );

		  /* Now we check that m actually holds the same data. */
		  
		  for(Iterator i=t.iterator(); i.hasNext();  ) {
		      ensure( m.contains( i.next() ), "Error (" + level + ", " + seed + "): m and t differ on an entry after removal (iterating on t)");
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  
		  for(Iterator i=m.iterator(); i.hasNext();  ) {
		      ensure( t.contains( i.next() ), "Error (" + level + ", " + seed + "): m and t differ on an entry after removal (iterating on m)" );
		  }

		  /* Now we check that both sets agree on first/last keys. */

		  mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		  try {
				m.first();
		  }
		  catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		  try {
				t.first();
		  }
		  catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		  ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): first() divergence in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
		  if ( ! mThrowsNoElement ) ensure( t.first().equals( m.first() ), "Error (" + level + ", " + seed + "): m and t differ on their first key (" + m.first() + ", " + t.first() +")" );

		  mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		  try {
				m.last();
		  }
		  catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		  try {
				t.last();
		  }
		  catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		  ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): last() divergence in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );

		  if ( ! mThrowsNoElement ) ensure( t.last().equals( m.last() ), "Error (" + level + ", " + seed + "): m and t differ on their last key (" + m.last() + ", " + t.last() +")");



		  int h = m.hashCode();


		  /* Now we save and read m. */

		  SORTEDSET m2 = null;
		  
		  try {
				java.io.File ff = new java.io.File("regressionTest");
				java.io.OutputStream os = new java.io.FileOutputStream(ff);
				java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);
				
				oos.writeObject(m);
				oos.close();
				
				java.io.InputStream is = new java.io.FileInputStream(ff);
				java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);
				
				m2 = (SORTEDSET)ois.readObject();
				ois.close();
				ff.delete();
		  }
		  catch(Exception e) {
				e.printStackTrace();
				System.exit(-1);
		  }

		  ensure( m2.hashCode() == h, "Error (" + level + ", " + seed + "): hashCode() changed after save/read" );
		  
		  /* Now we check that m2 actually holds that data. */
		  
		  ensure( m2.equals(t), "Error (" + level + ", " + seed + "): ! m2.equals( t ) after save/read" );
		  ensure( t.equals(m2), "Error (" + level + ", " + seed + "): ! t.equals( m2 ) after save/read" );

		  /* Now we take out of m everything, and check that it is empty. */

		  for(Iterator i=t.iterator(); i.hasNext(); ) m2.remove(i.next());

		  ensure( m2.isEmpty(), "Error (" + level + ", " + seed + "): m2 is not empty (as it should be)" );
				 
		  /* Now we play with iterators. */

		  {
				ListIterator i, j;
				Object J;
				i = (ListIterator)m.iterator(); 
				j = new LinkedList( t ).listIterator(); 

				for( int k = 0; k < n/2; k++ ) {
					 ensure( i.hasNext() == j.hasNext(), "Error (" + level + ", " + seed + "): divergence in hasNext()" );
					 ensure( i.hasPrevious() == j.hasPrevious(), "Error (" + level + ", " + seed + "): divergence in hasPrevious()" );

					 if ( r.nextFloat() < .8 && i.hasNext() ) {
						  ensure( i.next().equals( J = j.next() ), "Error (" + level + ", " + seed + "): divergence in next()" );

						  if ( r.nextFloat() < 0.05 ) {
								i.remove();
								j.remove();
								t.remove( J );
						  }
					 }
					 else if ( r.nextFloat() < .2 && i.hasPrevious() ) {
						  ensure( i.previous().equals( J = j.previous() ), "Error (" + level + ", " + seed + "): divergence in previous()" );

						  if ( r.nextFloat() < 0.05 ) {
								i.remove();
								j.remove();
								t.remove( J );
						  }
					 }

					 ensure( i.nextIndex() == j.nextIndex(), "Error (" + level + ", " + seed + "): divergence in nextIndex()" );
					 ensure( i.previousIndex() == j.previousIndex(), "Error (" + level + ", " + seed + "): divergence in previousIndex()" );

				}

		  }

		  /* Now we check that m actually holds that data. */
		  
		  ensure( m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals( t ) after iteration" );
		  ensure( t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals( m ) after iteration" );

		  /* Now we select a pair of keys and create a subset. */

		  if ( ! m.isEmpty() ) {
				ListIterator i;
				Object start = m.first(), end = m.first();
				for( i = (ListIterator)m.iterator(); i.hasNext() && r.nextFloat() < .3; start = end = i.next() );
				for( ; i.hasNext() && r.nextFloat() < .95; end = i.next() );

				//System.err.println("Checking subSet from " + start + " to " + end + " (level=" + (level+1) + ")..." );
				testSets( (SORTEDSET)m.subSet( start, end ), t.subSet( start, end ), n, level + 1 );

				ensure( m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals( t ) after subSet" );
				ensure( t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals( m ) after subSet" );

				//System.err.println("Checking headSet to " + end + " (level=" + (level+1) + ")..." );
				testSets( (SORTEDSET)m.headSet( end ), t.headSet( end ), n, level + 1 );

				ensure( m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals( t ) after headSet" );
				ensure( t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals( m ) after headSet" );

				//System.err.println("Checking tailSet from " + start + " (level=" + (level+1) + ")..." );
				testSets( (SORTEDSET)m.tailSet( start ), t.tailSet( start ), n, level + 1 );

				ensure( m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals( t ) after tailSet" );
				ensure( t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals( m ) after tailSet" );
		  }
		  

	 }


	 private static void regressionTest( int n ) {
		  RBTREESET m = new RBTREESET();
		  SortedSet t = new TreeSet();
		  topSet = m;
		  k = new Object[n];
		  nk = new Object[n];
		  kt = new KEY_TYPE[n];
		  nkt = new KEY_TYPE[n];

		  for( int i = 0; i < n; i++ ) {
#if #keyclass(Object)
				k[i] = kt[i] = genKey();
				nk[i] = nkt[i] = genKey();
#else
				k[i] = new KEY_CLASS( kt[i] = genKey() );
				nk[i] = new KEY_CLASS( nkt[i] = genKey() );
#endif
		  }
		  
		  /* We add pairs to t. */
		  for( int i = 0; i < n;  i++ ) t.add( k[i] );
		  
		  /* We add to m the same data */
		  m.addAll(t);

		  testSets( m, t, n, 0 );

		  System.out.println("Regression test OK");
		  System.exit(0);
	 }


	 public static void main( String args[] ) {
		  int n  = Integer.parseInt(args[1]);
		  
		  if ("speedTest".equals(args[0]) || "speedComp".equals(args[0])) speedTest( n, "speedComp".equals(args[0]) );
		  else if ( "regressionTest".equals( args[0] ) ) regressionTest(n);
	 }

#endif


}

// Local Variables:
// mode: java
// End:
