/*		 
 * fastutil: Fast & compact type-specific collections for Java
 *
 * Copyright (C) 2002, 2003 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package PACKAGE;

import it.unimi.dsi.fastutil.booleans.*;
import it.unimi.dsi.fastutil.bytes.*;
import it.unimi.dsi.fastutil.shorts.*;
import it.unimi.dsi.fastutil.chars.*;
import it.unimi.dsi.fastutil.ints.*;
import it.unimi.dsi.fastutil.longs.*;
import it.unimi.dsi.fastutil.floats.*;
import it.unimi.dsi.fastutil.doubles.*;
import it.unimi.dsi.fastutil.objects.*;

import it.unimi.dsi.fastutil.Iterators;
import it.unimi.dsi.fastutil.HashCommon;
import it.unimi.dsi.fastutil.Sets;

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Map;
import java.util.SortedSet;
import java.util.SortedMap;
import java.util.NoSuchElementException;

/** A class providing static methods that do useful things with type-specific maps.
 *
 * @see java.util.Collections
 */

public class MAPS {

	private MAPS() {}


	/** A class representing an empty map. */

	protected static class EmptyMap extends ABSTRACT_MAP implements java.io.Serializable, Cloneable {
	
		public static final long serialVersionUID = -7046029254386353129L;
	
		protected EmptyMap() {}
	
		public VALUE_TYPE put( final KEY_TYPE k, final VALUE_TYPE v ) { throw new UnsupportedOperationException(); }
		public Object get( final Object ok ) { return null; }

		public boolean containsKey( final KEY_TYPE k ) { return false; }
		public boolean containsValue( final VALUE_TYPE v ) { return false; }

		public VALUE_TYPE defaultReturnValue()  { return VALUE_NULL; }
		public void defaultReturnValue( final VALUE_TYPE defRetValue )  { throw new UnsupportedOperationException(); }
	
		public void putAll( final Map m ) { throw new UnsupportedOperationException(); }

		public Set entrySet() { return Sets.EMPTY_SET; }
		public Set keySet() { return Sets.EMPTY_SET; }
		public Collection values() { return Sets.EMPTY_SET; }


#if ( ! #keyclass( Object ) && ! #keyclass( Reference ) ) || ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public Object put( final Object k, final Object v ) { throw new UnsupportedOperationException(); }
#endif

#if ! #keyclass( Object ) && ! #keyclass( Reference )
		public VALUE_TYPE remove( final KEY_TYPE k ) { throw new UnsupportedOperationException(); }
		public VALUE_TYPE get( final KEY_TYPE k ) { return VALUE_NULL; }
		public boolean containsKey( final Object ok ) { return false; }
#endif

#if ! #valueclass( Object ) && ! #valueclass( Reference )
		public boolean containsValue( final Object ov ) { return false; }
#endif

#if ( #keyclass( Object ) || #keyclass( Reference ) ) && ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public VALUE_TYPE REMOVE_VALUE( final Object k ) { throw new UnsupportedOperationException(); }
		public VALUE_TYPE GET_VALUE( final Object k ) { throw new UnsupportedOperationException(); }
#endif

		public int size() { return 0; }
		public void clear() {}
	
        private Object readResolve() { return EMPTY_MAP; }

		public Object clone() { return EMPTY_MAP; }
	}



	/** An empty type-specific map (immutable). It is serializable and cloneable. */
	 
	public static final EmptyMap EMPTY_MAP = new EmptyMap();


	/** An immutable class representing a type-specific singleton map. */

	protected static class Singleton extends ABSTRACT_MAP implements java.io.Serializable, Cloneable {
	
		public static final long serialVersionUID = -7046029254386353129L;
	
		protected final KEY_TYPE key;
		protected final VALUE_TYPE value;

		protected transient volatile Set entries, keys;
		protected transient volatile Collection values;

		protected Singleton( final KEY_TYPE key, final VALUE_TYPE value ) {
			this.key = key;
			this.value = value;
		}
	
		public VALUE_TYPE put( final KEY_TYPE k, final VALUE_TYPE v ) { throw new UnsupportedOperationException(); }
		public Object get( final Object k ) { if ( KEY_EQUAL( key, KEY2TYPE( k ) ) ) return VALUE2OBJ( value ); else return null; }

		public boolean containsKey( final KEY_TYPE k ) { return KEY_EQUAL( key, k ); }
		public boolean containsValue( final VALUE_TYPE v ) { return VALUE_EQUAL( value, v ); }

		public VALUE_TYPE defaultReturnValue()  { return VALUE_NULL; }
		public void defaultReturnValue( final VALUE_TYPE defRetValue )  { throw new UnsupportedOperationException(); }

		public void putAll( final Map m ) { throw new UnsupportedOperationException(); }

		public Set entrySet() { if ( entries == null ) entries = ObjectSets.singleton( new SingletonEntry() ); return entries; }
		public Set keySet() { if ( keys == null ) keys = SETS.singleton( key ); return keys; }
		public Collection values() { if ( values == null ) values = VALUE_SETS.singleton( value ); return values; }

		private class SingletonEntry implements Map.Entry {
			public Object getKey() { return KEY2OBJ( Singleton.this.key ); }
			public Object getValue() { return VALUE2OBJ( Singleton.this.value ); }
			public Object setValue( final Object value ) { throw new UnsupportedOperationException(); }
			
			public boolean equals( final Object o ) {
				if (!(o instanceof MAP.Entry)) return false;
				MAP.Entry e = (MAP.Entry)o;
			
				return KEY_EQUAL( Singleton.this.key, KEY2TYPE( e.getKey() ) ) && VALUE_EQUAL( Singleton.this.value, VALUE2TYPE( e.getValue() ) );
			}
			
			public int hashCode() { return KEY2INT( Singleton.this.key ) ^ VALUE2INT( Singleton.this.value ); }
			public String toString() { return Singleton.this.key + "->" + Singleton.this.value; }
		}


#if ( ! #keyclass( Object ) && ! #keyclass( Reference ) ) || ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public Object put( final Object k, final Object v ) { throw new UnsupportedOperationException(); }
#endif

#if ! #keyclass( Object ) && ! #keyclass( Reference )
		public VALUE_TYPE remove( final KEY_TYPE k ) { throw new UnsupportedOperationException(); }
		public VALUE_TYPE get( final KEY_TYPE k ) { if ( KEY_EQUAL( key, k ) ) return value; else return VALUE_NULL; }
		public boolean containsKey( final Object ok ) { return containsKey( KEY2TYPE( ok ) ); }
#endif

#if ! #valueclass( Object ) && ! #valueclass( Reference )
		public boolean containsValue( final Object ov ) { return VALUE_EQUAL( value, VALUE2TYPE( ov ) ); }
#endif

#if ( #keyclass( Object ) || #keyclass( Reference ) ) && ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public VALUE_TYPE REMOVE_VALUE( final Object k ) { throw new UnsupportedOperationException(); }
		public VALUE_TYPE GET_VALUE( final Object k ) { throw new UnsupportedOperationException(); }
#endif

		public int size() { return 1; }
		public void clear() { throw new UnsupportedOperationException(); }
	
		public Object clone() { return this; }
	}

	/** Returns a type-specific immutable map containing only the specified pair. The returned map is serializable and cloneable.
	 *
	 * @param key the only key of the returned map.
	 * @param value the only value of the returned map.
	 * @return a type-specific immutable map containing just the pair <code>&lt;key,value></code>.
	 */

	public static MAP singleton( final KEY_TYPE key, VALUE_TYPE value ) {
		return new Singleton( key, value );
	}

#if ( ! #keyclass( Object ) && ! #keyclass( Reference ) ) || ( ! #valueclass( Object ) && ! #valueclass( Reference ) )

	/** Returns a type-specific immutable map containing only the specified pair. The returned map is serializable and cloneable.
	 *
	 * @param key the only key of the returned map.
	 * @param value the only value of the returned map.
	 * @return a type-specific immutable map containing just the pair <code>&lt;key,value></code>.
	 */

	public static MAP singleton( final Object key, final Object value ) {
		return new Singleton( KEY2TYPE( key ), VALUE2TYPE( value ) );
	}

#endif


	protected static class SynchronizedMap extends ABSTRACT_MAP implements MAP, java.io.Serializable {

		public static final long serialVersionUID = -7046029254386353129L;

		protected final MAP map;
		protected final Object sync;

		protected transient volatile Set entries, keys;
		protected transient volatile Collection values;

		SynchronizedMap( final MAP m, final Object sync ) {
			if ( m == null ) throw new NullPointerException();
			this.map = m;
			this.sync = sync;
		}

		SynchronizedMap( final MAP m ) {
			if ( m == null ) throw new NullPointerException();
			this.map = m;
			this.sync = this;
		}

		public Object remove( final Object ok ) { synchronized( sync ) { return map.remove( ok ); } }
		public Object get( final Object ok ) { synchronized( sync ) { return map.get( ok ); } }

		public int size() { synchronized( sync ) { return map.size(); } }
		public boolean containsKey( final KEY_TYPE k ) { synchronized( sync ) { return map.containsKey( k ); } }
		public boolean containsValue( final VALUE_TYPE v ) { synchronized( sync ) { return map.containsValue( v ); } }

		public VALUE_TYPE defaultReturnValue()  { synchronized( sync ) { return map.defaultReturnValue(); } }
		public void defaultReturnValue( final VALUE_TYPE defRetValue )  { synchronized( sync ) { map.defaultReturnValue( defRetValue ); } }

		public VALUE_TYPE put( final KEY_TYPE k, final VALUE_TYPE v ) { synchronized( sync ) { return map.put( k, v ); } }

		public void putAll( final MAP c ) { synchronized( sync ) { map.putAll( c ); } }

		public Set entrySet() { if ( entries == null ) entries = ObjectSets.synchronize( (ObjectSet)map.entrySet(), sync ); return entries; }
		public Set keySet() { if ( keys == null ) keys = SETS.synchronize( (SET)map.keySet(), sync ); return keys; }
		public Collection values() { if ( values == null ) return VALUE_COLLECTIONS.synchronize( (VALUE_COLLECTION)map.values(), sync ); return values; }

		public void clear() { synchronized( sync ) { map.clear(); } }
		public String toString() { synchronized( sync ) { return map.toString(); } }

#if ( ! #keyclass( Object ) && ! #keyclass( Reference ) ) || ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public Object put( final Object k, final Object v ) { synchronized( sync ) { return map.put( k, v ); } }
#endif

#if ! #keyclass( Object ) && ! #keyclass( Reference )
		public VALUE_TYPE remove( final KEY_TYPE k ) { synchronized( sync ) { return map.remove( k ); } }
		public VALUE_TYPE get( final KEY_TYPE k ) { synchronized( sync ) { return map.get( k ); } }
		public boolean containsKey( final Object ok ) { synchronized( sync ) { return map.containsKey( ok ); } }
#endif

#if ! #valueclass( Object ) && ! #valueclass( Reference )
		public boolean containsValue( final Object ov ) { synchronized( sync ) { return map.containsValue( ov ); } }
#endif

#if ( #keyclass( Object ) || #keyclass( Reference ) ) && ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public VALUE_TYPE REMOVE_VALUE( final Object k ) { synchronized( sync ) { return map.REMOVE_VALUE( k ); } }
		public VALUE_TYPE GET_VALUE( final Object k ) { synchronized( sync ) { return map.GET_VALUE( k ); } }
#endif

	}

	/** Returns a synchronized type-specific map backed by the specified type-specific map.
	 *
	 * @param m the map to be wrapped in a synchronized map.
	 * @return a synchronized view of the specified map.
	 * @see java.util.Collections#synchronizedMap(Map)
	 */
	public static MAP synchronize( final MAP m ) { return new SynchronizedMap( m ); }

	/** Returns a synchronized type-specific map backed by the specified type-specific map, using an assigned object to synchronize.
	 *
	 * @param m the map to be wrapped in a synchronized map.
	 * @param sync an object that will be used to synchronize the access to the map.
	 * @return a synchronized view of the specified map.
	 * @see java.util.Collections#synchronizedMap(Map)
	 */

	public static MAP synchronize( final MAP m, final Object sync ) { return new SynchronizedMap( m, sync ); }



	
}

// Local Variables:
// mode: jde
// tab-width: 4
// End:
