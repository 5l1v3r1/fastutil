/*		 
 * fastutil: Fast & compact type-specific collections for Java
 *
 * Copyright (C) 2002, 2003, 2004, 2005, 2006 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package PACKAGE;

import it.unimi.dsi.fastutil.Iterators;
import it.unimi.dsi.fastutil.HashCommon;
import it.unimi.dsi.fastutil.Sets;

import it.unimi.dsi.fastutil.objects.ObjectSet;
import it.unimi.dsi.fastutil.objects.ObjectSets;

import VALUE_PACKAGE.VALUE_COLLECTION;
import VALUE_PACKAGE.VALUE_COLLECTIONS;
import VALUE_PACKAGE.VALUE_SETS;
import VALUE_PACKAGE.VALUE_ABSTRACT_COLLECTION;
import VALUE_PACKAGE.VALUE_ITERATOR;
import VALUE_PACKAGE.VALUE_LIST_ITERATOR;

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Map;
import java.util.SortedSet;
import java.util.SortedMap;
import java.util.NoSuchElementException;

/** A class providing static methods and objects that do useful things with type-specific maps.
 *
 * @see it.unimi.dsi.fastutil.Maps
 * @see java.util.Collections
 */

public class MAPS {

	private MAPS() {}


	/** An immutable class representing an empty type-specific map.
	 *
	 * <P>This class may be useful to implement your own in case you subclass
	 * a type-specific map.
	 */

	public static class EmptyMap extends ABSTRACT_MAP implements java.io.Serializable, Cloneable {
	
		public static final long serialVersionUID = -7046029254386353129L;
	
		protected EmptyMap() {}
	
		public VALUE_TYPE put( final KEY_TYPE k, final VALUE_TYPE v ) { throw new UnsupportedOperationException(); }
		public Object get( final Object ok ) { return null; }

		public boolean containsKey( final KEY_TYPE k ) { return false; }
		public boolean containsValue( final VALUE_TYPE v ) { return false; }

		public VALUE_TYPE defaultReturnValue()  { return VALUE_NULL; }
		public void defaultReturnValue( final VALUE_TYPE defRetValue )  { throw new UnsupportedOperationException(); }
	
		public void putAll( final Map m ) { throw new UnsupportedOperationException(); }

		public Set entrySet() { return Sets.EMPTY_SET; }
		public Set keySet() { return Sets.EMPTY_SET; }
		public Collection values() { return Sets.EMPTY_SET; }


#if ( ! #keyclass( Object ) && ! #keyclass( Reference ) ) || ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public Object put( final Object k, final Object v ) { throw new UnsupportedOperationException(); }
#endif

#if ! #keyclass( Object ) && ! #keyclass( Reference )
		public VALUE_TYPE get( final KEY_TYPE k ) { return VALUE_NULL; }
		public boolean containsKey( final Object ok ) { return false; }
#endif

#if ! #valueclass( Object ) && ! #valueclass( Reference )
		public boolean containsValue( final Object ov ) { return false; }
#endif

#if ( #keyclass( Object ) || #keyclass( Reference ) ) && ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public VALUE_TYPE GET_VALUE( final Object k ) { return VALUE_NULL; }
#endif

		public int size() { return 0; }
		public void clear() {}
	
        private Object readResolve() { return EMPTY_MAP; }

		public Object clone() { return EMPTY_MAP; }
	}



	/** An empty type-specific map (immutable). It is serializable and cloneable. */
	 
	public static final EmptyMap EMPTY_MAP = new EmptyMap();


	/** An immutable class representing a type-specific singleton map.	 
	 *
	 * <P>This class may be useful to implement your own in case you subclass
	 * a type-specific map.
	 */

	public static class Singleton extends ABSTRACT_MAP implements java.io.Serializable, Cloneable {
	
		public static final long serialVersionUID = -7046029254386353129L;
	
		protected final KEY_TYPE key;
		protected final VALUE_TYPE value;

		protected transient volatile Set entries, keys;
		protected transient volatile Collection values;

		protected Singleton( final KEY_TYPE key, final VALUE_TYPE value ) {
			this.key = key;
			this.value = value;
		}
	
		public boolean containsKey( final KEY_TYPE k ) { return KEY_EQUALS( key, k ); }
		public boolean containsValue( final VALUE_TYPE v ) { return VALUE_EQUAL( value, v ); }

		public void putAll( final Map m ) { throw new UnsupportedOperationException(); }

		public Set entrySet() { if ( entries == null ) entries = ObjectSets.singleton( new SingletonEntry() ); return entries; }
		public Set keySet() { if ( keys == null ) keys = SETS.singleton( key ); return keys; }
		public Collection values() { if ( values == null ) values = VALUE_SETS.singleton( value ); return values; }

		private class SingletonEntry implements MAP.Entry {
			public Object getKey() { return KEY2OBJ( Singleton.this.key ); }
			public Object getValue() { return VALUE2OBJ( Singleton.this.value ); }

#if !#keyclass(Object) && ! #keyclass(Reference)
			public KEY_TYPE ENTRY_GET_KEY() { return Singleton.this.key; }
#endif

#if !#valueclass(Object) && ! #valueclass(Reference)
			public VALUE_TYPE ENTRY_GET_VALUE() { return Singleton.this.value; }
			public VALUE_TYPE setValue( final VALUE_TYPE value ) { throw new UnsupportedOperationException(); }
#endif

			public Object setValue( final Object value ) { throw new UnsupportedOperationException(); }
			
			public boolean equals( final Object o ) {
				if (!(o instanceof Map.Entry)) return false;
				Map.Entry e = (Map.Entry)o;
			
				return KEY_EQUALS( Singleton.this.key, KEY2TYPE( e.getKey() ) ) && VALUE_EQUAL( Singleton.this.value, VALUE2TYPE( e.getValue() ) );
			}
			
			public int hashCode() { return KEY2INT( Singleton.this.key ) ^ VALUE2INT( Singleton.this.value ); }
			public String toString() { return Singleton.this.key + "->" + Singleton.this.value; }
		}


		public VALUE_TYPE GET_VALUE( final KEY_TYPE k ) { if ( KEY_EQUALS( key, k ) ) return value; else return defRetValue; }

		public int size() { return 1; }
	
		public Object clone() { return this; }
	}

	/** Returns a type-specific immutable map containing only the specified pair. The returned map is serializable and cloneable.
	 *
	 * <P>Note that albeit the returned map is immutable, its default return value may be changed.
	 *
	 * @param key the only key of the returned map.
	 * @param value the only value of the returned map.
	 * @return a type-specific immutable map containing just the pair <code>&lt;key,value></code>.
	 */

	public static MAP singleton( final KEY_TYPE key, VALUE_TYPE value ) {
		return new Singleton( key, value );
	}

#if ( ! #keyclass( Object ) && ! #keyclass( Reference ) ) || ( ! #valueclass( Object ) && ! #valueclass( Reference ) )

	/** Returns a type-specific immutable map containing only the specified pair. The returned map is serializable and cloneable.
	 *
	 * <P>Note that albeit the returned map is immutable, its default return value may be changed.
	 *
	 * @param key the only key of the returned map.
	 * @param value the only value of the returned map.
	 * @return a type-specific immutable map containing just the pair <code>&lt;key,value></code>.
	 */

	public static MAP singleton( final Object key, final Object value ) {
		return new Singleton( KEY2TYPE( key ), VALUE2TYPE( value ) );
	}

#endif


	/** A synchronized wrapper class for maps. */

	public static class SynchronizedMap extends ABSTRACT_MAP implements MAP, java.io.Serializable {

		public static final long serialVersionUID = -7046029254386353129L;

		protected final MAP map;
		protected final Object sync;

		protected transient volatile Set entries, keys;
		protected transient volatile Collection values;

		protected SynchronizedMap( final MAP m, final Object sync ) {
			if ( m == null ) throw new NullPointerException();
			this.map = m;
			this.sync = sync;
		}

		protected SynchronizedMap( final MAP m ) {
			if ( m == null ) throw new NullPointerException();
			this.map = m;
			this.sync = this;
		}

		public Object remove( final Object ok ) { synchronized( sync ) { return map.remove( ok ); } }
		public Object get( final Object ok ) { synchronized( sync ) { return map.get( ok ); } }

		public int size() { synchronized( sync ) { return map.size(); } }
		public boolean containsKey( final KEY_TYPE k ) { synchronized( sync ) { return map.containsKey( k ); } }
		public boolean containsValue( final VALUE_TYPE v ) { synchronized( sync ) { return map.containsValue( v ); } }

		public VALUE_TYPE defaultReturnValue()  { synchronized( sync ) { return map.defaultReturnValue(); } }
		public void defaultReturnValue( final VALUE_TYPE defRetValue )  { synchronized( sync ) { map.defaultReturnValue( defRetValue ); } }

		public VALUE_TYPE put( final KEY_TYPE k, final VALUE_TYPE v ) { synchronized( sync ) { return map.put( k, v ); } }

		public void putAll( final MAP c ) { synchronized( sync ) { map.putAll( c ); } }
		public void putAll( final Map m ) { synchronized( sync ) { map.putAll( m ); } }

		public Set entrySet() { if ( entries == null ) entries = ObjectSets.synchronize( (ObjectSet)map.entrySet(), sync ); return entries; }
		public Set keySet() { if ( keys == null ) keys = SETS.synchronize( (SET)map.keySet(), sync ); return keys; }
		public Collection values() { if ( values == null ) return VALUE_COLLECTIONS.synchronize( (VALUE_COLLECTION)map.values(), sync ); return values; }

		public void clear() { synchronized( sync ) { map.clear(); } }
		public String toString() { synchronized( sync ) { return map.toString(); } }

#if ( ! #keyclass( Object ) && ! #keyclass( Reference ) ) || ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public Object put( final Object k, final Object v ) { synchronized( sync ) { return map.put( k, v ); } }
#endif

#if ! #keyclass( Object ) && ! #keyclass( Reference )
		public VALUE_TYPE remove( final KEY_TYPE k ) { synchronized( sync ) { return map.remove( k ); } }
		public VALUE_TYPE get( final KEY_TYPE k ) { synchronized( sync ) { return map.get( k ); } }
		public boolean containsKey( final Object ok ) { synchronized( sync ) { return map.containsKey( ok ); } }
#endif

#if ! #valueclass( Object ) && ! #valueclass( Reference )
		public boolean containsValue( final Object ov ) { synchronized( sync ) { return map.containsValue( ov ); } }
#endif

#if ( #keyclass( Object ) || #keyclass( Reference ) ) && ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public VALUE_TYPE REMOVE_VALUE( final Object k ) { synchronized( sync ) { return map.REMOVE_VALUE( k ); } }
		public VALUE_TYPE GET_VALUE( final Object k ) { synchronized( sync ) { return map.GET_VALUE( k ); } }
#endif

	}

	/** Returns a synchronized type-specific map backed by the given type-specific map.
	 *
	 * @param m the map to be wrapped in a synchronized map.
	 * @return a synchronized view of the specified map.
	 * @see java.util.Collections#synchronizedMap(Map)
	 */
	public static MAP synchronize( final MAP m ) { return new SynchronizedMap( m ); }

	/** Returns a synchronized type-specific map backed by the given type-specific map, using an assigned object to synchronize.
	 *
	 * @param m the map to be wrapped in a synchronized map.
	 * @param sync an object that will be used to synchronize the access to the map.
	 * @return a synchronized view of the specified map.
	 * @see java.util.Collections#synchronizedMap(Map)
	 */

	public static MAP synchronize( final MAP m, final Object sync ) { return new SynchronizedMap( m, sync ); }



	/** An unmodifiable wrapper class for maps. */

	public static class UnmodifiableMap extends ABSTRACT_MAP implements MAP, java.io.Serializable {

		public static final long serialVersionUID = -7046029254386353129L;

		protected final MAP map;

		protected transient volatile Set entries, keys;
		protected transient volatile Collection values;

		protected UnmodifiableMap( final MAP m ) {
			if ( m == null ) throw new NullPointerException();
			this.map = m;
		}

		public Object remove( final Object ok ) { throw new UnsupportedOperationException(); }
		public Object get( final Object ok ) { return map.get( ok ); }

		public int size() { return map.size(); }
		public boolean containsKey( final KEY_TYPE k ) { return map.containsKey( k ); }
		public boolean containsValue( final VALUE_TYPE v ) { return map.containsValue( v ); }

		public VALUE_TYPE defaultReturnValue()  { throw new UnsupportedOperationException(); }
		public void defaultReturnValue( final VALUE_TYPE defRetValue )  { throw new UnsupportedOperationException(); }

		public VALUE_TYPE put( final KEY_TYPE k, final VALUE_TYPE v ) { throw new UnsupportedOperationException(); }

		public void putAll( final MAP c ) { throw new UnsupportedOperationException(); }
		public void putAll( final Map m ) { throw new UnsupportedOperationException(); }

		public Set entrySet() { if ( entries == null ) entries = ObjectSets.unmodifiable( (ObjectSet)map.entrySet() ); return entries; }
		public Set keySet() { if ( keys == null ) keys = SETS.unmodifiable( (SET)map.keySet() ); return keys; }
		public Collection values() { if ( values == null ) return VALUE_COLLECTIONS.unmodifiable( (VALUE_COLLECTION)map.values() ); return values; }

		public void clear() { throw new UnsupportedOperationException(); }
		public String toString() { return map.toString(); }

#if ( ! #keyclass( Object ) && ! #keyclass( Reference ) ) || ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public Object put( final Object k, final Object v ) { throw new UnsupportedOperationException(); }
#endif

#if ! #keyclass( Object ) && ! #keyclass( Reference )
		public VALUE_TYPE remove( final KEY_TYPE k ) { throw new UnsupportedOperationException(); }
		public VALUE_TYPE get( final KEY_TYPE k ) { return map.get( k ); }
		public boolean containsKey( final Object ok ) { return map.containsKey( ok ); }
#endif

#if ! #valueclass( Object ) && ! #valueclass( Reference )
		public boolean containsValue( final Object ov ) { return map.containsValue( ov ); }
#endif

#if ( #keyclass( Object ) || #keyclass( Reference ) ) && ( ! #valueclass( Object ) && ! #valueclass( Reference ) )
		public VALUE_TYPE REMOVE_VALUE( final Object k ) { throw new UnsupportedOperationException(); }
		public VALUE_TYPE GET_VALUE( final Object k ) { return map.GET_VALUE( k ); }
#endif

	}

	/** Returns an unmodifiable type-specific map backed by the given type-specific map.
	 *
	 * @param m the map to be wrapped in an unmodifiable map.
	 * @return an unmodifiable view of the specified map.
	 * @see java.util.Collections#unmodifiableMap(Map)
	 */
	public static MAP unmodifiable( final MAP m ) { return new UnmodifiableMap( m ); }



	
}

// Local Variables:
// mode: jde
// tab-width: 4
// End:
