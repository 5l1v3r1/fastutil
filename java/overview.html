<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>fastutil</title>
  </head>

  <body>

    <P>Extends the the <a href="http://java.sun.com/j2se/1.4.2/docs/guide/collections/">Java&trade; Collections Framework</a> by providing
    type-specific maps, sets, lists and priority queues with a small memory
    footprint and fast access and insertion. It is <A
    HREF="http://www.gnu.org/philosophy/free-sw.html">free software</A>
    distributed under the <A
    HREF="http://www.gnu.org/copyleft/lesser.html"><ACRONYM TITLE="GNU's not Unix">GNU</ACRONYM> Lesser General Public License</A>.

    <blockquote>

      <p><strong>Warning:</strong> As of 4.0, the introduction of the new
	high-performance <code>addElements()</code> methods to type-specific
	lists made previous implementations of type-specific lists incomplete.
	However, the new methods are implemented by type-specific abstract
	lists, so a recompilation should be sufficient.

	<p>Moreover, the abstract generic version of <code>get()</code>,
	<code>put()</code> and <code>remove()</code> for maps with non-object
	keys or values now always return <code>null</code> to denote a missing
	key. In a few cases they used to return an object-wrapped default
	return value.

      <P>As of 3.1, the introduction of several new
	static methods made it clear that accumulating all such methods in a
	single static container class would not have been feasible ({@link
	it.unimi.dsi.fastutil.Collections} would have more than a thousand
	methods). Thus, static methods are spread, whenever appropriate, in
	type-specific classes such as {@link
	it.unimi.dsi.fastutil.ints.IntSets}. The old
	<code>it.unimi.dsi.fastutil.Iterators</code> has been fit into this
	framework, too, and now all its methods are distributed in type-specific classes
	(e.g., {@link it.unimi.dsi.fastutil.ints.IntIterators}).

      <P>As a consequence, source code compatibility is broken for methods
	contained in the old <code>it.unimi.dsi.fastutil.Iterators</code>
	class.

      <P>Moreover, after facing of a number of ambiguities in method
	invocation, it has been decided to rename all removal methods in
	type-specific versions of {@link java.util.Collection} to
	<code>rem()</code> (this was previously true just of {@link
	it.unimi.dsi.fastutil.ints.IntSet#rem(int)}).

	
    </blockquote>

    <h2>Package Specification</h2>

    
    <p>The classes of this package specialize the most useful {@link
      java.util.HashSet}, {@link java.util.HashMap}, {@link
      java.util.LinkedHashSet}, {@link java.util.LinkedHashMap}, {@link
      java.util.TreeSet}, {@link java.util.TreeMap}, {@link
      java.util.IdentityHashMap}, {@link java.util.ArrayList} and {@link
      java.util.Stack} classes to versions that accept a specific kind of
      key or value (e.g., {@linkplain it.unimi.dsi.fastutil.ints.IntSet integers}). Besides, there are also
      several types of {@linkplain it.unimi.dsi.fastutil.PriorityQueue priority
      queues} and a large collection of static objects and
      methods (such as {@linkplain it.unimi.dsi.fastutil.Sets#EMPTY_SET
      immutable empty containers}, {@linkplain
      it.unimi.dsi.fastutil.ints.IntComparators#OPPOSITE_COMPARATOR
      comparators implementing the opposite of the natural order},
      {@linkplain it.unimi.dsi.fastutil.ints.IntIterators#wrap(int[])
      iterators obtained by wrapping an array} and so on.</p>

    <p>To understand what's going on at a glance, the best thing is to look at
    the <A HREF="#example">examples</A> provided. If you already used the
    Collections Framework, everything should look
    rather natural. If, in particular, you use an IDE such as <A
    HREF="http://www.eclipse.org/">Eclipse</A>, which can suggest you the
    method names, all you need to know is <A HREF="#names">the right name for
    the class you need</A>.

    <p>All data structures in <code>fastutil</code> implement their standard
    counterpart interface (e.g., {@link java.util.Map} for maps). Thus, they
    can be just plugged into existing code, using the standard access methods
    (of course, any attempt to use the wrong type for keys or values will
    produce a {@link java.lang.ClassCastException}). However, they also provide
    (whenever possible) many polymorphic versions of the most used methods that
    lessen the tedious "type juggling" that is well known to Java
    programmers. In doing so, they implement more stringent interfaces that
    extend the standard ones (e.g., {@link
    it.unimi.dsi.fastutil.ints.Int2IntSortedMap} or {@link
    it.unimi.dsi.fastutil.ints.IntListIterator}).</p>
      
    <p>Of course, the main point of type-specific data structures is that the
    absence of wrappers around primitive types can increas speed and reduce
    space occupancy by several times. The implementation of generics in Java
    will not change this fact, since there will be no genericity for primitive
    types: thanks to automatic boxing/deboxing of primitive types, type juggling will
    be eliminated, but the data structures themselves will remain much larger and
    slower than needed.

    <p>The implementation techniques used in <code>fastutil</code> are quite
    different than those of {@link java.util}: for instance, open-addressing
    hash tables, threaded AVL trees, threaded red-black trees and exclusive-or
    lists. An effort has also been made to provide powerful derived objects:
    for instance, the {@linkplain
    it.unimi.dsi.fastutil.objects.Object2IntSortedMap#keySet() keys of sorted maps
    are sorted} and iterators on sorted containers are always {@linkplain
    it.unimi.dsi.fastutil.BidirectionalIterator bidirectional}.

    <p>More generally, the rationale behing <code>fastutil</code> is that
    <em>you should never need to code explicitly natural
    transformations</em>. You do to not need to define an anonymous class to
    iterate over an array of integers&mdash;just {@linkplain
    it.unimi.dsi.fastutil.ints.IntIterators#wrap(int[]) wrap it}. You do not
    need to write a loop to put the characters returned by an iterator into a
    set&mdash;just {@linkplain
    it.unimi.dsi.fastutil.chars.CharOpenHashSet#CharOpenHashSet(CharIterator)
    use the right constructor}. And so on.

      <h3><A NAME="names"></A>The Names</h3>

    In general, class names adhere to the general pattern</p>

    <div style="padding: 1em">
      <var>valuetype</var> <var>collectiontype</var>
    </div>
    
    <p>for collections, and</p>
    
    <div style="padding: 1em">
      <var>keytype</var> 2 <var>valuetype</var> <var>maptype</var>
    </div>
    
    <p>for maps.

    <P>By "type" here I mean a capitalized primitive type, {@link
      java.lang.Object} or <code>Reference</code>. In the latter case, we
      are treating objects, but their equality is established by reference
      equality (that is, without invoking <code>equals()</code>), similarly
      to {@link java.util.IdentityHashMap}. Of course, reference-based
      classes are significantly faster.</p>
    
    <P>Thus, an {@link it.unimi.dsi.fastutil.ints.IntOpenHashSet} stores
    integers efficiently and implements {@link
    it.unimi.dsi.fastutil.ints.IntSet}, whereas a {@link
    it.unimi.dsi.fastutil.longs.Long2IntAVLTreeMap} does the same for maps from
    longs to integers (but the map will be sorted, tree based, and balanced
    using the AVL criterion), implementing {@link
    it.unimi.dsi.fastutil.longs.Long2IntMap}. If you need additional
    flexibility in choosing your {@linkplain
    it.unimi.dsi.fastutil.Hash.Strategy hash strategy}, you can put, say, arrays
    of integers in a {@link it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet},
    maybe using the ready-made {@linkplain
    it.unimi.dsi.fastutil.ints.IntArrays#HASH_STRATEGY hash strategy for
    arrays}.  A {@link it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet}
    stores longs in a hash table, but provides a predictable iteration order
    (the insertion order) and access to first/last elements of the order. A
    {@link it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap} is
    similar to an {@link java.util.IdentityHashMap}. You can manage a priority
    queue of characters in a heap using a {@link
    it.unimi.dsi.fastutil.chars.CharHeapPriorityQueue}, which implements {@link
    it.unimi.dsi.fastutil.chars.CharPriorityQueue}.  {@link
    it.unimi.dsi.fastutil.bytes.ByteArrayFrontCodedList Front-coded lists} are
    highly specialized immutable data structures that store compactly a large
    number of arrays: if you don't know them you probably don't need them.

    <p>Since there are eight primitive types in Java, and we support
    reference-based containers, we get 1302 (!) classes (some nonsensical
    classes, such as <code>Boolean2BooleanAVLTreeMap</code>, are not
    generated). Many classes are generated just to mimic the hierarchy of
    {@link java.util} so to redistribute common code in a similar way. There
    are also several abstract classes that ease significantly the creation of
    new type-specific classes by providing automatically generic methods based
    on the type-specific ones.</p>

    <p>The huge number of classes required a suitable division in subpackages
    (more than anything else, to avoid crashing browsers with a preposterous
    package summary). Each subpackage is characterized by the type of elements
    or keys: thus, for instance, {@link it.unimi.dsi.fastutil.ints.IntSet}
    belongs to {@link it.unimi.dsi.fastutil.ints} (the plural is required, as
    <code>int</code> is a keyword and cannot be used in a package name), as
    well as {@link it.unimi.dsi.fastutil.ints.Int2ReferenceRBTreeMap}. Note
    that all classes for non-primitive elements and keys are gathered in {@link
    it.unimi.dsi.fastutil.objects}. Finally, a number of non-type-specific
      classes have been gathered in {@link it.unimi.dsi.fastutil}.

      
      <h3>An  In&ndash;Depth Look</h3>

    <P>The following table summarizes the available interfaces and
    implementations. To get more information, you can look at a specific
    implementation in {@link
    it.unimi.dsi.fastutil} or, for instance, {@link it.unimi.dsi.fastutil.ints}.

    <div align=center>
    <table border=1 title="Interfaces and Abstract Implementations">
	<tr><th>Interfaces<th>Abstract Implementations<th>Implementations
	<tr><td>Collection<td>AbstractCollection
	<tr><td>Set<td>AbstractSet<td>OpenHashSet, OpenCustomHashSet
	<tr><td>SortedSet<td>AbstractSortedSet<td>RBTreeSet, AVLTreeSet, LinkedOpenHashSet
	<tr><td>Map<td>AbstractMap<td>OpenHashMap, OpenCustomHashMap
	<tr><td>SortedMap<td>AbstractSortedMap<td>RBTreeMap, AVLTreeMap, LinkedOpenHashMap
	<tr><td>List<td>AbstractList<td>ArrayList, ArrayFrontCodedList
	<tr><td>PriorityQueue&dagger;<td>AbstractPriorityQueue&dagger;<td>HeapPriorityQueue, ArrayPriorityQueue
	<tr><td>IndirectPriorityQueue&Dagger;<td>AbstractIndirectPriorityQueue&Dagger;<td>HeapSemiIndirectPriorityQueue, HeapIndirectPriorityQueue, ArrayIndirectPriorityQueue
	<tr><td>IndirectDoublePriorityQueue&Dagger;<td>AbstractIndirectDoublePriorityQueue&Dagger;<td>HeapSesquiIndirectDoublePriorityQueue, ArrayIndirectDoublePriorityQueue
	<tr><td>Stack&dagger;<td>AbstractStack&dagger;<td>ArrayList
	<tr><td>Iterator<td>AbstractIterator
	<tr><td>Comparator<td>AbstractComparator
	<tr><td>BidirectionalIterator&dagger;<td>AbstractBidirectionalIterator
	<tr><td>ListIterator<td>AbstractListIterator
    </table>
    </div>

    <P>&dagger;: this class has also a non-type-specific implementation in {@link it.unimi.dsi.fastutil}.
    <P>&Dagger;: this class has <em>only</em> a non-type-specific implementation in {@link it.unimi.dsi.fastutil}.
    
    <P>Note that abstract implementations are named by prefixing the interface
    name with <samp>Abstract</samp>. Thus, if you want to define a
    type-specific structure holding a set of integers without the hassle of
    defining object-based methods, you should inherit from {@link it.unimi.dsi.fastutil.ints.AbstractIntSet}.

    <P>The following table summarizes static containers, which usually give rise
    both to a type-specific and to a generic class:
      
    <div align=center>
    <table border=1 style="border: solid thin black" title="Static Containers">
	<tr><th>Static Containers
	<tr><td>Collections&dagger;
	<tr><td>Sets&dagger;
	<tr><td>SortedSets&dagger;
	<tr><td>Maps&dagger;
	<tr><td>SortedMaps
	<tr><td>Lists&dagger;
	<tr><td>Arrays&dagger;
	<tr><td>Heaps
	<tr><td>SemiIndirectHeaps
	<tr><td>IndirectHeaps
	<tr><td>PriorityQueues&dagger;
	<tr><td>IndirectPriorityQueues&Dagger;
	<tr><td>IndirectDoublePriorityQueues&Dagger;
	<tr><td>Iterators&dagger;
	<tr><td>Comparators
	<tr><td>Hash&Dagger;
	<tr><td>HashCommon&Dagger;
    </table>
    </div>

    <P>&dagger;: this class has also a non-type-specific implementation in {@link it.unimi.dsi.fastutil}.
    <P>&Dagger;: this class has <em>only</em> a non-type-specific implementation in {@link it.unimi.dsi.fastutil}.

    <P>The static containers provide also special-purpose implementations for
    all kinds of {@linkplain it.unimi.dsi.fastutil.Sets#EMPTY_SET empty
    structures} (including {@linkplain
    it.unimi.dsi.fastutil.objects.ObjectArrays#EMPTY_ARRAY arrays}) and
    {@linkplain it.unimi.dsi.fastutil.ints.Int2IntMaps#singleton(int,int) singletons}.

    <h3>Warnings</h3>

    <p><strong>All classes are not synchronized</strong>. If multiple threads access one
      of these classes concurrently, and at least one of the threads modifies it,
      it must be synchronized externally. Iterators will behave unpredictably in
      the presence of concurrent modifications. Reads, however, can be carried
      out concurrently.

    <p><strong>Reference-based classes violate the {@link java.util.Map}
	contract</strong>. They intentionally compare objects by reference, and do
      not use the <code>equals()</code> method. They should be used only
      when reference-based equality is desired (for instance, if all
      objects involved are canonized, as it happens with interned strings).

    <p><strong>Linked classes do not implement completely the {@link
	java.util.SortedMap} interface</strong>. They provide methods to get the
      first and last element in iteration order, but any submap or subset
      method will cause an {@link java.lang.UnsupportedOperationException}.
      (this may change in future versions).

    <p><strong>Substructures in sorted classes allow the creation of
	arbitrary substructures</strong>. In {@link java.util}, instead, you
      can only create contained sub-substructures (BTW, why?). For instance,
      <code>(new TreeSet()).tailSet(new Integer(1)).tailSet(new
	Integer(0))</code> will throw an exception, but {@link
      it.unimi.dsi.fastutil.ints.IntRBTreeSet (new
      IntRBTreeSet()).tailSet(1).tailSet(0)} won't.

    <p><strong>Immutability is syntactically based (as opposed to
	semantically based)</strong>. All methods that are known not to be
      causing modifications to the structure at compile time will not throw
      exceptions (e.g., {@link it.unimi.dsi.fastutil.Sets#EMPTY_SET
      EMPTY_SET.clear()}). All other methods will cause an {@link
      java.lang.UnsupportedOperationException}.  Note that (as of Java 1.4)
      the situation in {@link java.util} is definitely different, and
      inconsistent: for instance, in singletons <code>add()</code> always
      throws an exception, whereas <code>remove()</code> does it only if the
      singleton would be modified. This behaviour agrees with the interface documentation, 
      but it is confusing nonetheless.

    
    <h3>Additional Features and Methods</h3>

    <p>The new interfaces add some very natural methods. Moreover, whenever
      possible, the object returned is type-specific, or even implements a more
      powerful interface.

    <p>Due to some limitations of Java (you cannot override covariantly the
      return value of an interface, i.e., with a method returning a more
      specific value), however, sometimes these features are available only
      by means of type casting.

    <P>More in detail:
    <UL>
      
      <LI>Keys and values of a map are of the <code>fastutil</code> type you
	would expect (e.g., the keys of an {@link
	it.unimi.dsi.fastutil.ints.Int2LongSortedMap} are an {@link
	it.unimi.dsi.fastutil.ints.IntSortedSet} and the values are a {@link
	it.unimi.dsi.fastutil.longs.LongCollection}), but you must explicitly cast the
	objects returned by {@link java.util.Map#keySet() keySet()} and {@link
	java.util.Map#values() values()} to the appropriate type.

      <LI>Submaps of a sorted map and subsets of a sorted sets are of the
	<code>fastutil</code> type you would expect, too. The standard
	constructors return a {@link java.util.SortedMap} or a {@link
	java.util.SortedSet}, respectively, which can be safely cast to
	the right type-specific interface. However, if you use extended
	interfaces and keys are not objects, then there are new methods accepting
	primitive keys and returning a type-specific sorted structure directly
	(see, e.g., {@link it.unimi.dsi.fastutil.ints.Int2IntSortedMap}).

      <LI>Iterators returned by {@link java.util.Set#iterator()
	iterator()} can be cast to the obvious type (e.g., {@link
	it.unimi.dsi.fastutil.chars.CharIterator} for a {@link
	it.unimi.dsi.fastutil.chars.CharSet}), too. There is also an
	additional method returning directly a type-specific iterator
	(see, e.g., {@link
	it.unimi.dsi.fastutil.ints.IntCollection#intIterator()
	intIterator()}). See below for more information on
	<code>fastutil</code> iterators.

      <LI>Sorted structures in <code>fastutil</code> return (possibly
	type-specific) {@linkplain
	it.unimi.dsi.fastutil.BidirectionalIterator bidirectional
	iterators}. This means that you can move back and forth among
	entries, keys or values. Again, you must manually cast the
	result of a call to {@link java.util.Set#iterator() iterator()}
	to {@link it.unimi.dsi.fastutil.BidirectionalIterator} or, even
	better, to a type-specific bidirectional iterator such as
	{@link it.unimi.dsi.fastutil.ints.IntBidirectionalIterator}. Note that
	sometimes the return value is explicitly marked to be castable
	to an even more powerful type-specific {@linkplain
	java.util.ListIterator list iterator}.

      <LI>The type-specific sorted set interfaces, moreover, feature an optional
	method <code>iterator(from)</code> which creates a type-specific {@link
	it.unimi.dsi.fastutil.BidirectionalIterator} starting from a given
	element of the domain (not necessarily in the set). See, for instance,
	{@link it.unimi.dsi.fastutil.ints.IntSortedSet#iterator(int)}. The method is
	implemented by all type-specific sorted sets and subsets.

      <LI>Finally, there are constructors that allow you to build easily sets
	using array and iterators. This means, for instance, that you can create quickly a
	set of strings with a statement like
	<blockquote>
	  <code>new ObjectOpenHashSet( new String[] { "foo", "bar" } )</code>
	</blockquote>
	or just "unroll" the integers returned by an iterator into a list with
	<blockquote>
	  <code>new IntArrayList( iterator )</code>
	</blockquote>

    </UL>


    <P>There are a few quirks, however, that you should be aware of:

    <ul>

      <li>The versions of the {@link java.util.Map#get(Object)
	get()}, {@link java.util.Map#put(Object,Object) put()} and
	{@link java.util.Map#remove(Object) remove()} methods that
	return a primitive type cannot, of course, rely on returning
	<code>null</code> to denote the absence of a certain
	pair. Rather, they return a <em>{@linkplain
	  it.unimi.dsi.fastutil.ints.Int2LongMap#defaultReturnValue(long) default 
	  return value}</em>, which is set to 0 cast to the
	return type (<code>false</code> for booleans) at creation, but
	can be changed using the <code>defaultReturnValue()</code>
	method (see, e.g., {@link
	it.unimi.dsi.fastutil.ints.Int2IntMap}). Note that changing the
	default return value does not change anything about the data
	structure; it is just a way to return a reasonably meaningful
	result&mdash;it can be changed at any time. For uniformity reasons,
	even maps returning objects can use
	<code>defaultReturnValue()</code> (of course, in this case the
	default return value is initialized to <code>null</code>). A
	submap or subset has an independent default return value (which
	however is initialized to the default return value of the
	originator).</li>

      <li>For all maps that have object as keys, the {@link
	java.util.Map#get(Object) get()} and {@link
	java.util.Map#remove(Object) remove()} methods do not admit
	polymorphic versions, as Java does not allow return-value
	polymorphism. Rather, the extended interfaces introduce new
	methods of the form {@link
	it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap#getInt(Object)
	get<var>valuetype</var>()} and {@link
	it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap#removeInt(Object)
	remove<var>valuetype</var>()}. Similar problems occur with
	{@link it.unimi.dsi.fastutil.chars.CharSortedSet#firstChar()
	first()}, {@link
	it.unimi.dsi.fastutil.chars.CharSortedSet#lastChar() last()},
	and so on.</li>

      <LI>Similarly, all iterators have a suitable method {@link
	it.unimi.dsi.fastutil.ints.IntIterator#nextInt()
	next<var>type</var>()} returning directly a primitive type.
	And, of course, you have a type-specific version of {@link
	java.util.ListIterator#previous() previous()}.

      <li>For the same reason, the method {@link java.util.Collection#toArray}
	has a polymorphic version accepting a type-specific array, but there are
	also explicitly typed methods
	{@link it.unimi.dsi.fastutil.bytes.ByteCollection#toByteArray() to<var>keytype</var>Array()}.</li>

      <li>A name clash between the list and collection interfaces
	forces the deletion method of an collection to be named {@link
	it.unimi.dsi.fastutil.doubles.DoubleCollection#rem(double)
	rem()}. At the risk of creating some confusion, {@link
	it.unimi.dsi.fastutil.doubles.DoubleSet#remove(double) remove()}
	reappears in the type-specific set interfaces, so the only
	really unpleasant effect is that you must use
	<code>rem()</code> on variables that are collections, but not
	sets&mdash;for instance, {@linkplain
	it.unimi.dsi.fastutil.ints.IntList type-specific lists}.

      <li>There are type-specific versions of {@link java.util.Comparator} that
	require specifying both a type-specific comparison method and an object-based
	one; this is necessary as a type-specific comparator must implement {@link
	java.util.Comparator}. However, to simplify the creation of type-specific
	comparators there are abstract type-specific comparator classes that
	implement an object-based comparator wrapping the (abstract)
	type-specific one; thus, if you need to create a type-specific comparator
	you just have to inherit from those classes and define the type-specific
	method. Analogously for iterators.

      <li>Stacks are <em>interfaces</em> implemented by array-based
	lists: the interface, moreover, is slightly different from the
	implementation contained in {@link java.util.Stack}.
    </ul>

    <h3>Static Container Classes</h3>

    <P><code>fastutil</code> provides a number of static methods and
      singletons, much like {@link java.util.Collections}. To avoid creating
      classes with hundreds of methods, there are separate containers for
      sets, lists, maps and so on. Generic containers are placed in {@link
      it.unimi.dsi.fastutil}, whereas type-specific containers are in the
      appropriate package.  You should look at the documentation of the
      static classes contained in {@link it.unimi.dsi.fastutil}, and in
      type-specific static classes such as {@link
      it.unimi.dsi.fastutil.chars.CharSets}, {@link
      it.unimi.dsi.fastutil.floats.Float2ByteSortedMaps}, {@link
      it.unimi.dsi.fastutil.longs.LongArrays}, {@link
      it.unimi.dsi.fastutil.floats.FloatHeaps} and  {@link
      it.unimi.dsi.fastutil.doubles.DoublePriorityQueues}.  Presently, you can easily
      obtain {@linkplain it.unimi.dsi.fastutil.Sets#EMPTY_SET empty collections},
      {@linkplain it.unimi.dsi.fastutil.longs.Long2IntMaps#EMPTY_MAP empty
      type-specific collections}, {@linkplain
      it.unimi.dsi.fastutil.ints.IntLists#singleton(int) singletons}, and
      {@linkplain
      it.unimi.dsi.fastutil.objects.Object2ReferenceSortedMaps#synchronize(Object2ReferenceSortedMap)
      synchronized versions} of any type-specific container.
      
    <P>On a completely different side, the {@linkplain
      it.unimi.dsi.fastutil.ints.IntArrays type-specific static container
      classes for arrays} provide several useful methods that allow to treat
      an array much like an array-based list, hiding completely the growth
      logic. In many cases, using this methods and an array is even simpler
      then using a full-blown {@linkplain
      it.unimi.dsi.fastutil.doubles.DoubleArrayList type-specific
      array-based list} because elements access is syntactically much
      simpler. The version for objects uses reflection to return arrays of
      the same type of the argument.

    <P>For the same reason, <code>fastutil</code> provides a full
    implementation of methods that manipulate arrays as type-specific
    {@linkplain it.unimi.dsi.fastutil.ints.IntHeaps heaps}, {@linkplain
    it.unimi.dsi.fastutil.ints.IntSemiIndirectHeaps semi-indirect heaps} and
    {@linkplain it.unimi.dsi.fastutil.ints.IntIndirectHeaps indirect heaps}.


    <h3>Iterators and Comparators</h3>

    <P><code>fastutil</code> provides type-specific iterators and
      comparators. The interface of a <code>fastutil</code> iterator is
      slightly more powerful than that of a {@link java.util} iterator, as
      it contains a {@link it.unimi.dsi.fastutil.objects.ObjectIterator#skip(int)
      skip()} method that allows to skip over a list of elements (an
      {@linkplain
      it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator#back(int) analogous
      method} is provided for bidirectional iterators). For objects (even
      those managed by reference), the extended interface is named {@link
      it.unimi.dsi.fastutil.objects.ObjectIterator}; it is the return type, for
      instance, of {@link
      it.unimi.dsi.fastutil.objects.ObjectCollection#objectIterator()}.
      
      <code>fastutil</code> provides also classes and methods that makes it
      easy to create type-specific iterators and comparators. There are abstract versions of
      each (type-specific) iterator and comparator that implement in the
      obvious way some of the methods (see, e.g., {@link
      it.unimi.dsi.fastutil.ints.AbstractIntIterator} or {@link
      it.unimi.dsi.fastutil.ints.AbstractIntComparator}).

    <P>A plethora of useful static methods is also provided by various
      type-specific static containers (e.g., {@link
      it.unimi.dsi.fastutil.ints.IntIterators}) and by {@link
      it.unimi.dsi.fastutil.Iterators}: among other things, you can
      {@linkplain it.unimi.dsi.fastutil.ints.IntIterators#wrap(int[]) wrap
      arrays} and {@linkplain
      it.unimi.dsi.fastutil.ints.IntIterators#asIntIterator(java.util.Iterator)
      standard iterators} in type-specific iterators, {@linkplain
      it.unimi.dsi.fastutil.ints.IntIterators#fromTo(int,int) generate them}
      giving an interval of elements to be returned, {@linkplain
      it.unimi.dsi.fastutil.objects.ObjectIterators#concat(ObjectIterator[])
      concatenate them} or {@linkplain
      it.unimi.dsi.fastutil.objects.ObjectIterators#pour(Iterator,ObjectCollection)
      pour them} into a set.


    <h3>Queues</h3>

    <P><code>fastutil</code> offers three types of queues: <em>direct
    queues</em>, <em>indirect queues</em> and <em>double indirect
    queues</em>. A direct queue offers type-specific method to {@linkplain
    it.unimi.dsi.fastutil.longs.LongPriorityQueue#enqueue(long) enqueue} and
    {@linkplain it.unimi.dsi.fastutil.longs.LongPriorityQueue#dequeueLong()
    dequeue} elements. An indirect queue needs a <em>reference array</em>,
    specified at construction time: {@linkplain
    it.unimi.dsi.fastutil.IndirectPriorityQueue#enqueue(int) enqueue} and
    {@linkplain it.unimi.dsi.fastutil.IndirectPriorityQueue#dequeue()
    dequeue} operations refer to indices in the reference array. The advantage
    is that it may be possible to {@linkplain
    it.unimi.dsi.fastutil.IndirectPriorityQueue#changed(int) notify the change}
      of any element of the reference array, or even to {@linkplain
    it.unimi.dsi.fastutil.IndirectPriorityQueue#remove(int) remove an arbitrary
      element}. Finally, {@linkplain it.unimi.dsi.fastutil.IndirectDoublePriorityQueue double indirect queues} maintain at the same time <em>two</em> orders
      (very commonly, opposite orders).

    <P>Queues have two type of implementations: a trivial array-based
    implementation, and a heap-based implementation. In particular, heap-based
    indirect queues may be {@linkplain
    it.unimi.dsi.fastutil.objects.ObjectHeapIndirectPriorityQueue fully
    indirect} or just {@linkplain
    it.unimi.dsi.fastutil.objects.ObjectHeapSemiIndirectPriorityQueue
    semi-indirect}: in the latter case, there is no need for an explicit
    indirection array (which saves one integer per queue entry), but not all
    operations will be avalable. Correspondingly, double priority queues have a
    <em>{@linkplain it.unimi.dsi.fastutil.ints.IntHeapSesquiIndirectDoublePriorityQueue sesqui}</em>
    (i.e., one-and-a-half) indirect implementation.


    <h3>Custom Hashing</h3>

    <P>Sometimes, the behaviour of the built-in equality and hashing methods is
    not what you want. In particular, this happens if you store in a hash-based
    collection arrays, and you would like to compare them by equality. For this kind of applications,
      <code>fastutil</code> provides {@linkplain it.unimi.dsi.fastutil.Hash.Strategy custom hash strategies},
      which define new equality and hashing methods to be used inside the collection. There are even
      {@linkplain it.unimi.dsi.fastutil.ints.IntArrays#HASH_STRATEGY ready-made strategies} for arrays. Note, however,
      that <code>fastutil</code> containers do not cache hash codes, so custom hash strategies must be efficient.


    <h3>Abstract Classes</h3>

    <p><code>fastutil</code> provides a wide range of abstract classes, to
      help in implementing its interfaces. They take care, for instance, of
      providing wrappers for non-type-specific method calls, so that you have to
      write just the (usually simpler) type-specific version. 


      
    <h3>Performance</h3>
    
    <p>The main reason behind <code>fastutil</code> is performance, both in
    time and in space. The relevant methods of type-specific hash maps and sets
    are something like 2 to 10 times faster than those of the standard
    classes. Note that performance of hash-based classes on object keys is
    usually <em>worse</em> (from a few percent to doubled time) than that of
    {@link java.util}, because <code>fastutil</code> classes do not cache hash
    codes (albeit it will not be that bad if keys cache internally hash codes,
    as in the case of {@link java.lang.String}). Of course, you can try to get
    more speed from hash tables using a small load factor (say, 1/2).

    <p>For tree-based classes you have two choices: AVL and red-black
      trees. The essential difference is that AVL trees are more balanced (their
      height is at most 1.44 log <var>n</var>), whereas red-black trees have
      faster deletions (but their height is at most 2 log <var>n</var>). So on
      small trees red-black trees could be faster, but on very large sets AVL
      trees will shine. In general, AVL trees have slightly slower updates but
      faster searches; however, on very large collections the smaller height may
      lead in fact to faster updates, too.

    <p><code>fastutil</code> reduces enormously the creation and collection of
      objects. First of all, if you use the polymorphic methods and iterators no
      wrapper objects have to be created. Moreover, since <code>fastutil</code>
      uses open-addressing hashing techniques, creation and garbage collection of
      hash-table entries are avoided (but tables have to be rehashed whenever
      they are filled beyond the load factor). The major reduction of the number
      of objects around has a definite (but very difficult to measure) impact on
      the whole application (as garbage collection runs proportionally to the
      number of alive objects).

    <p>Whenever possible, <code>fastutil</code> tries to gain some speed by
      checking for faster interfaces: for instance, the various set-theoretic
      methods <code>addAll()</code>, <code>retainAll()</code>, ecc. check whether
      their arguments are type-specific and use faster iterators and accessors
      accordingly.
      

    <h3>Deletions in Hash Tables</h3>

    <p>Since deletions in hash tables are handled simply by tagging, they are
      very fast <i>per se</i>, but they tend to slow down subsequent accesses
      (with respect to a table with no deleted entries). In highly dynamical
      situations, where entries are continuously created and deleted,
      unsuccessful searches may take linear time (as <em>all</em> entries must be
      probed).

    <p>A partial solution to this problem (which has no known complete
      solution if you use open addressing with double
      hashing&mdash;cfr. Knuth's section on hashing in the third volume of
      <i>The Art of Computer Programming</i>) is to call the
      <code>rehash()</code> method, which will try to rebuild the table
      remapping all keys. There are also <code>trim()</code> methods that
      will reduce the table size if possible.

    <p>In other words, if your application requires inextricably interleaved
      insertions, deletions and queries open-addressing hash-table
      implementations (and in particular <code>fastutil</code> classes) are not
      the right choice.

    <p>Note, however, that <code>fastutil</code> implements a special
      optimization, usually not found elsewhere, that speeds up probes for
      recently deleted entries. More details can be found in the documentation of
      the {@link it.unimi.dsi.fastutil.Hash} interface.

    <P>The case of linked tables is even more problematic: the deletion of
      an item requires a linear probe of the links until the item is found,
      and thus it has potentially linear cost (however, this is not true if
      the deletion is performed by means of an iterator, or if you delete
      the last element).

    <h3>Memory Usage</h3>

    <P>The absence of wrappers makes data structures in <code>fastutil</code>
    much smaller: even in the case of objects, however, data structures in
    <code>fastutil</code> try to be space-efficient.

    <h4>Hash Tables</h4>

    <p>To avoid memory waste, (unlinked) hash tables in
      <code>fastutil</code> keep no additional information about elements
      (such as a list of keys). In particular, this means that enumerations
      are always linear in the size of the table (rather than in the number
      of keys). Usually, this would imply slower iterators. Nonetheless, the
      iterator code includes a single, tight loop; moreover, it is possible
      to avoid the creation of wrappers. These two facts make in practice
      <code>fastutil</code> iterators <em>faster</em> than {@link
      java.util}'s.

    <p>The memory footprint for a table with <var>n</var> keys is exactly the
      memory required for the related types times <var>n</var>, plus a
      overhead of <var>n</var> bytes to store the state of each entry. The
      absence of wrappers around primitive types can reduce space occupancy by
      several times (this applies even more to serialized data, e.g., when you
      save such a data structure in a file).  These figures can greatly vary with
      your virtual machine, JVM versions, CPU etc.

    <p>More precisely, when you ask for a map that will hold <var>n</var>
      elements with load factor 0&nbsp;&lt;&nbsp;<var>f</var>&nbsp;&le;&nbsp;1, <var>p</var> entries are
      allocated, where <var>p</var> is first prime in {@link
      it.unimi.dsi.fastutil.Hash#PRIMES} larger than
      <var>n</var>&nbsp;/&nbsp;<var>f</var>. Primes in {@link
      it.unimi.dsi.fastutil.Hash#PRIMES} are roughly multiplicatively spaced by
      2<sup>1/16</sup>, so you lose on average about 2% with respect to
      <var>n</var>&nbsp;/&nbsp;<var>f</var>. 

    <P>When the table is filled up beyond the load factor, it is rehashed to a
      larger size. The growth is controlled by the <em>growth factor</em>, which
      can be set at any time. By default, the table size is doubled (for more
      information, see {@link it.unimi.dsi.fastutil.ints.IntOpenHashSet}), but
      you can trade speed for memory occupancy by {@linkplain
      it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap#growthFactor(int) setting a slower growth rate}.

    <p>In the case of linked hash tables, there is an additional vector of
      <var>p</var> integers that is used to store link information. Each
      element records the next and previous element indexes exclusive-or'd
      together. As a result, linked tables provide bidirectional iterators
      without having to store two pointers per entry (however, iterators
      starting from a given element require a linear probe to be
      initialized, unless the element is the last one).
      
    <p>Since hash codes are not cached, equality on objects is checked
      first by checking equality of their {@link java.lang.Object#hashCode()
      hashCode()}, and then using {@link java.lang.Object#equals(Object)
      equals()}. This turns out to increase slightly the performance, as
      many classes (including {@link java.lang.String}) cache their hash
      codes; in any case, the speed cannot reach that of {@link java.util}'s
      hash classes, which cache hash codes.


    <h4>Balanced Trees</h4>

    <p>The balanced trees implementation is also very parsimonious.
      <code>fastutil</code> is based on the excellent (and unbelievably well
      documented) code contained in Ben Pfaff's <A
	HREF="http://www.msu.edu/~pfaffben/avl/">GNU libavl</A>, which describes in
      detail how to handle balanced trees with <em>threads</em>. Thus, the
      overhead per entry is two pointers and one integer, which compares well to
      three pointers plus one boolean of the standard tree maps. The trick is
      that we use the integer bit by bit, so we consume two bits to store thread
      information, plus one or two bits to handle balancing. As a result, we get
      bidirectional iterators in constant space and amortized constant time
      without having to store references to parent nodes.
      
    <P>It should be mentioned that all tree-based classes have a fixed overhead
      for some arrays that are used as stacks to simulate recursion; in
      particular, we need 48 booleans for AVL trees and 64 pointers plus 64
      booleans for red-black trees.

    <h3><A NAME="example"></A>An Example</h3>

    <P>Suppose you want to store a sorted map from longs to integers. The first
      step is to define a variable of the right interface, and assign it a new
      tree map (say, of the AVL type):
    <PRE>
Long2IntSortedMap m = new Long2IntAVLTreeMap();
    </PRE>
    <P>Now we can easily modify and access its content:
    <PRE>
m.put( 1, 5 );
m.put( 2, 6 );
m.put( 3, 7 );
m.put( 1000000000L, 10 );
m.get( 1 ); // This method call will return 5
m.get( 4 ); // This method call will return 0
    </PRE>
    <P>We can also try to change the default return value:
    <PRE>
m.defaultReturnValue( -1 );
m.get( 4 ); // This method call will return -1
    </PRE>
    <P>By suitable type casting, we can obtain a very powerful iterator:
    <PRE>
LongListIterator i = (LongListIterator)((LongSortedSet)m.keySet()).iterator();
// Now we sum all keys
long s = 0;
while( i.hasNext() ) s += i.nextLong();
    </PRE>
    <P>If one just needs a type-specific iterator, there is a special
      method that avoids casting:
    <PRE>
LongIterator i = ((LongSortedSet)m.keySet()).longIterator();
// Now we sum all keys
long s = 0;
while( i.hasNext() ) s += i.nextLong();
    </PRE>
    <P>We now generate a head map, and iterate bidirectionally over it starting
      from a given point:
    <PRE>
// This map contains only keys smaller than 4
Long2IntSortedMap m1 = m.headMap( 4 );
// This iterator is positioned between 2 and 3
LongBidirectionalIterator t = ((LongSortedSet)m1.keySet()).iterator( 2 );
t.previous(); // This method call will return 2 (t.next() would return 3)
    </PRE>
    <P>Should we need to access the map concurrently, we can wrap it:
    <PRE>
// This map can be safely accessed by many threads
Long2IntSortedMap m2 = Longs2IntSortedMaps.synchronize( m1 );
    </PRE>
    <P>Linked maps are very flexible data structures which can be used to implement, for
      instance, queues whose content can be probed efficiently:
    <PRE>
// This map remembers insertion order (note that we are using the array-based constructor)
IntSortedSet s = new IntLinkedOpenHashSet( new int[] { 4, 3, 2, 1 } );
s.firstInt(); // This method call will return 4
s.lastInt(); // This method call will return 1
s.contains(5); // This method will return false
IntBidirectionalIterator i = s.iterator( s.lastInt() ); // We could even cast it to a list iterator 
i.previous(); // This method call will return 1
i.previous(); // This method call will return 2
s.remove(s.lastInt()); // This will remove the last element in constant time
    </PRE>
    <P>Finally, we play with iterators. It is easy to create iterators over
      intervals or over arrays, and combine them:
    <PRE>
IntIterator i = Iterators.fromTo( 0, 10 ); // This iterator will return 0, 1, ..., 9.
int a[] = new int[] { 5, 1, 9 };
IntIterator j = Iterators.wrap( a ); // This iterator will return 5, 1, 9.
IntIterator k = Iterators.concat( new IntIterator[] { i , j } ); // This iterator will return 0, 1, ..., 9, 5, 1, 9.
    </PRE>
  </body>
</html>
