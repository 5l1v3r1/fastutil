<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>fastutil</title>
  </head>

  <body>

	 <P>Provides type-specific maps, sets and lists with a small memory footprint and
	 much faster access and insertion. It is <A
	 HREF="http://www.gnu.org/philosophy/free-sw.html">free software</A>
	 distributed under the <A
	 HREF="http://www.gnu.org/copyleft/lesser.html"><ACRONYM TITLE="GNU's not
	 Unix">GNU</ACRONYM> Lesser General Public License</A>.

    <blockquote>


      <p><strong>Warning:</strong> As of 3.2, the introduction of the new
	high-performance <code>addElements()</code> methods to type-specific
	lists made previous implementations of type-specific lists incomplete.
	However, the new methods are implemented by type-specific abstract
	lists, so a recompilation should be sufficient.

	<P>As of 3.1, the introduction of several new
      static methods made it clear that accumulating all such methods in a
      single static container class would not have been feasible ({@link
      it.unimi.dsi.fastutil.Collections} would have more than a thousand
      methods). Thus, static methods are spread, whenever appropriate, in
      type-specific classes such as {@link
      it.unimi.dsi.fastutil.ints.IntSets}. The old
      <code>it.unimi.dsi.fastutil.Iterators</code> has been fit into this
      framework, too, and now all its methods are distributed in type-specific classes
      (e.g., {@link it.unimi.dsi.fastutil.ints.IntIterators}).

      <P>As a consequence, source code compatibility is broken for methods
	contained in the old <code>it.unimi.dsi.fastutil.Iterators</code>
	class.

      <P>Moreover, after facing of a number of ambiguities in method
      invocation, it has been decided to rename all removal methods in
      type-specific versions of {@link java.util.Collection} to
      <code>rem()</code> (this was previously true just of {@link
      it.unimi.dsi.fastutil.ints.IntSet#rem(int)}).

      <P>As of 3.0, the introduction of the new
      type-specific lists required a tweak in the naming scheme: the
      type-specific version of {@link java.util.Collection#remove(Object)} for
      integers is now named {@link
      it.unimi.dsi.fastutil.ints.IntCollection#rem(int)}. The only really unpleasant
      effect is that you must use {@link
      it.unimi.dsi.fastutil.ints.IntCollection#rem(int) rem(int)} on variables of
      type {@link it.unimi.dsi.fastutil.ints.IntCollection} that are not of type
      {@link it.unimi.dsi.fastutil.ints.IntSet} (as {@link
      it.unimi.dsi.fastutil.ints.IntSet} reinstates {@link
      it.unimi.dsi.fastutil.ints.IntSet#remove(int) remove(int)} in its right
      place)&mdash;for instance, {@link it.unimi.dsi.fastutil.ints.IntList}.  We are
      sorry for this inconvenience, but there was no other way to work around
      the problem.

	<P>The huge number of classes, moreover, required a division in
	subpackages. Each subpackage contains classes with a given type of keys
	or elements.

	<P>As of 2.60, there was a major overhaul of iterators. Now iterators
	must be skippable, so previous implementation of type-specific iterator
	interfaces (e.g., {@link it.unimi.dsi.fastutil.ints.IntIterator}) will not
	work. However, new abstract classes allow to build iterator with ease
	by providing for free the skipping logic, and many useful static
	methods in Iterators allow to generate type-specific iterators wrapping
	standard iterators, arrays, etc. Moreover, the name of abstract
	classes always start with <samp>Abstract</samp> (so what was an
	<code>IntAbstractComparator</code> is now an {@link
	it.unimi.dsi.fastutil.ints.AbstractIntComparator}). Please read the section
	about iterators and comparators.

	<P>As of 2.52, the package name has changed from
	<samp>it.unimi.dsi.fastUtil</samp> to
	<samp>it.unimi.dsi.fastutil</samp>. Also the RPM and the jar file name
	have changed, so you can get a smooth transition by leaving both of
	them around for a while. However, you should modify your sources and
	erase the old package and jar file as soon as possible.
	
	</blockquote>

	 <h2>Package Specification</h2>

	 
	 <p>The classes of this package specialize the most useful {@link
	 java.util.HashSet}, {@link java.util.HashMap}, {@link
	 java.util.LinkedHashSet}, {@link java.util.LinkedHashMap}, {@link
	 java.util.TreeSet}, {@link java.util.TreeMap}, {@link
	 java.util.IdentityHashMap}, {@link java.util.ArrayList} and {@link
	 java.util.Stack} classes to versions that accept a specific kind of
	 key or value. Moreover, the techniques used in the available
	 implementations are quite different: open-addressing hash tables,
	 threaded AVL trees, threaded red-black trees and exclusive-or
	 lists. Class names adhere to the general pattern</p>

	 <div style="padding: 1em">
		<var>valuetype</var> <var>collectiontype</var>
	 </div>
	 
	 <p>for collections, and</p>
	 
	 <div style="padding: 1em">
		<var>keytype</var> 2 <var>valuetype</var> <var>maptype</var>
	 </div>
	 
	 <p>for maps. Presently, possible values for <var>collectiontype</var>
	 are <code>OpenHashSet</code>, <code>LinkedOpenHashSet</code>,
	 <code>AVLTreeSet</code>, <code>RBTreeSet</code>,
	 <code>ArrayList</code>, and <code>ArrayFrontCodedList</code>, whereas
	 possible values for <var>maptype</var> are <code>OpenHashMap</code>,
	 <code>LinkedOpenHashMap</code>, <code>AVLTreeMap</code> and
	 <code>RBTreeMap</code>.

         <P>Correspondingly, there are interfaces with names derived from
         {@link java.util.Set}, {@link java.util.SortedSet}, {@link
         java.util.List}, {@link java.util.List}, {@link java.util.Stack},
         {@link java.util.Map}, {@link java.util.SortedMap} and {@link
         java.util.Iterator}.  Additionally, <code>fastutil</code> provides
         {@link it.unimi.dsi.fastutil.BidirectionalIterator}, for iterators
         that can move back and forth, but do not provide the full power of a
         {@link java.util.ListIterator}.

         <P>Finally, analogously to {@link java.util} there are several static
         container class, named by making an interface name plural (e.g.,
         {@link it.unimi.dsi.fastutil.ints.IntSets}, {@link
         it.unimi.dsi.fastutil.chars.Char2LongMaps}, but also {@link
         it.unimi.dsi.fastutil.doubles.DoubleArrays}, {@link
         it.unimi.dsi.fastutil.Sets}, and so on), that contain useful static
         methods.
	
         <P>By "type" here I mean a capitalized primitive type, {@link
         java.lang.Object} or <code>Reference</code>. In the latter case, we
         are treating objects, but their equality is established by reference
         equality (that is, without invoking <code>equals()</code>), similarly
         to {@link java.util.IdentityHashMap}. Of course, reference-based
         classes are significantly faster.</p>

	 <P>Thus, an {@link it.unimi.dsi.fastutil.ints.IntOpenHashSet} stores
	 integers efficiently, whereas a {@link
	 it.unimi.dsi.fastutil.longs.Long2IntAVLTreeMap} does the same for maps
	 from longs to integers (but the map will be sorted, tree based, and
	 balanced using the AVL criterion). A {@link
	 it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet} stores longs in a
	 hash table, but provides a predictable iteration order (the insertion
	 order) and access to first/last elements of the order. A {@link
	 it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap} is
	 similar to an {@link java.util.IdentityHashMap}. {@link
	 it.unimi.dsi.fastutil.bytes.ByteArrayFrontCodedList Front-coded
	 lists} are highly specialized immutable data structures that store
	 compactly a large number of arrays: if you don't know them you
	 probably don't need them.
      	 
	 <p>Since there are eight primitive types in Java, and we support
	 reference-based containers, we get 1061 (!) classes (some nonsensical
	 classes, such as <code>Boolean2BooleanAVLTreeMap</code>, are not
	 generated). Many classes are generated just to mimic the hierarchy of
	 {@link java.util} so to redistribute common code in a similar way.</p>

    	 <p>The huge number of classes required a suitable division in
    	 subpackages (more than anything else, to avoid crashing browsers with
    	 a preposterous package summary). Each subpackage is characterized by
    	 the type of elements or keys: thus, for instance, {@link
    	 it.unimi.dsi.fastutil.ints.IntSet} belongs to {@link
    	 it.unimi.dsi.fastutil.ints} (the plural is required, as
    	 <code>int</code> is a keyword and cannot be used in a package
    	 name), as well as {@link
    	 it.unimi.dsi.fastutil.ints.Int2ReferenceRBTreeMap}. Note that all classes for non-primitive elements and keys are
    	 gathered in {@link it.unimi.dsi.fastutil.objects}.


	 <p><strong>All classes are not synchronized</strong>. If multiple threads access one
	 of these classes concurrently, and at least one of the threads modifies it,
	 it must be synchronized externally. Iterators will behave unpredictably in
	 the presence of concurrent modifications. Reads, however, can be carried
	 out concurrently.

	 <p><strong>Reference-based classes violate the {@link java.util.Map}
	 contract</strong>. They intentionally compare objects by reference, and do
	 not use the <code>equals()</code> method. They should be used only
	 when reference-based equality is desired (for instance, if all
	 objects involved are canonized, as it happens with interned strings).

	 <p><strong>Linked classes do not implement completely the {@link
	 java.util.SortedMap} interface</strong>. They provide methods to get the
	 first and last element in iteration order, but any submap or subset
	 method will cause an {@link java.lang.UnsupportedOperationException}.
         (this may change in future versions).

	 <p><strong>Substructures in sorted classes allow the creation of
	 arbitrary substructures</strong>. In {@link java.util}, instead, you
	 can only create contained sub-substructures (BTW, why?). For instance,
	 <code>(new TreeSet()).tailSet(new Integer(1)).tailSet(new
	 Integer(0))</code> will throw an exception, but {@link
	 it.unimi.dsi.fastutil.ints.IntRBTreeSet (new
	 IntRBTreeSet()).tailSet(1).tailSet(0)} won't.

	 <p><strong>Immutability is syntactically based (as opposed to
	 semantically based)</strong>. All methods that are known not to be
	 causing modifications to the structure at compile time will not throw
	 exceptions (e.g., {@link it.unimi.dsi.fastutil.Sets#EMPTY_SET
	 EMPTY_SET.clear()}). All other methods will cause an {@link
	 java.util.UnsupportedOperationException}.  Note that (as of Java 1.4)
	 the situation in {@link java.util} is definitely different, and
	 inconsistent: for instance, in singletons <code>add()</code> always
	 throws an exception, whereas <code>remove()</code> does it only if the
	 singleton would be modified.

	 <h3>Implemented Interfaces</h3>
	 
	 <p>All maps, sets and lists in <code>fastutil</code> implement their standard
	 counterpart interface (e.g., {@link java.util.Map} for maps). Thus, they
	 can be just plugged into existing code, using the standard access methods
	 (of course, any attempt to use the wrong type for keys or values will
	 produce a {@link java.lang.ClassCastException}). However, they also provide
	 (whenever possible) many polymorphic versions of the most used methods that
	 lessen the tedious "type juggling" that is well known to Java
	 programmers. In doing so, they implement more stringent interfaces that
	 extend the standard ones (e.g., {@link
	 it.unimi.dsi.fastutil.ints.Int2IntSortedMap} or {@link
	 it.unimi.dsi.fastutil.ints.IntListIterator}).</p>
	 
	 <h3>Additional Features and Methods</h3>

	 <p>The new interfaces add some very natural methods. Moreover, whenever
	 possible, the object returned is type-specific, or even implements a more
	 powerful interface.

	 <p>Due to some limitations of Java (you cannot override covariantly the
	 return value of an interface, i.e., with a method returning a more
	 specific value), however, sometimes these features are available only
	 by means of type casting.

	 <P>More in detail:
	 <UL>
		
		<LI>Keys and values of a map are of the <code>fastutil</code> type you
		would expect (e.g., the keys of an {@link
		it.unimi.dsi.fastutil.ints.Int2LongSortedMap} are an {@link
		it.unimi.dsi.fastutil.ints.IntSortedSet} and the values are a {@link
		it.unimi.dsi.fastutil.longs.LongCollection}), but you must explicitly cast the
		objects returned by {@link java.util.Map#keySet() keySet()} and {@link
		java.util.Map#values() values()} to the appropriate type.

		<LI>Submaps of a sorted map and subsets of a sorted sets are of the
		<code>fastutil</code> type you would expect, too. The standard
		constructors return a {@link java.util.SortedMap} or a {@link
		java.util.SortedSet}, respectively, which can be safely cast to
		the right type-specific interface. However, if you use extended
		interfaces and keys are not objects, then there are new methods accepting
		primitive keys and returning a type-specific sorted structure directly
		(see, e.g., {@link it.unimi.dsi.fastutil.ints.Int2IntSortedMap}).

		<LI>Iterators returned by {@link java.util.Set#iterator()
		iterator()} can be cast to the obvious type (e.g., {@link
		it.unimi.dsi.fastutil.chars.CharIterator} for a {@link
		it.unimi.dsi.fastutil.chars.CharSet}), too. There is also an
		additional method returning directly a type-specific iterator
		(see, e.g., {@link
		it.unimi.dsi.fastutil.ints.IntCollection#intIterator()
		intIterator()}). See below for more information on
		<code>fastutil</code> iterators.

		<LI>Sorted structures in <code>fastutil</code> return (possibly
		type-specific) {@linkplain
		it.unimi.dsi.fastutil.BidirectionalIterator bidirectional
		iterators}. This means that you can move back and forth among
		entries, keys or values. Again, you must manually cast the
		result of a call to {@link java.util.Set#iterator() iterator()}
		to {@link it.unimi.dsi.fastutil.BidirectionalIterator} or, even
		better, to a type-specific bidirectional iterator such as
		{@link it.unimi.dsi.fastutil.ints.IntBidirectionalIterator}. Note that
		sometimes the return value is explicitly marked to be castable
		to an even more powerful type-specific {@linkplain
		java.util.ListIterator list iterator}.

		<LI>The type-specific sorted set interfaces, moreover, feature an optional
		method <code>iterator(from)</code> which creates a type-specific {@link
		it.unimi.dsi.fastutil.BidirectionalIterator} starting from a given
		element of the domain (not necessarily in the set). See, for instance,
		{@link it.unimi.dsi.fastutil.ints.IntSortedSet#iterator(int)}. The method is
		implemented by all type-specific sorted sets and subsets.

		<LI>Finally, there are constructors that allow you to build easily sets
		using array and iterators. This means, for instance, that you can create quickly a
		set of strings with a statement like
		  <blockquote>
			 <code>new ObjectOpenHashSet( new String[] { "foo", "bar" } )</code>
		  </blockquote>
                 or just "unroll" the integers returned by an iterator into a list with
		  <blockquote>
			 <code>new IntArrayList( iterator )</code>
		  </blockquote>

	 </UL>


	 <P>There are a few quirks, however, that you should be aware of:

	 <ul>

		<li>The versions of the {@link java.util.Map#get(Object)
		get()}, {@link java.util.Map#put(Object,Object) put()} and
		{@link java.util.Map#remove(Object) remove()} methods that
		return a primitive type cannot, of course, rely on returning
		<code>null</code> to denote the absence of a certain
		pair. Rather, they return a <em>{@linkplain
		it.unimi.dsi.fastutil.ints.Int2LongMap#defaultReturnValue(long) default 
	  	return value}</em>, which is set to 0 cast to the
		return type (<code>false</code> for booleans) at creation, but
		can be changed using the <code>defaultReturnValue()</code>
		method (see, e.g., {@link
		it.unimi.dsi.fastutil.ints.Int2IntMap}). Note that changing the
		default return value does not change anything about the data
		structure; it is just a way to return a reasonably meaningful
		result&mdash;it can be changed at any time. As a commodity,
		even maps returning objects can use
		<code>defaultReturnValue()</code> (of course, in this case the
		default return value is initialized to <code>null</code>). A
		submap or subset has an independent default return value (which
		however is initialized to the default return value of the
		originator).</li>

		<li>For all maps that have object as keys, the {@link
		java.util.Map#get(Object) get()} and {@link
		java.util.Map#remove(Object) remove()} methods do not admit
		polymorphic versions, as Java does not allow return-value
		polymorphism. Rather, the extended interfaces introduce new
		methods of the form {@link
		it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap#getInt(Object)
		get<var>valuetype</var>()} and {@link
		it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap#removeInt(Object)
		remove<var>valuetype</var>()}. Similar problems occur with
		{@link it.unimi.dsi.fastutil.chars.CharSortedSet#firstChar()
		first()}, {@link
		it.unimi.dsi.fastutil.chars.CharSortedSet#lastChar() last()},
		and so on.</li>

		<LI>Similarly, all iterators have a suitable method {@link
		it.unimi.dsi.fastutil.ints.IntIterator#nextInt()
		next<var>type</var>()} returning directly a primitive type.
		And, of course, you have a type-specific version of {@link
		java.util.ListIterator#previous() previous()}.

		<li>For the same reason, the method {@link java.util.Collection#toArray}
		has a polymorphic version accepting a type-specific array, but there are
		also explicitly typed methods
		{@link it.unimi.dsi.fastutil.bytes.ByteCollection#toByteArray() to<var>keytype</var>Array()}.</li>

		<li>A name clash between the list and collection interfaces
		forces the deletion method of an collection to be named {@link
		it.unimi.dsi.fastutil.doubles.DoubleCollection#rem(double)
		rem()}. At the risk of creating some confusion, {@link
		it.unimi.dsi.fastutil.doubles.DoubleSet#remove(double) remove()}
		reappears in the type-specific set interfaces, so the only
		really unpleasant effect is that you must use
		<code>rem()</code> on variables that are collections, but not
		sets&mdash;for instance, {@linkplain
		it.unimi.dsi.fastutil.ints.IntList type-specific lists}.

		<li>There are type-specific versions of {@link java.util.Comparator} that
		require specifying both a type-specific comparison method and an object-based
		one; this is necessary as a type-specific comparator must implement {@link
		java.util.Comparator}. However, to simplify the creation of type-specific
		comparators there are abstract type-specific comparator classes that
		implement an object-based comparator wrapping the (abstract)
		type-specific one; thus, if you need to create a type-specific comparator
		you just have to inherit from those classes and define the type-specific
		method. Analogously for iterators.

		<li>Stacks are <em>interfaces</em> implemented by array-based
		lists: the interface, moreover, is slightly different from the
		implementation contained in {@link java.util.Stack}.
	 </ul>

    	 <h2>Static Container Classes</h2>

    	 <P><code>fastutil</code> provides a number of static methods and
    	 singletons, much like {@link java.util.Collection}. To avoid creating
    	 classes with hundreds of methods, there are separate containers for
    	 sets, lists, maps and so on. Generic containers are placed in {@link
    	 it.unimi.dsi.fastutil}, whereas type-specific containers are in the
    	 appropriate package.  You should look at the documentation of the
    	 static classes contained in {@link it.unimi.dsi.fastutil}, and in
    	 type-specific static classes such as {@link
    	 it.unimi.dsi.fastutil.chars.CharSets}, {@link
    	 it.unimi.dsi.fastutil.floats.Float2ByteSortedMaps}, and {@link
    	 it.unimi.dsi.fastutil.longs.LongArrays}.  Presently, you can easily
    	 obtain {@linkplain it.unimi.dsi.fastutil.Sets#EMPTY_SET empty collections},
    	  {@linkplain it.unimi.dsi.fastutil.longs.Long2IntMaps#EMPTY_MAP empty
    	 type-specific collections}, {@linkplain
    	 it.unimi.dsi.fastutil.ints.IntLists#singleton(int) singletons}, and
    	 {@linkplain
    	 it.unimi.dsi.fastutil.objects.Object2ReferenceSortedMaps#synchronize(Object2ReferenceSortedMap)
    	 synchronized versions} of any type-specific container.
      
         <P>On a completely different side, the {@linkplain
         it.unimi.dsi.fastutil.ints.IntArrays type-specific static container
         classes for arrays} provide several useful methods that allow to treat
         an array much like an array-based list, hiding completely the growth
         logic. In many cases, using this methods and an array is even simpler
         then using a full-blown {@linkplain
         it.unimi.dsi.fastutil.doubles.DoubleArrayList type-specific
         array-based list} because elements access is syntactically much
         simpler.


    	 <h2>Iterators and Comparators</h2>

    	 <P><code>fastutil</code> provides type-specific iterators and
    	 comparators. The interface of a <code>fastutil</code> iterator is
    	 slightly more powerful than that of a {@link java.util} iterator, as
    	 it contains a {@link it.unimi.dsi.fastutil.objects.ObjectIterator#skip(int)
    	 skip()} method that allows to skip over a list of elements (an
    	 {@linkplain
    	 it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator#back(int) analogous
    	 method} is provided for bidirectional iterators). For objects (even
    	 those managed by reference), the extended interface is named {@link
    	 it.unimi.dsi.fastutil.objects.ObjectIterator}; it is the return type, for
    	 instance, of {@link
    	 it.unimi.dsi.fastutil.objects.ObjectCollection#objectIterator()}.
      
      	 <code>fastutil</code> provides also classes and methods that makes it
      	 easy to create type-specific iterators and comparators. There are abstract versions of
      	 each (type-specific) iterator and comparator that implement in the
      	 obvious way some of the methods (see, e.g., {@link
      	 it.unimi.dsi.fastutil.ints.AbstractIntIterator} or {@link
      	 it.unimi.dsi.fastutil.ints.AbstractIntComparator}).

      	<P>A plethora of useful static methods is also provided by various
      	type-specific static containers (e.g., {@link
      	it.unimi.dsi.fastutil.ints.IntIterators}) and by {@link
      	it.unimi.dsi.fastutil.Iterators}: among other things, you can
      	{@linkplain it.unimi.dsi.fastutil.ints.IntIterators#wrap(int[]) wrap
      	arrays} and {@linkplain
      	it.unimi.dsi.fastutil.ints.IntIterators#asIntIterator(java.util.Iterator)
      	standard iterators} in type-specific iterators, {@linkplain
      	it.unimi.dsi.fastutil.ints.IntIterators#fromTo(int,int) generate them}
      	giving an interval of elements to be returned, {@linkplain
      	it.unimi.dsi.fastutil.objects.ObjectIterators#concat(ObjectIterator[])
      	concatenate them} or {@linkplain
      	it.unimi.dsi.fastutil.objects.ObjectIterators#pour(Iterator,ObjectSet)
      	pour them} into a set.



      <h2>Abstract Classes</h2>

      <p><code>fastutil</code> provides a wide range of abstract classes, to
      help in implementing its interfaces. They take care, for instance, of
      providing wrappers for non-type-specific method calls, so that you have to
      write just the (usually simpler) type-specific version. 


      
	 <h2>Performance</h2>
	 
	 <p>The main reason behind <code>fastutil</code> is performance, both in
	 time and in space. The relevant methods of type-specific hash maps and sets
	 are something like 2 to 10 times faster than those of the standard
	 classes. Note that performance of hash-based classes on object keys is
	 usually <em>worse</em> (from a few percent to doubled time) than that of
	 {@link java.util}, because <code>fastutil</code> classes do not cache hash
	 codes. Of course, you can try to get more speed from hash tables using a
	 small load factor (say, 1/2).

	 <p>For tree-based classes you have two choices: AVL and red-black
	 trees. The essential difference is that AVL trees are more balanced (their
	 height is at most 1.44 log <var>n</var>), whereas red-black trees have
	 faster deletions (but their height is at most 2 log <var>n</var>). So on
	 small trees red-black trees could be faster, but on very large sets AVL
	 trees will shine. In general, AVL trees have slightly slower updates but
	 faster searches; however, on very large collections the smaller height may
	 lead in fact to faster updates, too.

	 <p><code>fastutil</code> reduces enormously the creation and collection of
	 objects. First of all, if you use the polymorphic methods and iterators no
	 wrapper objects have to be created. Moreover, since <code>fastutil</code>
	 uses open-addressing hashing techniques, creation and garbage collection of
	 hash-table entries are avoided (but tables have to be rehashed whenever
	 they are filled beyond the load factor). The major reduction of the number
	 of objects around has a definite (but very difficult to measure) impact on
	 the whole application (as garbage collection runs proportionally to the
	 number of alive objects).

    <p>Whenever possible, <code>fastutil</code> tries to gain some speed by
    checking for faster interfaces: for instance, the various set-theoretic
    methods <code>addAll()</code>, <code>retainAll()</code>, ecc. check whether
    their arguments are type-specific and use faster iterators and accessors
    accordingly.
	 

	 <h3>Deletions in Hash Tables</h3>

	 <p>Since deletions in hash tables are handled simply by tagging, they are
	 very fast <i>per se</i>, but they tend to slow down subsequent accesses
	 (with respect to a table with no deleted entries). In highly dynamical
	 situations, where entries are continuously created and deleted,
	 unsuccessful searches may take linear time (as <em>all</em> entries must be
	 probed).

	 <p>A partial solution to this problem (which has no known complete
	 solution if you use open addressing with double
	 hashing&mdash;cfr. Knuth's section on hashing in the third volume of
	 <i>The Art of Computer Programming</i>) is to call the
	 <code>rehash()</code> method, which will try to rebuild the table
	 remapping all keys. There are also <code>trim()</code> methods that
	 will reduce the table size if possible.

	 <p>In other words, if your application requires inextricably interleaved
	 insertions, deletions and queries open-addressing hash-table
	 implementations (and in particular <code>fastutil</code> classes) are not
	 the right choice.

	 <p>Note, however, that <code>fastutil</code> implements a special
	 optimization, usually not found elsewhere, that speeds up probes for
	 recently deleted entries. More details can be found in the documentation of
	 the {@link it.unimi.dsi.fastutil.Hash} interface.

      	 <P>The case of linked tables is even more problematic: the deletion of
      	 an item requires a linear probe of the links until the item is found,
      	 and thus it has potentially linear cost (however, this is not true if
      	 the deletion is performed by means of an iterator, or if you delete
      	 the last element).

	 <h2>Memory Usage</h2>

	 <h3>Hash Tables</h3>

	 <p>To avoid memory waste, (unlinked) hash tables in
	 <code>fastutil</code> keep no additional information about elements
	 (such as a list of keys). In particular, this means that enumerations
	 are always linear in the size of the table (rather than in the number
	 of keys). Usually, this would imply slower iterators. Nonetheless, the
	 iterator code includes a single, tight loop; moreover, it is possible
	 to avoid the creation of wrappers. These two facts make in practice
	 <code>fastutil</code> iterators <em>faster</em> than {@link
	 java.util}'s.

	 <p>The memory footprint for a table with <var>n</var> keys is exactly the
	 memory required for the related types times <var>n</var>, plus a
	 overhead of <var>n</var> bytes to store the state of each entry. The
	 absence of wrappers around primitive types can reduce space occupancy by
	 several times (this applies even more to serialized data, e.g., when you
	 save such a data structure in a file).  These figures can greatly vary with
	 your virtual machine, JVM versions, CPU etc.

	 <p>More precisely, when you ask for a map that will hold <var>n</var>
	 elements with load factor 0&nbsp;&lt;&nbsp;<var>f</var>&nbsp;&le;&nbsp;1, <var>p</var> entries are
	 allocated, where <var>p</var> is first prime in {@link
	 it.unimi.dsi.fastutil.Hash#PRIMES} larger than
	 <var>n</var>&nbsp;/&nbsp;<var>f</var>. Primes in {@link
	 it.unimi.dsi.fastutil.Hash#PRIMES} are roughly multiplicatively spaced by
	 2<sup>1/16</sup>, so you lose on average about 2% with respect to
	 <var>n</var>&nbsp;/&nbsp;<var>f</var>. 

    <P>When the table is filled up beyond the load factor, it is rehashed to a
    larger size. The growth is controlled by the <em>growth factor</em>, which
    can be set at any time. By default, the table size is doubled (for more
    information, see {@link it.unimi.dsi.fastutil.ints.IntOpenHashSet}), but
    you can trade speed for memory occupancy by {@linkplain
      it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap#growthFactor(int) setting a slower growth rate}.

      	 <p>In the case of linked hash tables, there is an additional vector of
      	 <var>p</var> integers that is used to store link information. Each
      	 element records the next and previous element indexes exclusive-or'd
      	 together. As a result, linked tables provide bidirectional iterators
      	 without having to store two pointers per entry (however, iterators
      	 starting from a given element require a linear probe to be
      	 initialized, unless the element is the last one).
      
	 <p>Since hash codes are not cached, equality on objects is checked
	 first by checking equality of their {@link java.lang.Object#hashCode()
	 hashCode()}, and then using {@link java.lang.Object#equals(Object)
	 equals()}. This turns out to increase slightly the performance, as
	 many classes (including {@link java.lang.String}) cache their hash
	 codes; in any case, the speed cannot reach that of {@link java.util}'s
	 hash classes, which cache hash codes.


	 <h3>Balanced Trees</h3>

	 <p>The balanced trees implementation is also very parsimonious.
	 <code>fastutil</code> is based on the excellent (and unbelievably well
	 documented) code contained in Ben Pfaff's <A
	 HREF="http://www.msu.edu/~pfaffben/avl/">GNU libavl</A>, which describes in
	 detail how to handle balanced trees with <em>threads</em>. Thus, the
	 overhead per entry is two pointers and one integer, which compares well to
	 three pointers plus one boolean of the standard tree maps. The trick is
	 that we use the integer bit by bit, so we consume two bits to store thread
	 information, plus one or two bits to handle balancing. As a result, we get
	 bidirectional iterators in constant space and amortized constant time
	 without having to store references to parent nodes.
		
	 <P>It should be mentioned that all tree-based classes have a fixed overhead
	 for some arrays that are used as stacks to simulate recursion; in
	 particular, we need 48 booleans for AVL trees and 64 pointers plus 64
	 booleans for red-black trees.

	<h2>An Example</h2>

	<P>Suppose you want to store a sorted map from longs to integers. The first
	step is to define a variable of the right interface, and assign it a new
		tree map (say, of the AVL type):
<PRE>
Long2IntSortedMap m = new Long2IntAVLTreeMap();
</PRE>
    <P>Now we can easily modify and access its content:
<PRE>
m.put( 1, 5 );
m.put( 2, 6 );
m.put( 3, 7 );
m.put( 1000000000L, 10 );
m.get( 1 ); // This method call will return 5
m.get( 4 ); // This method call will return 0
</PRE>
	 <P>We can also try to change the default return value:
<PRE>
m.defaultReturnValue( -1 );
m.get( 4 ); // This method call will return -1
</PRE>
	 <P>By suitable type casting, we can obtain a very powerful iterator:
<PRE>
LongListIterator i = (LongListIterator)((LongSortedSet)m.keySet()).iterator();
// Now we sum all keys
long s = 0;
while( i.hasNext() ) s += i.nextLong();
</PRE>
	 <P>If one just needs a type-specific iterator, there is a special
      method that avoids casting:
<PRE>
LongIterator i = ((LongSortedSet)m.keySet()).longIterator();
// Now we sum all keys
long s = 0;
while( i.hasNext() ) s += i.nextLong();
</PRE>
	 <P>We now generate a head map, and iterate bidirectionally over it starting
		from a given point:
<PRE>
// This map contains only keys smaller than 4
Long2IntSortedMap m1 = m.headMap( 4 );
// This iterator is positioned between 2 and 3
LongBidirectionalIterator t = ((LongSortedSet)m1.keySet()).iterator( 2 );
t.previous(); // This method call will return 2 (t.next() would return 3)
</PRE>
	 <P>Should we need to access the map concurrently, we can wrap it:
<PRE>
// This map can be safely accessed by many threads
Long2IntSortedMap m2 = Longs2IntSortedMaps.synchronize( m1 );
</PRE>
	 <P>Linked maps are very flexible data structures which can be used to implement, for
      instance, queues whose content can be probed efficiently:
<PRE>
// This map remembers insertion order (note that we are using the array-based constructor)
IntSortedSet s = new IntLinkedOpenHashSet( new int[] { 4, 3, 2, 1 } );
s.firstInt(); // This method call will return 4
s.lastInt(); // This method call will return 1
s.contains(5); // This method will return false
IntBidirectionalIterator i = s.iterator( s.lastInt() ); // We could even cast it to a list iterator 
i.previous(); // This method call will return 1
i.previous(); // This method call will return 2
s.remove(s.lastInt()); // This will remove the last element in constant time
</PRE>
    <P>Finally, we play with iterators. It is easy to create iterators over
      intervals or over arrays, and combine them:
<PRE>
IntIterator i = Iterators.fromTo( 0, 10 ); // This iterator will return 0, 1, ..., 9.
int a[] = new int[] { 5, 1, 9 };
IntIterator j = Iterators.wrap( a ); // This iterator will return 5, 1, 9.
IntIterator k = Iterators.concat( new IntIterator[] { i , j } ); // This iterator will return 0, 1, ..., 9, 5, 1, 9.
</PRE>
  </body>
</html>
