<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>fastUtil</title>
  </head>

  <body>

	 <P>Provides type-specific maps and sets with a small memory
	 footprint and much (2 to 10 times) faster access and insertion. It is <A
	 HREF="http://www.gnu.org/philosophy/free-sw.html">free software</A>
	 distributed under the <A
	 HREF="http://www.gnu.org/copyleft/lesser.html"><ACRONYM TITLE="GNU's not
	 Unix">GNU</ACRONYM> Lesser General Public License</A>.

	 <h2>Package Specification</h2>

	 <p>The classes of this package specialise the most useful {@link
	 java.util.HashSet}, {@link java.util.HashMap}, {@link java.util.TreeSet}
	 and {@link java.util.TreeMap} classes to versions that accept a specific
	 kind of key or value.

	 The general format is</p>
		<div style="padding: 1em">
		  <var>valuetype</var> <var>settype</var>
		</div>
		<p>for sets, and</p>
		<div style="padding: 1em">
		  <var>keytype</var> 2 <var>valuetype</var> <var>maptype</var>
		</div>
	 <p>for maps.Thus, an {@link it.unimi.dsi.fastUtil.IntHashSet} stores
	 integers efficiently, whereas a {@link
	 it.unimi.dsi.fastUtil.Long2IntTreeMap} does the same for maps from long
	 integers to integers (but the map will be sorted). By "type" here I mean a
	 capitalised primitive type, or {@link java.lang.Object}.</p>
	 
	 <p>Since there are eight primitive types in Java, we get 434 (!) classes
	 (some nonsensical class, such as <code>Boolean2BooleanHashMap</code>, are
	 not generated). Many classes are generated just to mimic the hierarchy of
	 {@link java.util} so to redistribute common code in a similar way.</p>
	 
	 <p><b>All classes are not synchronised</b>. If multiple threads access one
	 of these classes concurrently, and at least one of the threads modifies it,
	 it must be synchronised externally. Iterators will behave unpredictably in
	 the presence of concurrent modifications.

	 <h3>Interfaces Implemented</h3>
	 
	 <p>All maps and sets in <code>fastUtil</code> implement their standard
	 counterpart interface (e.g., {@link java.util.Map} for maps). Thus, they
	 can be just plugged into existing code, using the standard access methods
	 (of course, any attempt to use the wrong type for keys or values will
	 produce a {@link java.lang.ClassCastException}). However, they also provide
	 (whenever possible) many polymorphic versions of the most used methods that
	 allow to avoid the tedious "type juggling" that is well known to Java
	 programmers. In doing so, they implement more stringent interfaces that
	 extend the standard ones (e.g., {@link
	 it.unimi.dsi.fastUtil.Int2IntSortedMap} or {@link
	 it.unimi.dsi.fastUtil.IntListIterator}.</p>
	 
	 <h3>Additional Features and Methods</h3>

	 <p>The new interfaces add some very natural methods. Moreover, whenever
	 possible, the object returned is type-specific, or even implements a more
		powerful interface.

	 <p>Due to some limitation of Java (you cannot override covariantly the
	 return value of an interface, i.e., with a method returning a more
	 type-specific value), however, sometimes these features
	 are available only by means of type casting.

	 <P>More in detail:
	 <UL>
		
		<LI>Keys and values of a map are of the <code>fastUtil</code> type you
		would expect (e.g., the keys of an {@link
		it.unimi.dsi.fastUtil.Int2LongSortedMap} are an {@link
		it.unimi.dsi.fastUtil.IntSortedSet} and the values are a {@link
		it.unimi.dsi.fastUtil.LongCollection}), but you must explicitly cast the
		objects returned by {@link java.util.Map#keySet()} and {@link
		java.util.Map#values()} to the appropriate type.

		<LI>Submaps of a sorted map and subsets of a sorted sets are of the
		<code>fastUtil</code> type you would expect, too. The standard
		constructors return a {@link java.util.SortedMap} or a {@link
		java.util.SortedSet}, respectively, which of course can be safely cast to
		the right type-specific interface. However, if you use extended
		interfaces and keys are not objects, then there are new methods accepting
		primitive keys and returning a type-specific sorted structure directly
		(see, e.g., {@link it.unimi.dsi.fastUtil.Int2IntSortedMap}).

		<LI>Iterators returned by {@link java.util.Set#iterator()} can be cast to
		the obvious type (e.g., {@link it.unimi.dsi.fastUtil.CharIterator} for a
		{@link it.unimi.dsi.fastUtil.CharSet}), too.

		<LI>Sorted structures in <code>fastUtil</code> return type-specific
		{@link java.util.ListIterator}s. This means that you can move back and
		forth among entries, keys or values. Again, you must manually cast the
		result of a call to <code>iterator()</code> to {@link
		java.util.ListIterator} or, even better, to a type-specific list iterator
		such as {@link it.unimi.dsi.fastUtil.IntListIterator}.

		<LI>Finally, there are constructors that allows you to build easily a set
		from an array. This means, for instance, that you can create quickly a
		set of strings with a statement like
		  <blockquote>
			 <code>new ObjectHashSet(new String[] { "foo", "bar" })</code>
		  </blockquote>

	 </UL>


	 <P>There are a few quirks, however, that you should be aware of:

	 <ul>

		<li>The versions of the {@link java.util.Map#get(Object)}, {@link
		java.util.Map#put(Object,Object)} and {@link
		java.util.Map#remove(Object)} methods that return a primitive type
		cannot, of course, rely on returning <code>null</code> to denote the
		absence of a certain pair. Rather, they return a <em>default return
		value</em>, which is set to 0 cast to the return type(or
		<code>false</code> for booleans and <code>null</code> for objects) at
		creation, but can be changed using the <code>setDefRetValue()</code>
		method. Note that changing the default return value does not change
		anything about the data structure; it is just a way to return a
		reasonably meaningful result&mdash;it can be changed at any time. As a
		commodity, even maps and sets returning objects can use
		<code>setDefRetValue()</code>. A submap or subset has an independent
		default return value (which however is initialised to the default return
		value of the originator).</li>

		<LI>Similarly, all iterators have a suitable method
		<code>next<var>type</var>()</code> returning directly a primitive type.
		And, of course, you have a type-specific version of {@link
		java.util.ListIterator#previous()}.

		<li>For all maps that have object as keys, the {@link
		java.util.Map#get(Object)} and {@link java.util.Map#remove(Object)}
		methods do not admit polymorphic versions, as Java does not allow
		return-value polymorphism. Rather, the extended interfaces introduce new
		methods of the form <code>get<var>valuetype</var>()</code> and
		<code>remove<var>valuetype</var>()</code>. Similar problems occur with
		<code>firstKey()</code>, <code>lastKey()</code> and so on.</li>

		<li>For the same reason, the method {@link java.util.Collection#toArray}
		has a polymorphic version accepting a type-specific array, but there are
		also explicitly typed methods
		<code>to<var>keytype</var>Array()</code>.</li>

	 </ul>

	
	 <h2>Performance</h2>
	 
	 <p>The main reason behind <code>fastUtil</code> is performance, both in
	 time and in space. The relevant methods of the hash maps and sets are
	 something like 2 to 10 times faster than those of the standard classes.
	 Tree maps and sets are not that faster, as the standard counterparts are
	 optimised rather well, but the lack of wrappers definitely gives a
	 performance boost.

	 <p><code>fastUtil</code> reduces enormously the creation and collection of
	 objects. First of all, if you use the polymorphic methods and iterators no
	 wrapper objects have to be created. Moreover, since <code>fastUtil</code>
	 uses open-addressing hashing techniques, creation and garbage collection of
	 hash-table entries are avoided (but tables have to be rehashed whenever they are
	 filled beyond the load factor).

    <p>Whenever possible, <code>fastUtil</code> tries to gain some speed by
    checking for faster interfaces: for instance, the various set-theoretic
    methods <code>addAll()</code>, <code>retainAll()</code>, ecc. check whether
    their arguments are type-specific and use faster iterators and accessors
    accordingly.
	 

	 <h3>Deletions in Hash Tables</h3>

	 <p>Since deletions in hash tables are handled simply by tagging, they are
	 very fast <i>per se</i>, but they tend to slow down subsequent accesses
	 (with respect to a table with no deleted entries). In highly dynamical
	 situations, where entries are continuously created and deleted,
	 unsuccessful searches may take linear time (as <em>all</em> entries must be
	 probed).

	 <p>A partial solution to this problem (which has no known complete solution
	 if you use open addressing with double hashing&mdash;cfr. Knuth's
	 section on hashing in the third volume of <i>The Art of Computer
	 Programming</i>) is to call the <code>rehash()</code> method, which will
	 try to rebuild the table remapping all keys.

	 <p>In other words, if your application requires inextricably interleaved
	 insertions, deletions and queries open-addressing implementations (and in
	 particular <code>fastUtil</code> classes) are not the right choice.

	 <p>Note, however, that <code>fastUtil</code> implements a special
	 optimisation, usually not found elsewhere, that greatly speeds up probes
	 for recently deleted entries. More details can be found in the
	 documentation of the {@link it.unimi.dsi.fastUtil.Hash} interface.

	 <h2>Memory Usage</h2>

	 <h3>Hash Tables</h3>

	 <p>To avoid memory waste, the hash tables in <code>fastUtil</code> keep no
	 additional information about elements (such as a list of keys). In
	 particular, this means that enumerations are always linear in the size of
	 the table (rather than in the number of keys). In general, this would imply
	 slower iterators. Nonetheless, the iterator code includes a single, tight
	 loop; moreover, it is possible to avoid the creation of wrappers. These two
	 facts make in practise <code>fastUtil</code> iterators <em>faster</em> than
	 {@link java.util}'s.

	 <p>The memory footprint for a table with <var>n</var> keys is exactly the
	 memory required for the related types times <var>n</var> bytes, plus a
	 overhead of <var>n</var> bytes to store the state of each entry. The
	 absence of wrappers around primitive types can reduce space occupancy by
	 several times (this applies even more to serialised data, e.g., when you
	 save such a data structure in a file).  These data can greatly vary with
	 your virtual machine, JVM versions, CPU etc.

	 <p>More precisely, when you ask for a map that will hold <var>n</var>
	 elements with load factor 0&nbsp;&lt;&nbsp;<var>f</var>&nbsp;&le;&nbsp;1, <var>p</var> entries are
	 allocated, where <var>p</var> is first prime in {@link
	 it.unimi.dsi.fastUtil.Hash#primes} larger than
	 <var>n</var>&nbsp;/&nbsp;<var>f</var>. Primes in {@link
	 it.unimi.dsi.fastUtil.Hash#primes} are roughly multiplicatively spaced by
	 2<sup>1/16</sup>, so you lose on average about 2% with respect to
	 <var>n</var>&nbsp;/&nbsp;<var>f</var>. When the table is filled up beyond the load
	 factor, it is rehashed to a roughly doubled size.

	 <p>An important downside of this design is that <em>hash codes are not
	 cached</em>. Thus, you should not use <code>fastUtil</code> classes with
	 keys having slow equality methods, as a probe requires testing equality
	 with all keys met along the probe sequence.

    <h3>Balanced Trees</h3>

	 <p>The balanced trees implementation is also very parsimonious.
	 <code>fastUtil</code> uses the excellent code described by Arne Andersson
	 in his paper <i>Balanced Search Trees Made Simple</i>, Proc.&nbsp; of the
	 Workshop on Algorithms and Data Structures, pages 60&minus;71,
	 Springer-Verlag, 1993, and combines it with <em>threads</em>. As a result,
	 the overhead per entry is two pointers and one integer, which compares well
	 to three pointers plus one boolean of the standard tree maps. The trick is
	 that Andersson's code requires just <i>o</i>(log log <var>n</var>) bits per
	 entry to store level information, so we can safely use a couple of other
	 bits to store thread information in each entry, and still fit into an
	 integer. As a result, we get bidirectional iterators in constant space and
	 amortised constant time without having to store references to parent nodes
	 (red-black trees are very nice in theory, but I know no language that
	 allows one to store <em>exactly one</em> bit in a data structure, without
	 alignment losses).


	 <h2>Robustness</h2>
	 
	 <p>The code in <code>fastUtil</code> has passed intensive regression
	 tests. You can trust it much in the same way you trust the standard
	 classes.</p>

  </body>
</html>
