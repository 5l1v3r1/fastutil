/*		 
 * fastUtil 1.3: Fast & compact specialized hash-based utility classes for Java
 *
 * Copyright (C) 2002 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package it.unimi.dsi.fastUtil;

import it.unimi.dsi.fastUtil.Hash; // workaround to force @see/@link

import java.util.*;
import java.io.*;

/** A type-specific hash map with a very fast, small-footprint implementation.
 * @see Hash
 * @see HashCommon
 */

public final class HASHMAP extends ABSTRACT_MAP implements Serializable, Cloneable, Hash, MAP {
	 /** The array of keys. */
	 private transient KEY_TYPE key[];

	 /** The array of values. */
	 private transient VALUE_TYPE value[];
	 
	 /** The array of occupancy states. */
	 private transient byte state[];

	 /** The acceptable load factor. */
	 private final float f;
	 
	 /** Index into the prime list, giving the current table size. */
	 private int p;

	 /** Table size. Must be the p-th item of {@link Hash#primes}. */
	 private transient int n;

	 /** Number of entries in the map. */
	 private int count;

	 /** Cached set of entries and keys. */
	 private transient volatile Set entries, keys;

	 /** Cached collection of values. */
	 private transient volatile Collection values;


	 /** Creates a new hash map.
	  *
	  * The actual table size is the least available prime greater than <code>n</code>/<code>f</code>.
	  *
	  * @param n the expected number of elements in the hash map.
	  * @param f the load factor.
	  * @see Hash#primes
	  */
	 
	 public HASHMAP( int n, float f ) {
		  if ( f <= 0 || f > 1 ) throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
		  if ( n < 0 ) throw new IllegalArgumentException("Hash table size must be nonnegative");

		  int l = Arrays.binarySearch(primes, (int)(n/f)+1);
		  if (l < 0) l = -l-1;

		  this.f = f;
		  this.n = primes[l];
		  p = l;
		  key = new KEY_TYPE[this.n];
		  value = new VALUE_TYPE[this.n];
		  state = new byte[this.n];
	 }
	 
	 
	 /** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	  *
	  * @param n the expected number of elements in the hash map.
	  */
	 
	 public HASHMAP(int n) {
		  this(n, DEFAULT_LOAD_FACTOR);
	 }



	 /** Creates a new hash map with {@link Hash#DEFAULT_INITIAL_SIZE} entries
	  * and {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	  */
	 
	 public HASHMAP() {
		  this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);
	 }


	 /** Creates a new hash map copying a given one.
	  *
	  * @param m a {@link Map} to be copied into the new hash map. 
	  * @param f the load factor.
	  */
	 
	 public HASHMAP( Map m, float f ) {
		  this(m.size(), f);
		  putAll(m);
	 }

	 /** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor copying a given one.
	  *
	  * @param m a {@link Map} to be copied into the new hash map. 
	  */
	 
	 public HASHMAP( Map m ) {
		  this(m, DEFAULT_LOAD_FACTOR);
	 }

	 /*
	  * The following private methods implements some basic building blocks used by
	  * all accessors.  They are (and should be maintained) identical to those used in HashSet.drv.
	  */

	 /** Searches for a key, keeping track of a possible insertion point.
	  *
	  * The instance variables used by the search are to be passed as parameters to
	  * increase access speed.
	  *
	  * @param k the key.
	  * @param key the key array.
	  * @param state the state array.
	  * @return the index of the correct insertion point, if the key is not found; otherwise,
	  * <var>-i</var>-1, where <var>i</var> is the index of the entry containing the key.
	  */

	 private int findInsertionPoint(final KEY_TYPE k, final KEY_TYPE key[], final byte state[]) {

		  // First of all, we make the key into a positive integer.
		  final int k2i = KEY2INT(k) & 0x7FFFFFFF; 
		  // The primary hash, a.k.a. starting point.
		  int h1 = k2i % n;
		  final int s = h1;
		  // The secondary hash.
		  final int h2 = (k2i % (n - 2)) + 1;

		  while( state[h1] == OCCUPIED && ! KEY_EQUAL( key[h1], k ) ) h1 = ( h1 + h2 ) % n; // There's always a non-OCCUPIED entry.

		  if (state[h1] == FREE) return h1;
		  if (state[h1] == OCCUPIED) return -h1-1; // Necessarily, KEY_EQUAL(key[h1], k).

		  /* Tables without deletions will never use code beyond this point. */

		  final int i = h1; // Remember first available bucket for later.
		  
		  /** See the comments in the documentation of the interface Hash. */
		  while( state[h1] != FREE && ! KEY_EQUAL( key[h1], k ) ) if ( (h1 = ( h1 + h2 ) % n) == s ) return i;
		  
		  return state[h1] == OCCUPIED ? -h1-1 : i; // In the first case, necessarily, KEY_EQUAL(key[h1], k).
	 }


	 /** Searches for a key.
	  *
	  * The instance variables used by the search are to be passed as parameters to
	  * increase access speed.
	  *
	  * @param k the key.
	  * @param key the key array.
	  * @param state the state array.
	  * @return the index of the entry containing the key, or -1 if the key wasn't found.
	  */

	 private int findKey(final KEY_TYPE k, final KEY_TYPE key[], final byte state[]) {

		  // First of all, we make the key into a positive integer.
		  final int k2i = KEY2INT(k) & 0x7FFFFFFF; 
		  // The primary hash, a.k.a. starting point.
		  int h1 = k2i % n;
		  final int s = h1;
		  // The secondary hash.
		  final int h2 = (k2i % (n - 2)) + 1;
		  
		  /** See the comments in the documentation of the interface Hash. */
		  while( state[h1] != FREE && ! KEY_EQUAL(key[h1], k) ) if ( (h1 = ( h1 + h2 ) % n) == s ) return -1;
		  return state[h1] == OCCUPIED ? h1 : -1;  // In the first case, necessarily, KEY_EQUAL(key[h1], k).
	 }




	 public Object put(final Object ok, final Object ov) {
		  final VALUE_TYPE oldValue, v = VALUE2TYPE(ov);
		  final KEY_TYPE key[] = this.key, k = KEY2TYPE(ok);
		  final byte state[] = this.state;

		  final int i = findInsertionPoint( k, key, state );
		  
		  if (i < 0) {
				oldValue = value[-i-1];
				value[-i-1] = v;
				return VALUE2OBJ(oldValue);
		  }

		  state[i] = OCCUPIED;
		  key[i] = k;
		  value[i] = v;
		  if ( ++count >= n * f ) rehash( Math.min(p+16, primes.length-1) ); // Table too filled, let's rehash
		  return null;
	 }
	 

#if ! ( #valueclass(Object) && #keyclass(Object) )


	 public VALUE_TYPE put(final KEY_TYPE k, final VALUE_TYPE v) {
		  final VALUE_TYPE oldValue;
		  final KEY_TYPE key[] = this.key;
		  final byte state[] = this.state;

		  final int i = findInsertionPoint( k, key, state );
		  
		  if (i < 0) {
				oldValue = value[-i-1];
				value[-i-1] = v;
				return oldValue;
		  }

		  state[i] = OCCUPIED;
		  key[i] = k;
		  value[i] = v;
		  if ( ++count >= n * f ) rehash( Math.min(p+16, primes.length-1) ); // Table too filled, let's rehash
		  return DEF_RET_VALUE;
	 }


#endif

	 public Object remove(final Object ok) {
		  final KEY_TYPE k = KEY2TYPE(ok);
		  final byte state[] = this.state;

		  final int i = findKey(k, key, state);
		  if (i < 0) return null;

		  state[i] = REMOVED;

#if #keyclass(Object)
		  key[i] = HashCommon.removed;
#endif
#if #valueclass(Object)
		  final Object v = value[i];
		  value[i] = HashCommon.removed;
#endif

		  count--;

#if #valueclass(Object)
		  return v;
#else
		  return VALUE2OBJ( value[i] );
#endif
	 }

#if ! #valueclass(Object) 
	 
	 public boolean containsValue(final Object v) {
		  return containsValue(VALUE2TYPE(v));
	 }

#endif



	 public boolean containsValue(final VALUE_TYPE v) {
		  final VALUE_TYPE value[] = this.value;
		  final byte state[] = this.state;

		  int i = 0, j = count;

		  while(j-- != 0) {
				while(state[i] != OCCUPIED ) i++;
				if (VALUE_EQUAL(value[i], v)) return true;
				i++;
		  }
		  return false;
	 }


	 public void clear() {
		  this.count = 0;
		  Arrays.fill(state, FREE);
		  // We null all object entries so that the garbage collector can do its work.
#if #keyclass(Object)
		  Arrays.fill(key, null);
#endif
#if #valueclass(Object)
		  Arrays.fill(value, null);
#endif
	 }
    private static final class Entry implements MAP.Entry {
		  KEY_TYPE key;
		  VALUE_TYPE value;

		  Entry(Object key, Object value) {
				this.key = KEY2TYPE(key);
				this.value = VALUE2TYPE(value);
		  }

#if ! #keyclass(Object) || ! #valueclass(Object) 
		  
		  Entry(KEY_TYPE key, VALUE_TYPE value) {
				this.key = key;
				this.value = value;
		  }
		  
#endif

		  public Object getKey() {
				return KEY2OBJ(key);
		  }
		  
#if ! #keyclass(Object)
		  public KEY_TYPE ENTRY_GET_KEY() {
				return key;
		  }
#endif

		  public Object getValue() {
				return VALUE2OBJ(value);
		  }
		  
#if ! #valueclass(Object)
		  public VALUE_TYPE ENTRY_GET_VALUE() {
				return value;
		  }
#endif

		  public VALUE_TYPE setValue(final VALUE_TYPE value) {
				final VALUE_TYPE oldValue = this.value;
				this.value = value;
				return oldValue;
		  }
		  
#if ! #valueclass(Object)
		  
		  public Object setValue(final Object value) {
				return VALUE2OBJ(setValue(VALUE2TYPE(value)));
		  }

#endif


		  public boolean equals(Object o) {
				if (!(o instanceof Entry)) return false;
				Entry e = (Entry)o;
				
				return KEY_EQUAL(key, e.key) && VALUE_EQUAL(value, e.value);
		  }
		  
		  public int hashCode() {
				return KEY2INT(key) ^ VALUE2INT(value);
		  }
		  
		  
		  public String toString() {
				return key + "=" + value;
		  }
    }
	 

    public Set entrySet() {
		  if (entries == null) entries = new AbstractSet() {
					 
					 public Iterator iterator() {
						  return new Iterator() {
									 int pos = 0, last = -1, c = count;
						  
									 { 
										  final byte state[] = HASHMAP.this.state;
										  final int n = HASHMAP.this.n;

										  if (c != 0) while( pos < n && state[pos] != OCCUPIED ) pos++;
									 }
						  
									 public boolean hasNext() {
										  return c != 0 && pos < n;
									 }
						  
									 public Object next() {
										  Entry retVal;
										  final byte state[] = HASHMAP.this.state;
										  final int n = HASHMAP.this.n;
		  
										  if (!hasNext()) throw new NoSuchElementException();
										  retVal = new Entry(key[last = pos], value[pos]);
										  if (--c != 0) do pos++; while( pos < n && state[pos] != OCCUPIED );
								
										  return retVal;
									 }
						  
									 public void remove() {
										  if (last == -1) throw new IllegalStateException();
										  state[last] = REMOVED;
#if #keyclass(Object)
										  key[last] = HashCommon.removed;
#endif
#if #valueclass(Object)
										  value[last] = HashCommon.removed;
#endif

										  count--;
									 }
								};

					 }
					 
					 public boolean contains(Object o) {
						  if (!(o instanceof Map.Entry)) return false;
						  final Map.Entry e = (Map.Entry)o;
						  Object v = get(e.getKey());
						  return VALUE_EQUAL(v, e.getValue());
					 }
					 
					 public boolean remove(Object o) {
						  if (!(o instanceof Map.Entry)) return false;
						  final Map.Entry e = (Map.Entry)o;
						  Object v = get(e.getKey());
						  if ( VALUE_EQUAL(v, e.getValue()) ) return remove(e.getKey());
						  return false;
					 }
					 
					 public int size() {
						  return count;
					 }
					 
					 public void clear() {
						  HASHMAP.this.clear();
					 }
				};
	 
		  return entries;
	 }


    public Set keySet() {
		  if (keys == null) keys = new KEY_ABSTRACT_SET() {

					 public Iterator iterator() {
						  return new KEY_ITERATOR() {
									 int pos = 0, last = -1, c = count;
		  
									 { 
										  final byte state[] = HASHMAP.this.state;
										  final int n = HASHMAP.this.n;
										  
										  if (c != 0) while( pos < n && state[pos] != OCCUPIED ) pos++;
									 }
									 
									 public boolean hasNext() {
										  return c != 0 && pos < n;
									 }
									 
#if !#keyclass(Object)
									 public KEY_TYPE NEXT_KEY() {
										  KEY_TYPE retVal;
										  final byte state[] = HASHMAP.this.state;
										  final int n = HASHMAP.this.n;
										  
										  if (!hasNext()) throw new NoSuchElementException();
										  retVal = key[last = pos];
										  if (--c != 0) do pos++; while( pos < n && state[pos] != OCCUPIED );
										  
										  return retVal;
									 }

#endif									 

									 public Object next() {
										  Object retVal;
										  final byte state[] = HASHMAP.this.state;
										  final int n = HASHMAP.this.n;
										  
										  if (!hasNext()) throw new NoSuchElementException();
										  retVal = KEY2OBJ(key[last = pos]);
										  if (--c != 0) do pos++; while( pos < n && state[pos] != OCCUPIED );
										  
										  return retVal;
									 }
									 
									 public void remove() {
										  if (last == -1) throw new IllegalStateException();
										  state[last] = REMOVED;
#if #keyclass(Object)
										  key[last] = HashCommon.removed;
#endif
#if #valueclass(Object)
										  value[last] = HashCommon.removed;
#endif

										  count--;
									 }
								};
					 }

					 public int size() {
						  return count;
					 }


#if ! #keyclass(Object)
					 public boolean contains(KEY_TYPE k) {
						  return containsKey(k);
					 }
					 
					 public boolean remove(KEY_TYPE k) {
						  int oldCount = count;
						  HASHMAP.this.remove(k);
						  return count != oldCount;
					 }
					 
#endif
					 public boolean contains(Object ok) {
						  return containsKey(ok);
					 }

					 public boolean remove(Object ok) {
						  int oldCount = count;
						  HASHMAP.this.remove(ok);
						  return count != oldCount;
					 }

					 public void clear() {
						  HASHMAP.this.clear();
					 }
				};
		  return keys;
    }


    public Collection values() {
		  if (values == null) values = new VALUE_ABSTRACT_COLLECTION() {

					 public Iterator iterator() {
						  return new VALUE_ITERATOR() {
									 int pos = 0, last = -1, c = count;
									 
									 { 
										  final byte state[] = HASHMAP.this.state;
										  final int n = HASHMAP.this.n;
										  
										  if (c != 0) while( pos < n && state[pos] != OCCUPIED ) pos++;
									 }
		  
									 public boolean hasNext() {
										  return c != 0 && pos < n;
									 }
		  
#if !#valueclass(Object)
									 public VALUE_TYPE NEXT_VALUE() {
										  VALUE_TYPE retVal;
										  final byte state[] = HASHMAP.this.state;
										  final int n = HASHMAP.this.n;
		  
										  if (!hasNext()) throw new NoSuchElementException();
										  retVal = value[pos];
										  if (--c != 0) do pos++; while( pos < n && state[pos] != OCCUPIED );

										  return retVal;
									 }
#endif
		  
									 public Object next() {
										  Object retVal;
										  final byte state[] = HASHMAP.this.state;
										  final int n = HASHMAP.this.n;
		  
										  if (!hasNext()) throw new NoSuchElementException();
										  retVal = VALUE2OBJ(value[pos]);
										  if (--c != 0) do pos++; while( pos < n && state[pos] != OCCUPIED );

										  return retVal;
									 }
		  
									 public void remove() {
										  throw new UnsupportedOperationException();
									 }
								};
					 }

					 public int size() {
						  return count;
					 }

					 public boolean contains(Object ok) {
						  return containsValue(ok);
					 }

#if ! #valueclass(Object)
					 public boolean contains(VALUE_TYPE v) {
						  return containsValue(v);
					 }
#endif

					 public void clear() {
						  HASHMAP.this.clear();
					 }
				};

		  return values;
    }


	 /** Rehashes the map, keeping the same size.
	  * This method should be called when the map underwent numerous deletions and insertions.
	  * In this case, free entries become rare, and unsuccessful searches
	  * require probing <em>all</em> entries. For reasonable load factors this method is linear in the number of entries.
	  * You will need as much additional free memory as
	  * that occupied by the table.
	  * @return <code>true</code> if there was enough memory to rehash the map, <code>false</code> otherwise.
	  */

	 public boolean rehash() {
		  try {
				rehash(p);
		  }
		  catch(OutOfMemoryError cantDoIt) { return false; }
		  return true;
	 }


	 /** Resizes the map.
	  * @param newP the new size as an index in {@link Hash#primes}.
	  */

	 private void rehash( final int newP ) {
		  int i = 0, j = count, k2i, h1, h2;

		  KEY_TYPE k;
		  VALUE_TYPE v;

		  final int newN = primes[newP];
		  final KEY_TYPE key[] = this.key, newKey[] = new KEY_TYPE[newN];
		  final VALUE_TYPE value[] = this.value, newValue[] = new VALUE_TYPE[newN];
		  final byte state[] = this.state, newState[] = new byte[newN];

		  while(j-- != 0) {

				while(state[i] != OCCUPIED ) i++;

				k = key[i];
				v = value[i];
				k2i = KEY2INT(k) & 0x7FFFFFFF;

				h1 = k2i % newN;
				h2 = (k2i % (newN - 2)) + 1;

				while( newState[h1] != FREE ) h1 = ( h1 + h2 ) % newN;
				
				newState[h1] = OCCUPIED;
				newKey[h1] = k;
				newValue[h1] = v;
				i++;
		  }

		  this.n = newN;
		  this.p = newP;
		  this.key = newKey;
		  this.value = newValue;
		  this.state = newState;
	 }
	 
	 public boolean containsKey(KEY_TYPE k) {
		  return findKey(k, key, state) >= 0;
	 }
	 
	 public int size() {
		  return count;
	 }

	 public boolean isEmpty() {
		  return count == 0;
	 }


	 public Object get(final Object ok) {
		  final int i = findKey(KEY2TYPE(ok), key, state);

		  return i < 0 ? null : VALUE2OBJ(value[i]);
	 }


#if !#keyclass(Object)

	 public VALUE_TYPE get(final KEY_TYPE k) {
		  final int i = findKey(k, key, state);

		  return i < 0 ? DEF_RET_VALUE : value[i];
	 }

	 public VALUE_TYPE remove(final KEY_TYPE k) {
		  final byte state[] = this.state;

		  final int i = findKey(k, key, state);
		  if (i < 0) return DEF_RET_VALUE;

		  state[i] = REMOVED;

#if #valueclass(Object)
		  final Object v = value[i];
		  value[i] = HashCommon.removed;
#endif

		  count--;

#if #valueclass(Object)
		  return v;
#else
		  return value[i];
#endif
	 }
	 

	 public boolean containsKey(final Object ok) {
		  return findKey(KEY2TYPE(ok), key, state) >= 0;
	 }

#else
#if !#valueclass(Object)

	 public VALUE_TYPE GET_VALUE(final Object k) {
		  final int i = findKey(k, key, state);

		  return i < 0 ? DEF_RET_VALUE : value[i];
	 }

	 public VALUE_TYPE REMOVE_VALUE(final Object ok) {
		  final byte state[] = this.state;

		  final int i = findKey(KEY2TYPE(ok), key, state);
		  if (i < 0) return DEF_RET_VALUE;

		  state[i] = REMOVED;

#if #keyclass(Object)
		  key[i] = HashCommon.removed;
#endif

		  count--;
		  return value[i];
	 }
	 
#endif
#endif

	 /** Returns a deep copy of the map. 
	  *  @return a deep copy of the map.
	  */

	 public Object clone() {
		  HASHMAP c;
		  try {
				c = (HASHMAP)super.clone();
		  }
		  catch(CloneNotSupportedException cantHappen) {
				throw new InternalError();
		  }
		  c.key = (KEY_TYPE[])key.clone();
		  c.value = (VALUE_TYPE[])value.clone();
		  c.state = (byte[])state.clone();
		  return c;
	 }


	 /** Returns a hash code for this map.
	  *
	  * This method overrides the generic method provided by the superclass. 
	  * Since <code>equals()</code> is not overriden, it is important
	  * that the value returned by this method is the same value as
	  * the one returned by the overriden method.
	  *
	  * @return a hash code for this map.
	  */

	 public int hashCode() {
		  int h = 0, i = 0, j = count;
		  while(j-- != 0) {
				while(state[i] != OCCUPIED ) i++;
#if #keyclass(Object)
				if (this != key[i])
#endif
				h += KEY2INT(key[i]);
#if #valueclass(Object)
				if (this != value[i])
#endif
				h += VALUE2INT(value[i]);
				i++;
		  }
		  return h;
	 }



    private void writeObject(java.io.ObjectOutputStream s) throws IOException {
		  final KEY_TYPE key[] = this.key;
		  final VALUE_TYPE value[] = this.value;
		  final byte state[] = this.state;
		  int i = 0, j = count;

		  s.defaultWriteObject();

		  while(j-- != 0) {
				while(state[i] != OCCUPIED ) i++;
				s.WRITE_KEY(key[i]);
				s.WRITE_VALUE(value[i]);
				i++;
		  }
    }

    private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
		  KEY_TYPE key;
		  VALUE_TYPE value;

		  s.defaultReadObject();
		  this.n = primes[p];

		  this.key = new KEY_TYPE[n];
		  this.value = new VALUE_TYPE[n];
		  this.state = new byte[n];

		  int count = this.count;
		  this.count = 0;

		  while(count-- != 0) put(s.READ_KEY(), s.READ_VALUE());
    }

#ifndef NDEBUG

	 private static void speedTest( int n, float f ) {
		  int i;
		  MAP m;
		  Map t;
		  Random r = new Random();
		  Object o;
		  long v, fm, ct;

		  for(int k=0; k<10; k++) {

				if (k>0) System.out.println();

				t = new HashMap(n);
				m = new HASHMAP(n, f);
				/* First of all, we measure the time that is necessary to produce the inputs. */
		  
				v = System.currentTimeMillis();
		  
				for( i=0; i<n;  i++ ) {
				
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 new KEY_CLASS((KEY_TYPE)(r.nextInt())) 
#elif ! #keyclass(Object)
						  new KEY_CLASS(r.NEXT_KEY()) 
#else
						  new Long(r.nextLong()) 
#endif
						  ;
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
					 new VALUE_CLASS((VALUE_TYPE)(r.nextInt())) 
#elif ! #valueclass(Object)
						  new VALUE_CLASS(r.NEXT_VALUE()) 
#else
						  new Long(r.nextLong()) 
#endif
						  ;
				}
		  
				ct = System.currentTimeMillis() - v;
		  
				v = System.currentTimeMillis();
		  

				/* Then we add pairs to t. */

				for( i=0; i<n;  i++ ) {
					 t.put( 
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
							 new KEY_CLASS((KEY_TYPE)(r.nextInt())) 
#elif ! #keyclass(Object)
							 new KEY_CLASS(r.NEXT_KEY()) 
#else
							 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong()) 
#endif
							 ,
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
							 new VALUE_CLASS((VALUE_TYPE)(r.nextInt())) 
#elif ! #valueclass(Object)
							 new VALUE_CLASS(r.NEXT_VALUE()) 
#else
							 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong()) 
#endif
							 
							 );
				}

				System.out.println("Added "+n+" pairs in old HashMap (actual size: " + t.size() + ") in "+((System.currentTimeMillis() - v)) / 1000.0+"s" + 
										 " (actual time: "+((System.currentTimeMillis() - v - ct)) / 1000.0+"s)" );

				v = System.currentTimeMillis();

				/* Then we check for pairs in t. */

				for( i=0; i<n;  i++ ) {
					 t.get( 
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
							 new KEY_CLASS((KEY_TYPE)(r.nextInt())) 
#elif ! #keyclass(Object)
							 new KEY_CLASS(r.NEXT_KEY())
#else
							 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
							 );
				}

				System.out.println("Examined "+n+" pairs in old HashMap in "+((System.currentTimeMillis() - v)) / 1000.0+"s"+
										 " (actual time: "+((System.currentTimeMillis() - v - ct)) / 1000.0+"s)" );

				v = System.currentTimeMillis();

				/* Again, we measure the time that is necessary to produce the inputs. */
		  
				v = System.currentTimeMillis();
		  
				for( i=0; i<n;  i++ ) {
				
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 r.nextLong()
#endif
						  ;
				}
		  
				ct = System.currentTimeMillis() - v;
		  
				v = System.currentTimeMillis();

				/* Then we add pairs to m. */

				for( i=0; i<n;  i++ ) {
					 m.put( 
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
							 new KEY_CLASS((KEY_TYPE)(r.nextInt())) 
#elif ! #keyclass(Object)
							 new KEY_CLASS(r.NEXT_KEY()) 
#else
							 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong()) 
#endif
							 ,
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
							 new VALUE_CLASS((VALUE_TYPE)(r.nextInt())) 
#elif ! #valueclass(Object)
							 new VALUE_CLASS(r.NEXT_VALUE()) 
#else
							 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong()) 
#endif
							 );
				}
		  
				System.out.println("Added "+n+" pairs in new HashMap (actual size: " + m.size() + ") in "+((System.currentTimeMillis() - v)) / 1000.0+"s"+
										 " (actual time: "+((System.currentTimeMillis() - v - ct)) / 1000.0+"s)" );

				v = System.currentTimeMillis();

				/* Then we check for pairs in m. */

				for( i=0; i<n;  i++ ) {
					 m.get( 
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
							 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
							 r.NEXT_KEY()
#else
							 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
							 );
				}
				
				System.out.println("Examined "+n+" pairs in new HashMap in "+((System.currentTimeMillis() - v)) / 1000.0+"s" +
										 " (actual time: "+((System.currentTimeMillis() - v - ct)) / 1000.0+"s)" );
			
				
				/* Then we enumerate items in t. */
				v = System.currentTimeMillis();

				for(Iterator it=t.keySet().iterator(); it.hasNext(); ) t.get(it.next());
				
				System.out.println("Iterated on old HashMap in "+((System.currentTimeMillis() - v)) / 1000.0+"s");
	 

				/* Then we enumerate items in m. */
				v = System.currentTimeMillis();

				for(KEY_ITERATOR it=(KEY_ITERATOR)m.keySet().iterator(); it.hasNext(); ) m.get(it.NEXT_KEY());

				System.out.println("Iterated on new HashMap in "+((System.currentTimeMillis() - v)) / 1000.0+"s");
	 
		  }


	 }


	 private static boolean valEquals(Object o1, Object o2) {
		  return o1 == null ? o2 == null : o1.equals(o2);
	 }


	 private static void regressionTest( int n, float f ) {
		  HASHMAP m = new HASHMAP(Hash.DEFAULT_INITIAL_SIZE, f);
		  Map t = new HashMap();
		  Random r = new Random();

		  /* First of all, we fill t with random data. */

		  for(int i=0; i<n;  i++ ) {
				t.put( 
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
						new KEY_CLASS((KEY_TYPE)(r.nextInt())) 
#elif ! #keyclass(Object)
						new KEY_CLASS(r.NEXT_KEY()) 
#else
						r.nextInt() % 100 == 0 ? null : new Long(r.nextLong()) 
#endif
						,
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
						new VALUE_CLASS((VALUE_TYPE)(r.nextInt())) 
#elif ! #valueclass(Object)
						new VALUE_CLASS(r.NEXT_VALUE()) 
#else
						r.nextInt() % 100 == 0 ? null : new Long(r.nextLong()) 
#endif
						);
		  }
		  
		  /* Now we add to m the same data */
		  
		  m.putAll(t);

		  if (!m.equals(t)) System.out.println("Error: !m.equals(t) after insertion.\n");
		  if (!t.equals(m)) System.out.println("Error: !t.equals(m) after insertion.\n");

		  /* Now we check that m actually holds that data. */
		  
		  for(Iterator i=t.entrySet().iterator(); i.hasNext();  ) {
				java.util.Map.Entry e = (java.util.Map.Entry)i.next();
		      if (!valEquals(e.getValue(), m.get(e.getKey()))) 
					 System.out.println("Error: m and t differ on an entry ("+e+") after insertion (iterating on t).\n");
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  
		  for(Iterator i=m.entrySet().iterator(); i.hasNext();  ) {
				Entry e = (Entry)i.next();
		      if (!valEquals(e.getValue(), t.get(e.getKey()))) 
					 System.out.println("Error: m and t differ on an entry ("+e+") after insertion (iterating on m).\n");
		  }

		  /* Now we check that m actually holds the same keys. */
		  
		  for(Iterator i=t.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!m.containsKey(o)) {
					 System.out.println("Error: m and t differ on a key ("+o+") after insertion (iterating on t).\n");
					 System.exit(-1);
				}
		      if (!m.keySet().contains(o)) {
					 System.out.println("Error: m and t differ on a key ("+o+", in keySet()) after insertion (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually holds the same keys, but iterating on m. */
		  
		  for(Iterator i=m.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!t.containsKey(o)) {
					 System.out.println("Error: m and t differ on a key after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		      if (!t.keySet().contains(o)) {
					 System.out.println("Error: m and t differ on a key (in keySet()) after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		  }


		  /* Now we check that m actually hold the same values. */
		  
		  for(Iterator i=t.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!m.containsValue(o)) {
					 System.out.println("Error: m and t differ on a value after insertion (iterating on t).\n");
					 System.exit(-1);
				}
		      if (!m.values().contains(o)) {
					 System.out.println("Error: m and t differ on a value (in values()) after insertion (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually hold the same values, but iterating on m. */
		  
		  for(Iterator i=m.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!t.containsValue(o)) {
					 System.out.println("Error: m and t differ on a value after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		      if (!t.values().contains(o)) {
					 System.out.println("Error: m and t differ on a value (in values()) after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that inquiries about random data give the same answer in m and t. For
			  m we use the polymorphic method. */

		  for(int i=0; i<n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
					 ;

				if (m.containsKey(KEY2OBJ(T)) != t.containsKey(KEY2OBJ(T))) {
					 System.out.println("Error: divergence in keys between t and m (polymorphic method).\n");
					 System.exit(-1);
				}

#if #keyclass(Object) && ! #valueclass(Object)
				if ((m.GET_VALUE(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) || 
					 t.get(KEY2OBJ(T)) != null && 
					 ! VALUE2OBJ(m.GET_VALUE(T)).equals(t.get(KEY2OBJ(T)))) 
#else
					 if ((m.get(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) || 
						  t.get(KEY2OBJ(T)) != null && 
						  ! m.get(KEY2OBJ(T)).equals(t.get(KEY2OBJ(T)))) 
#endif
						  {
								System.out.println("Error: divergence between t and m (polymorphic method).\n");
								System.exit(-1);
						  }
		  }

		  /* Again, we check that inquiries about random data give the same answer in m and t, but
			  for m we use the standard method. */

		  for(int i=0; i<n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
					 ;
				if (!valEquals(m.get(KEY2OBJ(T)), t.get(KEY2OBJ(T)))) {
					 System.out.println("Error: divergence between t and m (standard method).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we put and remove random data in m and t, checking that the result is the same. */

		  for(int i=0; i<20*n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
					 ;
				VALUE_TYPE U =
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
					 (VALUE_TYPE)r.nextInt()
#elif ! #valueclass(Object)
					 r.NEXT_VALUE()
#else
					 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
					 ;
				if (!valEquals(m.put(KEY2OBJ(T), VALUE2OBJ(U)), t.put(KEY2OBJ(T), VALUE2OBJ(U)))) {
					 System.out.println("Error: divergence in put() between t and m.\n");
					 System.exit(-1);
				}
				T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
					 ;
				if (!valEquals(m.remove(KEY2OBJ(T)), t.remove(KEY2OBJ(T)))) {
					 System.out.println("Error: divergence in remove() between t and m.\n");
					 System.exit(-1);
				}
		  }

		  if (!m.equals(t)) System.out.println("Error: !m.equals(t) after removal.\n");
		  if (!t.equals(m)) System.out.println("Error: !t.equals(m) after removal.\n");


		  /* Now we check that m actually holds the same data. */
		  
		  for(Iterator i=t.entrySet().iterator(); i.hasNext();  ) {
				java.util.Map.Entry e = (java.util.Map.Entry)i.next();
		      if (!valEquals(e.getValue(), m.get(e.getKey()))) {
					 System.out.println("Error: m and t differ on an entry ("+e+") after removal (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  
		  for(Iterator i=m.entrySet().iterator(); i.hasNext();  ) {
				Entry e = (Entry)i.next();
		      if (!valEquals(e.getValue(), t.get(e.getKey()))) {
					 System.out.println("Error: m and t differ on an entry ("+e+") after removal (iterating on m).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually holds the same keys. */
		  
		  for(Iterator i=t.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!m.containsKey(o)) {
					 System.out.println("Error: m and t differ on a key ("+o+") after removal (iterating on t).\n");
					 System.exit(-1);
				}
		      if (!m.keySet().contains(o)) {
					 System.out.println("Error: m and t differ on a key ("+o+", in keySet()) after removal (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually holds the same keys, but iterating on m. */
		  
		  for(Iterator i=m.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!t.containsKey(o)) {
					 System.out.println("Error: m and t differ on a key after removal (iterating on m).\n");
					 System.exit(-1);
				}
		      if (!t.keySet().contains(o)) {
					 System.out.println("Error: m and t differ on a key (in keySet()) after removal (iterating on m).\n");
					 System.exit(-1);
				}
		  }


		  /* Now we check that m actually hold the same values. */
		  
		  for(Iterator i=t.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!m.containsValue(o)) {
					 System.out.println("Error: m and t differ on a value after removal (iterating on t).\n");
					 System.exit(-1);
				}
		      if (!m.values().contains(o)) {
					 System.out.println("Error: m and t differ on a value (in values()) after removal (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually hold the same values, but iterating on m. */
		  
		  for(Iterator i=m.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!t.containsValue(o)) {
					 System.out.println("Error: m and t differ on a value after removal (iterating on m).\n");
					 System.exit(-1);
				}
		      if (!t.values().contains(o)) {
					 System.out.println("Error: m and t differ on a value (in values()) after removal (iterating on m).\n");
					 System.exit(-1);
				}
		  }


		  int h = m.hashCode();


		  /* Now we save and read m. */

		  try {
				java.io.File ff = new java.io.File("regressionTest");
				java.io.OutputStream os = new java.io.FileOutputStream(ff);
				java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);
				
				oos.writeObject(m);
				oos.close();
				
				java.io.InputStream is = new java.io.FileInputStream(ff);
				java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);
				
				m = (HASHMAP)ois.readObject();
				ois.close();
				ff.delete();
		  }
		  catch(Exception e) {
				e.printStackTrace();
				System.exit(-1);
		  }

		  if (m.hashCode() != h) System.out.println("Error: hashCode() changed after save/read.\n");

		  /* Now we check that m actually holds that data. */
		  
		  for(Iterator i=t.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!valEquals(m.get(o),t.get(o))) {
					 System.out.println("Error: m and t differ on an entry after save/read.\n");
					 System.exit(-1);
				}
		  }

		  /* Now we take out of m everything, and check that it is empty. */

		  for(Iterator i=t.keySet().iterator(); i.hasNext(); ) m.remove(i.next()); 

		  if (!m.isEmpty())  {
				System.out.println("Error: m is not empty (as it should be).\n");
				System.exit(-1);
		  }

#if (#keyclass(Integer) || #keyclass(Long)) && (#valueclass(Integer) || #valueclass(Long))
		  m = new HASHMAP(n, f);
		  t.clear();
		  int x;

		  /* Now we torture-test the hash table. This part is implemented only for integers and longs. */

		  int p = m.n;

		  for(int i=0; i<p; i++) {
				for (int j=0; j<20; j++) {
					 m.put(i+(r.nextInt() % 10)*p, 1);
					 m.remove(i+(r.nextInt() % 10)*p);
				}

				for (int j=-10; j<10; j++) m.remove(i+j*p);
		  }
		  
		  t.putAll(m);

		  /* Now all table entries are REMOVED. */

		  for(int i=0; i<(p*f)/10; i++) {
				for (int j=0; j<10; j++) {
					 if (!valEquals(m.put(KEY2OBJ(x = i+(r.nextInt() % 10)*p), VALUE2OBJ(1)), t.put(KEY2OBJ(x), VALUE2OBJ(1))))
						  System.out.println("Error: m and t differ on an entry during torture-test insertion.");
				}
		  }

		  if (!m.equals(t)) System.out.println("Error: !m.equals(t) after torture-test insertion.\n");
		  if (!t.equals(m)) System.out.println("Error: !t.equals(m) after torture-test insertion.\n");

		  for(int i=0; i<p/10; i++) {
				for (int j=0; j<10; j++) {
					 if (!valEquals(m.remove(KEY2OBJ(x = i+(r.nextInt() % 10)*p)), t.remove(KEY2OBJ(x))))
						  System.out.println("Error: m and t differ on an entry during torture-test removal.");
				}
		  }

		  if (!m.equals(t)) System.out.println("Error: !m.equals(t) after torture-test removal.\n");
		  if (!t.equals(m)) System.out.println("Error: !t.equals(m) after torture-test removal.\n");

		  if (!m.equals(m.clone())) System.out.println("Error: !m.equals(m.clone()) after torture-test removal.\n");
		  if (!((HASHMAP)m.clone()).equals(m)) System.out.println("Error: !m.clone().equals(m) after torture-test removal.\n");

		  m.rehash();

		  if (!m.equals(t)) System.out.println("Error: !m.equals(t) after rehash().\n");
		  if (!t.equals(m)) System.out.println("Error: !t.equals(m) after rehash().\n");
#endif

		  System.out.println("Regression test OK.\n");
		  System.exit(0);
	 }


	 public static void main( String args[] ) {
		  float f = Hash.DEFAULT_LOAD_FACTOR;
		  int n  = Integer.parseInt(args[1]);
		  if (args.length>2) f = Float.parseFloat(args[2]);
		  
		  if (args[0].equals("speedTest")) speedTest(n, f);
		  else if (args[0].equals("regressionTest")) regressionTest(n, f);
	 }

#endif

}

// Local Variables:
// mode: jde
// End:
