/*		 
 * fastUtil 2.0: Fast & compact specialized utility classes for Java
 *
 * Copyright (C) 2002 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package it.unimi.dsi.fastUtil;

import java.util.*;
import java.io.*;

/** A type-specific tree map with a fast, small-footprint implementation.
 */

public final class TREEMAP extends ABSTRACT_MAP implements Serializable, SORTEDMAP {

	 /** A reference to the root entry. */
	 public transient Entry tree;

	 /** Number of entries in the map. */
	 private int count;

	 /** The first key in this map. */
	 private transient Entry firstEntry;

	 /** The last key in this map. */
	 private transient Entry lastEntry;

	 /** Cached set of entries and keys. */
	 private transient volatile Set entries, keys;

	 /** Cached collection of values. */
	 private transient volatile Collection values;

	 /** Temporary place to keep a key during recursive operations. */
	 private transient KEY_TYPE key;

	 /** Temporary place to keep a value during recursive operations. */
	 private transient VALUE_TYPE value;

	 /** The value of this variable remembers, after an <code>insert()</code> 
	  * or a <code>delete()</code>, whether the <em>domain</em> of the map
	  * has been modified. */
	 private transient boolean modified;

	 /** The value of this variable remembers, after an <code>insert()</code> 
	  * or a <code>delete()</code>, the entry that during the operation we
	  * possibly created or removed. */
	 private transient Entry change;

	 /** The value of this variable remembers, after a <code>delete()</code>,
	  * the entry that during the operation was deleted. Note that 
	  * if {@link #change} != {@link deleted}, then this entry is still in the
	  * map, but it contains the key and value previously stored in {@link #change}. */
	 private transient Entry deleted;

	 /** This variable is used by <code>insert()</code> 
	  * and <code>delete()</code> to remember temporarily the value previously 
	  * associated to the current {@link #key}, if any. */
	 private transient VALUE_TYPE oldValue;

	 /** This map's comparator, as provided in the constructor. */
	 private Comparator storedComparator;

	 /** This map's actual comparator; it may differ from {@link #storedComparator} because it is
		  always a type-specific comparator, so it could be derived from the former by wrapping. */
	 private transient KEY_COMPARATOR actualComparator;


	 /** Creates a new empty tree map. 
	  */

	 public TREEMAP() {
		  tree = null;
		  count = 0;
	 }

	 /** Generates the comparator that will be actually used.
	  *
	  * <P>When a specific {@link Comparator} is specified and stored in {@link
	  * #storedComparator}, we must check whether it is type-specific.  If it is
	  * so, we can used directly, and we store it in {@link #actualComparator}. Otherwise,
	  * we generate on-the-fly an anonymous class that wraps the non-specific {@link Comparator}
	  * and makes it into a type-specific one.
	  */
	 private void setActualComparator() {
#if #keyclass(Object)
		  actualComparator = storedComparator;
#else
		  /* If the provided comparator is already type-specific, we use it. Otherwise,
			  we use a wrapper anonymous class to fake that it is type-specific. */
		  if ( storedComparator == null || storedComparator instanceof KEY_COMPARATOR ) actualComparator = (KEY_COMPARATOR)storedComparator;
		  else actualComparator =	new KEY_COMPARATOR() {
				public int compare( KEY_TYPE k1, KEY_TYPE k2 ) {
					 return storedComparator.compare( KEY2OBJ( k1 ), KEY2OBJ( k2 ) );
				}
				public int compare( Object ok1, Object ok2 ) {
					 return storedComparator.compare( ok1, ok2 );
				}
		  };
#endif
	 }
	 

	 /** Creates a new empty tree map with the given comparator.
	  *
	  * @param comparator a {@link #Comparator}.
	  */

	 public TREEMAP( final Comparator c ) {
		  this();
		  storedComparator = c;
		  setActualComparator();
	 }


	 /** Creates a new tree map copying a given map.
	  *
	  * @param m a {@link Map} to be copied into the new tree map. 
	  */
	 
	 public TREEMAP( Map m ) {
		  this();
		  putAll( m );
	 }

	 /** Creates a new tree map copying a given sorted map (and its {@link Comparator}).
	  *
	  * @param m a {@link SortedMap} to be copied into the new tree map. 
	  */
	 
	 public TREEMAP( SortedMap m ) {
		  this( m.comparator() );
		  putAll( m );
	 }


	 /*
	  * The following private methods implements some basic building blocks used by
	  * all accessors.  They are (and should be maintained) identical to those used in TreeSet.drv.
	  */


	 /** Compares two keys in the right way. 
	  *
	  * <P>This method uses the {@link #actualComparator} if it is non-<code>null</code>.
	  * Otherwise, it resorts to primitive type comparisons or to {@link Comparable#compareTo(Object)}.
	  *
	  * @param k1 the first key.
	  * @param k2 the second key.
	  * @return a number smaller than, equal to or greater than 0, as usual
	  * (i.e., when k1 &lt; k2, k1 = k2 or k1 &gt; k2, respectively).
	  */
	 
	 private int compare( KEY_TYPE k1, KEY_TYPE k2 ) {
		  return actualComparator == null ? KEY_CMP( k1, k2 ) : actualComparator.compare( k1, k2 );
    }



	 /** Returns the entry corresponding to the given key, if it is in the tree; <code>null</code>, otherwise.
	  *
	  * @param k the key to search for.
	  * @return the corresponding entry, or <code>null</code> if no entry with the given key exists.
	  */

   private Entry findKey( KEY_TYPE k ) {
		 Entry e = tree;
		 int cmp;
		 
		 while ( e != null && ( cmp = compare( k, e.key ) ) != 0 ) 
			  e = cmp < 0 ? e.left() : e.right();
		 
		 return e;
   }

	 /** The value of this variable remembers during an <code>insert()</code> 
	  * whether we ever turned left. */
	 private transient boolean turnedLeft;

	 /** The value of this variable remembers during an <code>insert()</code> 
	  * whether we ever turned right. */
	 private transient boolean turnedRight;


	 /** Inserts a new pair in the map.
	  *
	  * <P>After execution of this method, {@link #modified} is true iff a new
	  * entry has been inserted.
	  *
	  * @param k a key.
	  * @param v a value.
	  * @return the previous value associated to the key (or the default return value, if there 
	  * was no existing entry with the same key).
	  */

	 
	 private VALUE_TYPE insert( final KEY_TYPE k, final VALUE_TYPE v ) {
		  oldValue = defRetValue; // This will hold the old value.
		  modified = turnedLeft = turnedRight = false;
		  key = k;
		  value = v;

		  if ( tree == null ) { // The case of the empty tree is treated separately.
				count++;
				tree = lastEntry = firstEntry = new Entry( k, v );
				modified = true;
		  }
		  else tree = insertRec( tree );

#if #keyclass(Object)
		  key = null;
#endif

#if #valueclass(Object)
		  value = null;
		  final VALUE_TYPE retValue = oldValue;
		  oldValue = VALUE_NULL;
		  return retValue;
#else
		  return oldValue;
#endif

	 }


	 /** Inserts recursively a given pair in a nonempty tree.
	  *
	  * <P>After execution of this method, {@link #modified} is true iff
	  * a new entry has been inserted. Otherwise, {@link #oldValue} contains the value previously
	  * associated with the key. Moreover, {@link #turnedRight} if true iff we
	  * turned right during the search; analogously for {@link #turnedLeft}.
	  *
	  * @param e a tree (i.e., an {@link Entry}).
	  * @return the new tree, that is, the {@link Entry} that is now at the top of the tree.
	  */

   private Entry insertRec( Entry e ) {

		 final int cmp = compare( key, e.key );
		 
		 if ( cmp < 0 ) {
			  turnedLeft = true;
			  if ( e.left() != null ) e.left = insertRec( e.left );
			  else {
					/* <P>This method we create a new {@link Entry} (marked as a leaf) and
					 * link it at the left of <code>e</code>. The {@link Entry#right} pointer
					 * of the new entry is <code>e</code>, whereas its {@link Entry#left} pointer
					 * is the {@link Entry#left} pointer of <code>e</code>. */
					count++;
					final Entry l = new Entry( key, value );
					
					modified = true;
					if ( ! turnedRight ) firstEntry = l;

					l.right = e;
					l.left = e.left;
					
					e.pred( false );
					e.left = l;
			  }
		 } 
		 else if ( cmp > 0 ) {
			  turnedRight = true;
			  if ( e.right() != null ) e.right = insertRec( e.right );
			  else {
					/* <P>We create a new {@link Entry} (marked as a leaf) and
					 * link it at the right of <code>e</code>. The {@link Entry#left} pointer
					 * of the new entry is <code>e</code>, whereas its {@link Entry#right} pointer
					 * is the {@link Entry#right} pointer of <code>e</code>. */
					count++;
					final Entry r = change = new Entry( key, value );
					
					modified = true;
					if ( ! turnedLeft ) lastEntry = r;

					r.left = e;
					r.right = e.right;
					
					e.succ( false );
					e.right = r;
			  }
		 }
		 else {
			  oldValue = e.value;
			  e.value = value;
			  return e;
		 }

		 if ( modified ) {
			  e = e.skew();
			  e = e.split();
		 }

		 return e;
   }
	 
	 
	 /** Deletes an entry from the map.
	  *
	  * <P>After execution of this method, {@link #modified} is true iff an 
	  * entry has been deleted. In this case, {@link #deleted} is the entry that contained
	  * the deleted key and {@link #change} is the entry actually removed from the tree.
	  *
	  * <P>Note that if values are not primitive it is a good idea to clear the
	  * content {@link #change} and {@link #deleted} after calling this method.
	  *
	  * @param k a key.
	  * @return the value previously associated to the key (or the default return value, if there 
	  * was no existing entry with the given key).
	  */
	 
	 private VALUE_TYPE delete( final KEY_TYPE k ) {
		  oldValue = defRetValue;
		  change = deleted = null;
		  modified = false;
		  key = k;

		  if ( tree == null ) return defRetValue;

		  tree = deleteRec( null, tree );

#if #keyclass(Object)
		  key = null;
#endif

#if #valueclass(Object)
		  final VALUE_TYPE retValue = oldValue;
		  oldValue = VALUE_NULL;
		  return retValue;
#else
		  return oldValue;
#endif
	 }

	 /** Deletes recursively an entry from a tree.
	  *
	  * <P>After execution of this method, {@link #modified} is true iff an 
	  * entry has been deleted. In this case, {@link #oldValue} contains the value
	  * previously associated with the key, {@link #deleted} is the entry that contained
	  * the deleted key and {@link #change} is the entry actually removed from the tree.
	  *
	  * @param p the parent of the second argument (i.e., an {@link Entry}.
	  * @param e a tree (i.e., an {@link Entry}.
	  * @return the new tree, that is, the {@link Entry} that is now at the top of the tree.
	  */

	 private Entry deleteRec( Entry p, Entry e ) {
		  change = e;

		  if ( compare( key, e.key ) < 0 ) {
				if ( e.left() != null ) e.left = deleteRec( e, e.left );
		  }
		  else  {
				deleted = e;
				if ( e.right() != null ) e.right = deleteRec( e, e.right );
		  }
				
		  if ( e == change && deleted != null && compare( key, deleted.key ) == 0 ) {

				oldValue = deleted.value;
				//System.err.println("Deleted entry is " + deleted + "; pred=" + deleted.pred() + "; succ="+ deleted.succ() + "; left=" + deleted.left + "; right=" + deleted.right );

				deleted.key = e.key;
				deleted.value = e.value;

				modified = true;
				count--;

				if ( p != null ) {
					 if ( p.right == e ) {
						  if ( e.succ() ) p.succ( true );  // This handles the case of e being a leaf to the right of p.
						  else if ( e.right.pred() ) e.right.left = p; // This handles the case of e being a right subtree and e.right a leaf.
					 }
					 else if ( e.right() != null && e.right.pred() ) e.right.left = e.left; // This handles the case of e being a left subtree of p with a right leaf.
				}

				// If we are deleting the first or last entry, we must update our state accordingly.
				if ( e.right == null ) lastEntry = e.left;
				if ( e.left == null ) firstEntry = e.right;

				/* If e is a leaf to the left of p, returning e.right would cause a
				loop. The right thing to do is to return e.left and set the
				predecessor flag in the parent. */

				if ( p != null && p.left == e && e.succ() ) {
					 p.pred( true );
					 return e.left;
				}

				return e.right;
		  }

		  if ( ! modified ) return e;

		  Entry l, r;
		  final int level = e.level();

		  if ( ( r = e.right() ) == null && level > 1 || r != null && r.level() < level - 1 || ( l = e.left() ) == null && level > 1 || l != null && l.level() < level - 1 ) {
				e.decLevel();
				if ( r != null && r.level() > e.level() ) r.level( e.level() );
				e = e.skew();
				if ( ( r = e.right() ) != null ) {
					 r = e.right = r.skew();
					 if ( r.right() != null ) r.right = r.right.skew();
				}
				e = e.split();
				if ( ( r = e.right() ) != null ) e.right = r.split();
		  }

		  return e;
	 }
	 

	 public Object put( final Object ok, final Object ov ) {
		  final VALUE_TYPE oldValue = insert( KEY2TYPE(ok), VALUE2TYPE(ov) );
		  return modified ? OBJDEFRETVALUE : VALUE2OBJ( oldValue );
	 }


#if ! ( #valueclass(Object) && #keyclass(Object) )
	 public VALUE_TYPE put(final KEY_TYPE k, final VALUE_TYPE v) {
		  return insert( k, v );
	 }
#endif

   public Object remove(final Object ok) {
		 final VALUE_TYPE oldValue = delete( KEY2TYPE( ok ) );
		 deleted = change = null;
		 return modified ? VALUE2OBJ( oldValue ) : OBJDEFRETVALUE;
   }

#if ! #valueclass(Object) 
	 
	 public boolean containsValue(final Object v) {
		  return containsValue( VALUE2TYPE( v ) );
	 }

#endif

	 public boolean containsValue(final VALUE_TYPE v) {
		  final TreeIterator i = new TreeIterator();
		  VALUE_TYPE ev;
		  
		  while( i.hasNext() ) {
				ev = ((Entry)i.next()).value;
				if ( VALUE_EQUAL( ev, v ) ) return true;
		  }
		  
		  return false;
	 }


	 public void clear() {
		  count = 0;
		  tree = null;
		  entries = null;
		  values = null;
		  keys = null;
		  firstEntry = lastEntry = null;
	 }

	 
	 /** This class represent an entry in a tree map.
	  *
	  * <P>We use the only "metadata", i.e., {@link Entry#mix}, to store
	  * information about level, predecessor status and successor status.
	  *
	  * <P>Note that since the class is recursive, it can be
	  * considered equivalently a tree.
	  */

    private static final class Entry implements MAP.Entry {
		  /** If the bit in this mask is true, {@link #right} points to a successor. */
		  private final static int SUCC_MASK = 1 << 31;
		  /** If the bit in this mask is true, {@link #left} points to a predecessor. */
		  private final static int PRED_MASK = 1 << 30;
		  /** The bits in this mask hold the node level. */
		  private final static int LEVEL_MASK = ~( SUCC_MASK | PRED_MASK );
		  /** The key of this entry. */
		  protected KEY_TYPE key;
		  /** The value of this entry. */
		  protected VALUE_TYPE value;
		  /** The pointers to the left and right subtrees. */
		  protected Entry left, right;
		  /** This integers holds different information in different bits (see {@link #SUCC_MASK}, {@link #PRED_MASK} and {@link #LEVEL_MASK}). */
		  private int mix;

		  /** Creates a new entry with no explicitly set key/value and <code>null</code> subtrees.
			*/

		  protected Entry() {}

		  /** Creates a new entry with the given key and value.
			*
			* @param k a key.
			* @param v a value.
			*/
		  protected Entry( Object k, Object v ) {
				this.key = KEY2TYPE( k );
				this.value = VALUE2TYPE( v );
				mix = 1 | SUCC_MASK | PRED_MASK;
		  }

#if ! #keyclass(Object) || ! #valueclass(Object) 
		  
		  /** Creates a new entry with the given key and value.
			*
			* @param k a key.
			* @param v a value.
			*/
		  protected Entry( KEY_TYPE k, VALUE_TYPE v ) {
				this.key = k;
				this.value = v;
				mix = 1 | SUCC_MASK | PRED_MASK;
		  }
		  
#endif

		  /** Returns the left subtree. 
			*
			* @return the left subtree (<code>null</code> if the left
			* subtree is empty).
			*/
		  protected Entry left() {
				return ( mix & PRED_MASK ) != 0 ? null : left;
		  }
		  
		  /** Returns the right subtree. 
			*
			* @return the right subtree (<code>null</code> if the right
			* subtree is empty).
			*/
		  protected Entry right() {
				return ( mix & SUCC_MASK ) != 0 ? null : right;
		  }
		  
		  /** Checks whether the left pointer is really a predecessor.
			* @return true if the left pointer is a predecessor.
			*/
		  protected boolean pred() {
				return ( mix & PRED_MASK ) != 0;
		  }
		  
		  /** Checks whether the right pointer is really a successor.
			* @return true if the right pointer is a successor.
			*/
		  protected boolean succ() {
				return ( mix & SUCC_MASK ) != 0;
		  }
		  
		  /** Sets whether the left pointer is really a predecessor.
			* @param pred if true then the left pointer will be considered a predecessor.
			*/
		  protected void pred( boolean pred ) {
				if ( pred ) mix |= PRED_MASK;
				else mix &= ~PRED_MASK;
		  }
		  
		  /** Sets whether the right pointer is really a successor.
			* @param succ if true then the right pointer will be considered a successor.
			*/
		  protected void succ( boolean succ ) {
				if ( succ ) mix |= SUCC_MASK;
				else mix &= ~SUCC_MASK;
		  }
		  
		  /** Returns the current level of the node.
			* @return the current level of this node.
			*/
		  protected int level() {
				return mix & LEVEL_MASK ;
		  }

		  /** Sets the level of this node.
			* @param level the new level of this node.
			*/
		  protected void level( int level ) {
				mix &= ~LEVEL_MASK;
				mix |= level;
		  }

		  /** Increments the level of this node. */
		  protected void incLevel() {
				mix++;
		  }
		  
		  /** Decrements the level of this node. */
		  protected	void decLevel() {
				mix--;
		  }
		  
		  public Object getKey() {
				return KEY2OBJ(key);
		  }
		  
#if ! #keyclass(Object)
		  public KEY_TYPE ENTRY_GET_KEY() {
				return key;
		  }
#endif
		  
		  public Object getValue() {
				return VALUE2OBJ(value);
		  }
		  
#if ! #valueclass(Object)
		  public VALUE_TYPE ENTRY_GET_VALUE() {
				return value;
		  }
#endif
		  
		  public VALUE_TYPE setValue(final VALUE_TYPE value) {
				final VALUE_TYPE oldValue = this.value;
				this.value = value;
				return oldValue;
		  }
		  
#if ! #valueclass(Object)
		  
		  public Object setValue(final Object value) {
				return VALUE2OBJ(setValue(VALUE2TYPE(value)));
		  }
		  
#endif
		  
		  public boolean equals(Object o) {
				if (!(o instanceof Entry)) return false;
				Entry e = (Entry)o;
				
				return KEY_EQUAL(key, e.key) && VALUE_EQUAL(value, e.value);
		  }
		  
		  public int hashCode() {
				return KEY2INT(key) ^ VALUE2INT(value);
		  }
		  
		  
		  public String toString() {
				return key + "=>" + value;
		  }
		  

		  /** Splits this subtree.
			* @return the new top of the subtree.
			*/
		  Entry split() {
				final Entry r;
				if ( ( r = right() ) != null && r.right() != null && r.right.level() == level() ) {
					 /* If our right subtree contains a predecessor, we set the
						 subtree as our successor. */
					 if ( ! r.pred() ) right = r.left;
					 
					 succ( r.pred() );
					 
					 r.left = this;
					 r.pred( false );
					 r.incLevel();
					 
					 return r;
				}
				return this;
		  }
		  
		  /** Skews this subtree.
			* @return the new top of the subtree.
			*/
		  Entry skew() {
				final Entry l;
				if ( ( l = left() ) != null && l.level() == level() ) {
					 /* If our left subtree contains a successor, we set the
						 subtree as our predecessor. */
					 if ( ! l.succ() ) left = l.right;
					 
					 pred( l.succ() );
					 
					 l.right = this;
					 l.succ( false );
					 
					 return l;
				}
				return this;
		  }

		  /*
		  public void prettyPrint() {
				prettyPrint(0);
		  }

		  public void prettyPrint(int level) {
				if ( pred() ) {
					 for (int i = 0; i < level; i++)
						  System.err.print("  ");
					 System.err.println("pred: " + left );
				}
				else if (left != null)
					 left.prettyPrint(level +1 );
				for (int i = 0; i < level; i++)
					 System.err.print("  ");
				System.err.println(key + "=" + value + " (" + level() + ")");
				if ( succ() ) {
					 for (int i = 0; i < level; i++)
						  System.err.print("  ");
					 System.err.println("succ: " + right );
				}
				else if (right != null)
					 right.prettyPrint(level + 1);
		  }
		  */
    }
	 
	 /*
		public void prettyPrint() {
      System.err.println("size: " + count);
      if (tree != null) tree.prettyPrint();
   }
	 */

	 public boolean containsKey( KEY_TYPE k ) {
		  return findKey( k ) != null;
	 }
	 
	 public int size() {
		  return count;
	 }
	 
	 public boolean isEmpty() {
		  return count == 0;
	 }
	 
	 
	 public Object get( final Object ok ) {
		  final Entry e = findKey( KEY2TYPE( ok ) );
		  return e == null ? OBJDEFRETVALUE : e.getValue();
	 }
	 

#if !#keyclass(Object)

	 public VALUE_TYPE get(final KEY_TYPE k) {
		  final Entry e = findKey( k );
		  return e == null ? defRetValue : e.value;
	 }

	 public VALUE_TYPE remove(final KEY_TYPE k) {
		  final VALUE_TYPE oldValue = delete( k );
		  change = deleted = null;
		  return oldValue;
	 }
	 
	 public boolean containsKey(final Object ok) {
		  return containsKey( KEY2TYPE( ok ) );
	 }
	 
#else
#if !#valueclass(Object)

	 public VALUE_TYPE GET_VALUE( final Object k ) {
		  final Entry e = findKey( k );
		  return e == null ? defRetValue : e.value;
	 }


	 public VALUE_TYPE REMOVE_VALUE( final Object k ) {
		  final VALUE_TYPE oldValue = delete( k );
		  deleted = change = null;
		  return oldValue;
	 }

#endif
#endif

	 public KEY_TYPE FIRST_KEY() {
		  return firstEntry.key;
	 }
	 
	 public KEY_TYPE LAST_KEY() {
		  return lastEntry.key;
	 }
	 
#if !#keyclass(Object)
	 public Object firstKey() {
		  return KEY2OBJ( FIRST_KEY() );
	 }
	 
	 public Object lastKey() {
		  return KEY2OBJ( LAST_KEY() );
	 }

#endif

	 /** An iterator on the whole range.
	  *
	  * <P>This class can iterate in both directions on a threaded tree.
	  */

	 private class TreeIterator implements ListIterator {
		  /** The entry that will be returned by the next call to {@link #previous()} (or <code>null</code> if no previous entry exists). */
		  protected Entry prev;
		  /** The entry that will be returned by the next call to {@link #next()} (or <code>null</code> if no next entry exists). */
		  protected Entry next;
		  /** The last entry that was returned (or <code>null</code> if we did not iterate or used {@link #remove()}). */
		  protected Entry curr;
		  /** The current index (in the sense of a {@link ListIterator}). */
		  protected int index = 0;
		  
		  protected TreeIterator() {
				next = firstEntry;
		  }

		  public boolean hasNext() { return next != null; }
		  public boolean hasPrevious() { return prev != null; }

		  protected void updateNext() {
				next = next.right;
				if ( next != null && ! curr.pred() ) while ( next.left() != null ) next = next.left;
		  }

		  protected Entry nextEntry() {
				if ( ! hasNext() ) throw new NoSuchElementException();
				curr = prev = next;
				index++;
				updateNext();
				return curr;
		  }

		  public Object next() { return nextEntry(); }

		  protected void updatePrevious() {
				prev = prev.left;
				if ( prev != null && ! curr.pred() ) while ( prev.right() != null ) prev = prev.right;
		  }

		  protected Entry previousEntry() {
				if ( ! hasPrevious() ) throw new NoSuchElementException();
				curr = next = prev;
				index--;
				updatePrevious();
				return curr;
		  }

		  public Object previous() { return previousEntry(); }

		  public int nextIndex() {
				if ( ! hasNext() ) throw new NoSuchElementException();
				return index;
		  }

		  public int previousIndex() {
				if ( ! hasPrevious() ) throw new NoSuchElementException();
				return index - 1;
		  }

		  public void remove() {
				if ( curr == null ) throw new IllegalStateException();
				/* If the last operation was a next(), we are removing an entry that preceeds
					the current index, and thus we must decrement it. */
				if ( curr == prev ) index--;
				next = prev = curr;
				updatePrevious();
				updateNext();
				TREEMAP.this.delete( curr.key );

				/* It could happen that the entry we chose as next is exactly the
				one that gets deleted (as deletion is performed by copying a
				suitable entry over the one to be deleted and then removing the
				source of the copy).  In this case, next will point to a removed
				entry (change); it should instead point to the destination of the
				copy (deleted), which is certainly the entry immediately after the
				deleted one. */
				if ( next == change ) next = deleted;
				change = deleted = curr = null;
		  }

		  public void set( Object o ) {
				throw new UnsupportedOperationException();
		  }

		  public void add( Object o ) {
				throw new UnsupportedOperationException();
		  }
	 }




    public Set entrySet() {
		  if ( entries == null ) entries = new AbstractSet() {
					 public Iterator iterator() {
						  return new TreeIterator();
					 }

					 public boolean contains(Object o) {
						  if (!(o instanceof Map.Entry)) return false;
						  final Map.Entry e = (Map.Entry)o;
						  final Entry f = findKey( KEY2TYPE( e.getKey() ) );
						  return e.equals( f );
					 }					 

					 public boolean remove(Object o) {
						  if (!(o instanceof Map.Entry)) return false;
						  final Map.Entry e = (Map.Entry)o;
						  final Entry f = findKey( KEY2TYPE( e.getKey() ) );
						  if ( f != null ) TREEMAP.this.remove( f.key );
						  change = deleted = null;
						  return f != null;
					 }

					 public int size() {
						  return count;
					 }
					 
					 public void clear() {
						  TREEMAP.this.clear();
					 }
					 
				};

		  return entries;
	 }

	 /** An iterator on the whole range of keys.
	  *
	  * <P>This class can iterate in both directions on the keys of a threaded tree. We 
	  * simply override the {@link #next()}/{@link #previous()} methods (and possibly
	  * their type-specific counterparts) so that they return keys instead of entries.
	  */
	 private class KeyIterator extends TreeIterator implements KEY_LIST_ITERATOR {
		  public KEY_TYPE NEXT_KEY() { return nextEntry().key; }
		  public KEY_TYPE PREV_KEY() { return previousEntry().key; }
#if !#keyclass(Object)
		  public Object next() { return KEY2OBJ( nextEntry().key ); }
		  public Object previous() { return KEY2OBJ( previousEntry().key ); }
#endif									
	 };

	 public Set keySet() {
		  if ( keys == null ) keys = new KEY_ABSTRACT_SET() {

					 public Iterator iterator() {
						  return new KeyIterator();
					 }

					 public boolean contains( KEY_TYPE k ) {
						  return containsKey( k );
					 }					 

					 public boolean remove( KEY_TYPE k ) {
						  TREEMAP.this.remove( k );
						  return modified;
					 }					 

#if ! #keyclass( Object )

					 public boolean contains( Object ok ) {
						  return containsKey( ok );
					 }					 

					 public boolean remove( Object ok ) {
						  TREEMAP.this.remove( KEY2TYPE( ok ) );
						  return modified;
					 }

#endif

					 public int size() {
						  return count;
					 }
					 
					 public void clear() {
						  TREEMAP.this.clear();
					 }
					 
				};

		  return keys;
	 }

	 /** An iterator on the whole range of values.
	  *
	  * <P>This class can iterate in both directions on the values of a threaded tree. We 
	  * simply override the {@link #next()}/{@link #previous()} methods (and possibly
	  * their type-specific counterparts) so that they return values instead of entries.
	  */
	 private class ValueIterator extends TreeIterator implements VALUE_LIST_ITERATOR {
		  public VALUE_TYPE NEXT_VALUE() { return nextEntry().value; }
		  public VALUE_TYPE PREV_VALUE() { return previousEntry().value; }
#if !#valueclass(Object)
		  public Object next() { return VALUE2OBJ( nextEntry().value ); }
		  public Object previous() { return VALUE2OBJ( previousEntry().value ); }
#endif									
	 };


    public Collection values() {
		  if ( values == null ) values = new VALUE_ABSTRACT_COLLECTION() {
					 public Iterator iterator() {
						  return new ValueIterator();
					 }

					 public boolean contains( VALUE_TYPE k ) {
						  return containsValue( k );
					 } 

#if ! #valueclass( Object )
					 public boolean contains( Object ok ) {
						  return containsValue( ok );
					 }					 
#endif

					 public int size() {
						  return count;
					 }
					 
					 public void clear() {
						  TREEMAP.this.clear();
					 }
					 
				};

		  return values;
	 }

	 public Comparator comparator() {
		  return storedComparator;
	 }

	 public SortedMap headMap( Object to  ) {
		  return new Submap( KEY_NULL, true, KEY2TYPE( to ), false );
	 }

	 public SortedMap tailMap( Object from ) {
		  return new Submap( KEY2TYPE( from ), false, KEY_NULL, true );
	 }

	 public SortedMap subMap( Object from, Object to ) {
		  return new Submap( KEY2TYPE( from ), false, KEY2TYPE( to ), false );
	 }

#if !#keyclass(Object)
	 public SORTEDMAP headMap( KEY_TYPE to ) {
		  return new Submap( KEY_NULL, true, to, false );
	 }

	 public SORTEDMAP tailMap( KEY_TYPE from ) {
		  return new Submap( from, false, KEY_NULL, true );
	 }

	 public SORTEDMAP subMap( KEY_TYPE from, KEY_TYPE to ) {
		  return new Submap( from, false, to, false );
	 }
#endif

	 /** A submap with given range.
	  *
	  * <P>This class represents a submap. One has to specify the left/right
	  * limits (which can be set to -&infin; or &infin;). Since the submap is a
	  * view on the map, at a given moment it could happen that the limits of
	  * the range are not any longer in the main map. Thus, things such as
	  * {@link #firstKey()} or {@link #size()} must be always computed
	  * on-the-fly.  
	  */
	 private class Submap extends ABSTRACT_MAP implements Serializable, SORTEDMAP {
		  /** The start of the submap range, unless {@link #bottom} is true. */
		  private KEY_TYPE from;
		  /** The end of the submap range, unless {@link #top} is true. */
		  private KEY_TYPE to;
		  /** If true, the submap range starts from -&infin;. */
		  private boolean bottom;
		  /** If true, the submap range goes to &infin;. */
		  private boolean top;
		  /** Cached set of entries and keys. */
		  private transient volatile Set entries, keys;
		  /** Cached collection of values. */
		  private transient volatile Collection values;
		  
		  /** Creates a new submap with given key range.
			*
			* @param from the start of the submap range.
			* @param bottom if true, the first parameter is ignored and the range starts from -&infin;.
			* @param to the end of the submap range.
			* @param top if true, the third parameter is ignored and the range goes to &infin;.
			*/
		  public Submap( KEY_TYPE from, boolean bottom, KEY_TYPE to, boolean top ) {
				if ( ! bottom && ! top && TREEMAP.this.compare( from, to ) > 0 ) {
					 throw new IllegalArgumentException( "fromKey > toKey" );
				}

				this.from = from;
				this.bottom = bottom;
				this.to = to;
				this.top = top;
				this.defRetValue = TREEMAP.this.defRetValue;
		  }

		  public void clear() {
				final SubmapIterator i = new SubmapIterator();
				while( i.hasNext() ) {
					 i.next();
					 i.remove();
				}
		  }

		  /** Checks whether a key is in the submap range.
			* @param k a key.
			* @return true if is the key is in the submap range.
			*/
		  private boolean in( KEY_TYPE k ) {
				return ( bottom || TREEMAP.this.compare( k, from ) >= 0 ) &&
					 ( top || TREEMAP.this.compare( k, to ) < 0 );
		  }

		  public Set entrySet() {
				if ( entries == null ) entries = new AbstractSet() {
						  public Iterator iterator() {
								return new SubmapIterator();
						  }
						  
						  public boolean contains(Object o) {
								if (!(o instanceof Map.Entry)) return false;
								final Map.Entry e = (Map.Entry)o;
								final TREEMAP.Entry f = findKey( KEY2TYPE( e.getKey() ) );
								return f != null && in( f.key ) && e.equals( f );
						  }					 

						  public boolean remove(Object o) {
								if (!(o instanceof Map.Entry)) return false;
								final Map.Entry e = (Map.Entry)o;
								final TREEMAP.Entry f = findKey( KEY2TYPE( e.getKey() ) );
								if ( f != null && in( f.key ) ) Submap.this.remove( f.key );
								change = deleted = null;
								return f != null;
						  }

						  public int size() {
								int c = 0;
								for( Iterator i = iterator(); i.hasNext(); i.next() ) c++;
								return c;
						  }
					 

						  public boolean isEmpty() {
								return ! new SubmapIterator().hasNext();
						  }

						  public void clear() {
								Submap.this.clear();
						  }
					 
					 };

				return entries;
		  }

		  public Set keySet() {
				if ( keys == null ) keys = new KEY_ABSTRACT_SET() {
						  
						  public Iterator iterator() {
								return new SubmapKeyIterator();
						  }

						  public boolean contains( KEY_TYPE k ) {
								return containsKey( k );
						  }					 

						  public boolean remove( KEY_TYPE k ) {
								Submap.this.remove( k );
								return modified;
						  }					 

#if ! #keyclass( Object )
						  public boolean contains( Object ok ) {
								return containsKey( ok );
						  }					 
						  
						  public boolean remove( Object ok ) {
								Submap.this.remove( KEY2TYPE( ok ) );
								return modified;
						  }
#endif
						  
						  public int size() {
								return Submap.this.size();
						  }
						  
						  public void clear() {
								Submap.this.clear();
						  }
					 
					 };

				return keys;
		  }
		  
		  public Collection values() {
				if ( values == null ) values = new VALUE_ABSTRACT_COLLECTION() {
						  public Iterator iterator() {
								return new SubmapValueIterator();
						  }

						  public boolean contains( VALUE_TYPE k ) {
								return containsValue( k );
						  } 

#if ! #valueclass( Object )
						  public boolean contains( Object ok ) {
								return containsValue( ok );
						  }					 
#endif

						  public int size() {
								return Submap.this.size();
						  }
						  
						  public void clear() {
								Submap.this.clear();
						  }
						  
					 };
				
				return values;
		  }
		  
		  public boolean containsKey( final KEY_TYPE k ) {
				return in( k ) && TREEMAP.this.containsKey( k );
		  }

#if !#keyclass(Object) 
		  public boolean containsKey( final Object ok ) {
				return containsKey( KEY2TYPE( ok ) );
		  }
#endif


#if ! #valueclass(Object) 
		  public boolean containsValue(final Object v) {
				return containsValue( VALUE2TYPE( v ) );
		  }
#endif

		  public boolean containsValue(final VALUE_TYPE v) {
				final SubmapIterator i = new SubmapIterator();
				VALUE_TYPE ev;
				
				while( i.hasNext() ) {
					 ev = ((TREEMAP.Entry)i.next()).value;
					 if ( VALUE_EQUAL( ev, v ) ) return true;
				}
				
				return false;
		  }
		  

		  public Object get( final Object ok ) {
				final TREEMAP.Entry e;
				return in( KEY2TYPE( ok ) ) &&  ( e = findKey( KEY2TYPE( ok ) ) ) != null ? e.getValue() : OBJDEFRETVALUE;
		  }
		  
		  
#if ! #keyclass(Object)
		  public VALUE_TYPE get(final KEY_TYPE k) {
				final TREEMAP.Entry e;
				return in( k ) && ( e = findKey( k ) ) != null ? e.value : this.defRetValue;
		  }
#elif ! #valueclass(Object)
		  public VALUE_TYPE GET_VALUE(final Object k) {
				final TREEMAP.Entry e;
				return in( k ) && ( e = findKey( k ) ) != null ? e.value : this.defRetValue;
		  }
#endif
		  
		  
		  public Object put( final Object ok, final Object ov ) {
				if ( ! in( KEY2TYPE( ok ) ) ) throw new IllegalArgumentException(); 
				final VALUE_TYPE oldValue = insert( KEY2TYPE(ok), VALUE2TYPE(ov) );
				return modified ? OBJDEFRETVALUE : VALUE2OBJ( oldValue );
		  }

		  
#if ! ( #valueclass(Object) && #keyclass(Object) )
		  public VALUE_TYPE put(final KEY_TYPE k, final VALUE_TYPE v) {
				if ( ! in( k ) ) throw new IllegalArgumentException(); 
				final VALUE_TYPE oldValue = insert( k, v );
				return modified ? this.defRetValue : oldValue;
		  }
#endif


		  public Object remove( final Object ok ) {
				if ( ! in( KEY2TYPE( ok ) ) ) return null;
				final VALUE_TYPE oldValue = delete( KEY2TYPE( ok ) );
				deleted = change = null;
				return modified ? VALUE2OBJ( oldValue ) : OBJDEFRETVALUE;
		  }

#if ! #keyclass(Object)
		  public VALUE_TYPE remove( final KEY_TYPE k ) {
				if ( ! in( k ) ) return this.defRetValue;
				final VALUE_TYPE oldValue = delete( k );
				deleted = change = null;
				return modified ? oldValue : this.defRetValue;
		  }
#elif ! #valueclass(Object)
		  public VALUE_TYPE REMOVE_VALUE( final Object k ) {
				if ( ! in( k ) ) return this.defRetValue; 
				final VALUE_TYPE oldValue = delete( k );
				deleted = change = null;
				return modified ? oldValue : this.defRetValue;
		  }
#endif

		  public int size() {
				final SubmapIterator i = new SubmapIterator();
				int n = 0;
				
				while( i.hasNext() ) {
					 n++;
					 i.next();
				}
				
				return n;
		  }


		  public boolean isEmpty() {
				return ! new SubmapIterator().hasNext();
		  }
		  
		  public Comparator comparator() {
				return storedComparator;
		  }
		  
		  public SortedMap headMap( final Object oto ) {
				final KEY_TYPE to = KEY2TYPE( oto );

				if ( top ) return new Submap( from, bottom, to, false );
				return compare( to, this.to ) < 0 ? new Submap( from, bottom, to, false ) : this;
		  }
		  
		  public SortedMap tailMap( final Object ofrom ) {
				final KEY_TYPE from = KEY2TYPE( ofrom );

				if ( bottom ) return new Submap( from, false, to, top );
				return compare( from, this.from ) > 0 ? new Submap( from, false, to, top ) : this;
		  }
		  
		  public SortedMap subMap( final Object ofrom, final Object oto ) {
				KEY_TYPE to = KEY2TYPE( oto );
				KEY_TYPE from = KEY2TYPE( ofrom );

				if ( top && bottom ) return new Submap( from, false, to, false );
				if ( ! top ) to = compare( to, this.to ) < 0 ? to : this.to;
				if ( ! bottom ) from = compare( from, this.from ) > 0 ? from : this.from;
				if ( from == this.from && to == this.to ) return this;
				return new Submap( from, false, to, false );
		  }

#if !#keyclass(Object)
		  public SORTEDMAP headMap( final KEY_TYPE to ) {
				if ( top ) return new Submap( from, bottom, to, false );
				return compare( to, this.to ) < 0 ? new Submap( from, bottom, to, false ) : this;
		  }
		  
		  public SORTEDMAP tailMap( final KEY_TYPE from ) {
				if ( bottom ) return new Submap( from, false, to, top );
				return compare( from, this.from ) > 0 ? new Submap( from, false, to, top ) : this;
		  }
		  
		  public SORTEDMAP subMap( KEY_TYPE from, KEY_TYPE to ) {
				if ( top && bottom ) return new Submap( from, false, to, false );
				if ( ! top ) to = compare( to, this.to ) < 0 ? to : this.to;
				if ( ! bottom ) from = compare( from, this.from ) > 0 ? from : this.from;
				if ( from == this.from && to == this.to ) return this;
				return new Submap( from, false, to, false );
		  }
#endif

		  /** Locates a key.
			*
			* @param k a key.
			* @return the last entry on a search for the given key; this will be
			* the given key, if it present; otherwise, it will be either the smallest greater key or the greatest smaller key.
			*/
		  private TREEMAP.Entry locateKey( KEY_TYPE k ) {
				TREEMAP.Entry e = tree, last = tree;
				int cmp = 0;
				
				while ( e != null && ( cmp = compare( k, e.key ) ) != 0 ) {
					 last = e;
					 e = cmp < 0 ? e.left() : e.right();
				}
				
				return cmp == 0 ? e : last;
		  }


		  /** Locates the first entry.
			*
			* @param k a key.
			* @return the first entry of this submap, or <code>null</code> if the submap is empty.
			*/
		  public TREEMAP.Entry firstEntry() {
				if ( tree == null ) return null;
				// If this submap goes to -infinity, we return the main map first entry; otherwise, we locate the start of the map.
				TREEMAP.Entry e;
				if ( bottom ) e = firstEntry;
				else {
					 e = locateKey( from );
					 // If we find either the start or something greater we're OK.
					 if ( compare( e.key, from ) < 0 ) {
						  // Otherwise, we look for a successor.
						  boolean succ = e.succ();
						  e = e.right;
						  // Oops, it's already the last element.
						  if ( e == null ) return null;
						  // If we did not follow a thread we descend the tree on the left.
						  if ( ! succ ) while ( e.left() != null ) e = e.left;
					 }
				}
				// Finally, if this submap doesn't go to infinity, we check that the resulting key isn't greater than the end.
				if ( ! top && compare( e.key, to ) >= 0 ) return null;
				return e;
		  }
	 
		  /** Locates the last entry.
			*
			* @param k a key.
			* @return the last entry of this submap, or <code>null</code> if the submap is empty.
			*/
		  public TREEMAP.Entry lastEntry() {
				if ( tree == null ) return null;
				// If this submap goes to infinity, we return the main map last entry; otherwise, we locate the end of the map.
				TREEMAP.Entry e;
				if ( top ) e = lastEntry;
				else {
					 e = locateKey( to );
					 // If we find something smaller than the end we're OK.
					 if ( compare( e.key, to ) >= 0 ) {
						  // Otherwise, we look for a predecessor.
						  boolean pred = e.pred();
						  e = e.left;
						  // Oops, it's already the first element.
						  if ( e == null ) return null;
						  // If we did not follow a thread we descend the tree on the right.
						  if ( ! pred ) while ( e.right() != null ) e = e.right;
					 }
				}
				// Finally, if this submap doesn't go to -infinity, we check that the resulting key isn't smaller than the start.
				if ( ! bottom && compare( e.key, from ) < 0 ) return null;
				return e;
		  }


		  public KEY_TYPE FIRST_KEY() {
				TREEMAP.Entry e = firstEntry();
				if ( e == null ) throw new NoSuchElementException();
				return e.key;
		  }
		  public KEY_TYPE LAST_KEY() {
				TREEMAP.Entry e = lastEntry();
				if ( e == null ) throw new NoSuchElementException();
				return e.key;
		  }
	 
#if !#keyclass(Object)
		  public Object firstKey() {
				TREEMAP.Entry e = firstEntry();
				if ( e == null ) throw new NoSuchElementException();
				return e.getKey();
		  }
	 
		  public Object lastKey() {
				TREEMAP.Entry e = lastEntry();
				if ( e == null ) throw new NoSuchElementException();
				return e.getKey();
		  }

#endif

		  /** An iterator for subranges.
			* 
			* <P>This class inherits from {@link TreeIterator}, but overrides the methods that
			* update the pointer after a {@link #next()} or {@link #previous()}. If we would
			* move out of the range of the submap we just overwrite the next or previous
			* entry with <code>null</code>.
			*/
		  private class SubmapIterator extends TreeIterator {
				protected SubmapIterator() {
					 next = firstEntry();
				}
				protected void updatePrevious() {
					 super.updatePrevious();
					 if ( ! bottom && prev != null && TREEMAP.this.compare( prev.key, from ) < 0 ) prev = null;
				}
				
				protected void updateNext() {
					 super.updateNext();
					 if ( ! top && next != null && TREEMAP.this.compare( next.key, to ) >= 0 ) next = null;
				}
		  }

		  /** An iterator on a subrange of keys.
			*
			* <P>This class can iterate in both directions on a subrange of the
			* keys of a threaded tree. We simply override the {@link
			* #next()}/{@link #previous()} methods (and possibly their
			* type-specific counterparts) so that they return keys instead of
			* entries.
			*/
		  private class SubmapKeyIterator extends SubmapIterator implements KEY_LIST_ITERATOR {
				public KEY_TYPE NEXT_KEY() { return nextEntry().key; }
				public KEY_TYPE PREV_KEY() { return previousEntry().key; }
#if !#keyclass(Object)
				public Object next() { return KEY2OBJ( nextEntry().key ); }
				public Object previous() { return KEY2OBJ( previousEntry().key ); }
#endif									
		  };
		  
		  /** An iterator on a subrange of values.
			*
			* <P>This class can iterate in both directions on the values of a
			* subrange of the keys of a threaded tree. We simply override the
			* {@link #next()}/{@link #previous()} methods (and possibly their
			* type-specific counterparts) so that they return values instead of
			* entries.  
			*/
		  private class SubmapValueIterator extends SubmapIterator implements VALUE_LIST_ITERATOR {
				public VALUE_TYPE NEXT_VALUE() { return nextEntry().value; }
				public VALUE_TYPE PREV_VALUE() { return previousEntry().value; }
#if !#valueclass(Object)
				public Object next() { return VALUE2OBJ( nextEntry().value ); }
				public Object previous() { return VALUE2OBJ( previousEntry().value ); }
#endif									
	 };


	 }
	 

    private void writeObject(java.io.ObjectOutputStream s) throws IOException {
		  int n = count;
		  Iterator i = new TreeIterator();
		  Entry e;

		  s.defaultWriteObject();

		  while(n-- != 0) {
				e = (Entry)i.next();
				s.WRITE_KEY( e.key );
				s.WRITE_VALUE( e.value );
		  }
    }

    private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
		  s.defaultReadObject();
		  tree = null;
		  /* The storedComparator is now correctly set, but we must restore
			  on-the-fly the actualComparator. */
		  setActualComparator();

		  int count = this.count;
		  this.count = 0;

		  /* This is not very good. There are linear-time ways of rebuilding a
		  tree.  Maybe in the next release... */

		  while( count-- != 0 ) put( s.READ_KEY(), s.READ_VALUE() );
    }



#ifndef NDEBUG

	 private static Random r = new Random();

	 private static KEY_TYPE genKey() {
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
		  return (KEY_TYPE)(r.nextInt());
#elif ! #keyclass(Object)
		  return r.NEXT_KEY(); 
#else
		  return new Long( r.nextLong() );
#endif
	 }

	 private static VALUE_TYPE genValue() {
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
		  return (VALUE_TYPE)(r.nextInt());
#elif ! #valueclass(Object)
		  return r.NEXT_VALUE();
#else
		  return new Long( r.nextLong() );
#endif
	 }


	 private static java.text.NumberFormat format = new java.text.DecimalFormat( "#,###.00" );
	 private static java.text.FieldPosition p = new java.text.FieldPosition( 0 );

	 private static String format( double d ) {
		  StringBuffer s = new StringBuffer();
		  return format.format( d, s, p ).toString();
	 }

	 private static void speedTest( int n ) {
		  int i;
		  MAP m;
		  SortedMap t;
		  Object[] k = new Object[n], v = new Object[n], nk = new Object[n];
		  KEY_TYPE kt[] = new KEY_TYPE[n];
		  KEY_TYPE nkt[] = new KEY_TYPE[n];
		  VALUE_TYPE vt[] = new VALUE_TYPE[n];
		  long ms;

		  for( i = 0; i < n; i++ ) {
#if #keyclass(Object)
				k[i] = kt[i] = genKey();
				nk[i] = nkt[i] = genKey();
#else
				k[i] = new KEY_CLASS( kt[i] = genKey() );
				nk[i] = new KEY_CLASS( nkt[i] = genKey() );
#endif
#if #valueclass(Object)
				v[i] = vt[i] = genValue();
#else
				v[i] = new VALUE_CLASS( vt[i] = genValue() );
#endif
		  }

		  double totPut = 0, totYes = 0, totNo = 0, totIter = 0, totRemYes = 0, totRemNo = 0, d;

		  for( int j = 0; j < 20; j++ ) {

				t = new TreeMap();

				/* We put pairs to t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.put( k[i], v[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totPut += d; 				
				System.out.print("Put: " + format( d ) +" K/s " );

				/* We check for pairs in t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.containsKey( k[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totYes += d; 				
				System.out.print("Yes: " + format( d ) +" K/s " );

				/* We check for pairs not in t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.containsKey( nk[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totNo += d; 				
				System.out.print("No: " + format( d ) +" K/s " );

				/* We iterate on t. */
				ms = System.currentTimeMillis();
				for( Iterator it = t.entrySet().iterator(); it.hasNext(); it.next() );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totIter += d; 				
				System.out.print("Iter: " + format( d ) +" K/s " );
				
				/* We delete pairs not in t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.remove( nk[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totRemNo += d; 				
				System.out.print("RemNo: " + format( d ) +" K/s " );
				
				/* We delete pairs in t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.remove( k[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totRemYes += d; 				
				System.out.print("RemYes: " + format( d ) +" K/s " );
				
				System.out.println();
		  }

		  System.out.println();
		  System.out.println( "java.util Put: " + format( totPut/20 ) + " K/s Yes: " + format( totYes/20 ) + " K/s No: " + format( totNo/20 ) + " K/s Iter: " + format( totIter/20 ) + " K/s RemYes: " + format( totRemYes/20 ) + " K/s RemNo: " + format( totRemNo/20 ) + "K/s" );

		  System.out.println();

		  totPut = totYes = totNo = totIter = totRemYes = totRemNo = 0;

		  for( int j = 0; j < 20; j++ ) {

				m = new TREEMAP();

				/* We put pairs to m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.put( kt[i], vt[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totPut += d; 				
				System.out.print("Put: " + format( d ) +" K/s " );

				/* We check for pairs in m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.containsKey( kt[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totYes += d; 				
				System.out.print("Yes: " + format( d ) +" K/s " );

				/* We check for pairs not in m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.containsKey( nkt[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totNo += d; 				
				System.out.print("No: " + format( d ) +" K/s " );

				/* We iterate on m. */
				ms = System.currentTimeMillis();
				for( Iterator it = m.entrySet().iterator(); it.hasNext(); it.next() );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totIter += d; 	 
				System.out.print("Iter: " + format( d ) +" K/s " );

				/* We delete pairs not in m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.remove( nkt[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totRemNo += d; 	
				System.out.print("RemNo: " + format( d ) +" K/s " );

				/* We delete pairs in m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.remove( kt[i] );
				d = 1.0 * n / (System.currentTimeMillis() - ms );
				if ( j > 2 ) totRemYes += d; 				
				System.out.print("RemYes: " + format( d ) +" K/s " );	 

				System.out.println();
		  }


		  System.out.println();
		  System.out.println( "fastUtil  Put: " + format( totPut/20 ) + " K/s Yes: " + format( totYes/20 ) + " K/s No: " + format( totNo/20 ) + " K/s Iter: " + format( totIter/20 ) + " K/s RemYes: " + format( totRemYes/20 ) + " K/s RemNo: " + format( totRemNo/20 ) + " K/s" );

		  System.out.println();

	 }


	 private static boolean valEquals(Object o1, Object o2) {
		  return o1 == null ? o2 == null : o1.equals(o2);
	 }

	 private static void fatal( String msg ) {
		  System.out.println( msg );
		  System.exit( 1 );
	 }

	 private static void ensure( boolean cond, String msg ) {
		  if ( cond ) return;
		  fatal( msg );
	 }

	 private static Object[] k, v, nk;
	 private static KEY_TYPE kt[];
	 private static KEY_TYPE nkt[];
	 private static VALUE_TYPE vt[];
	 private static TREEMAP topMap;

	 private static void testMaps( SORTEDMAP m, SortedMap t, int n, int level ) {
		  long ms;
		  Random r = new Random();
		  boolean mThrowsIllegal, tThrowsIllegal, mThrowsNoElement, tThrowsNoElement;
		  Object rt = null, rm = null;

		  if ( level > 4 ) return;
				

		  /* Now we check that both maps agree on first/last keys. */

		  mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		  try {
				m.firstKey();
		  }
		  catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		  try {
				t.firstKey();
		  }
		  catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		  ensure( mThrowsNoElement == tThrowsNoElement, "Error: firstKey() divergence at start in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
		  if ( ! mThrowsNoElement ) ensure( t.firstKey().equals( m.firstKey() ), "Error: m and t differ at start on their first key (" + m.firstKey() + ", " + t.firstKey() +").\n" );

		  mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		  try {
				m.lastKey();
		  }
		  catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		  try {
				t.lastKey();
		  }
		  catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		  ensure( mThrowsNoElement == tThrowsNoElement, "Error: lastKey() divergence at start in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );


		  if ( ! mThrowsNoElement ) ensure( t.lastKey().equals( m.lastKey() ), "Error: m and t differ at start on their last key (" + m.lastKey() + ", " + t.lastKey() +").\n");


		  /* Now we check that m and t are equal. */
		  if ( !m.equals( t ) || ! t.equals( m ) ) System.err.println("m: " + m + " t: " + t);

		  ensure( m.equals( t ), "Error: ! m.equals( t ) at start.\n" );
		  ensure( t.equals( m ), "Error: ! t.equals( m ) at start.\n" );



		  /* Now we check that m actually holds that data. */
		  for(Iterator i=t.entrySet().iterator(); i.hasNext();  ) {
				java.util.Map.Entry e = (java.util.Map.Entry)i.next();
		      ensure( valEquals(e.getValue(), m.get(e.getKey())), "Error: m and t differ on an entry ("+e+") after insertion (iterating on t).\n" );
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  for(Iterator i=m.entrySet().iterator(); i.hasNext();  ) {
				Entry e = (Entry)i.next();
		      ensure( valEquals(e.getValue(), t.get(e.getKey())), "Error: m and t differ on an entry ("+e+") after insertion (iterating on m).\n" );
		  }

		  /* Now we check that m actually holds the same keys. */
		  for(Iterator i=t.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      ensure( m.containsKey(o), "Error: m and t differ on a key ("+o+") after insertion (iterating on t).\n" );
		      ensure( m.keySet().contains(o), "Error: m and t differ on a key ("+o+", in keySet()) after insertion (iterating on t).\n" );
		  }

		  /* Now we check that m actually holds the same keys, but iterating on m. */
		  for(Iterator i=m.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      ensure( t.containsKey(o), "Error: m and t differ on a key after insertion (iterating on m).\n" );
		      ensure( t.keySet().contains(o), "Error: m and t differ on a key (in keySet()) after insertion (iterating on m).\n" );
		  }


		  /* Now we check that m actually hold the same values. */
		  for(Iterator i=t.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      ensure( m.containsValue(o), "Error: m and t differ on a value after insertion (iterating on t).\n" );
		      ensure( m.values().contains(o), "Error: m and t differ on a value (in values()) after insertion (iterating on t).\n" );
		  }

		  /* Now we check that m actually hold the same values, but iterating on m. */
		  for(Iterator i=m.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      ensure( t.containsValue(o), "Error: m and t differ on a value after insertion (iterating on m).\n");
		      ensure( t.values().contains(o), "Error: m and t differ on a value (in values()) after insertion (iterating on m).\n");
		  }

		  /* Now we check that inquiries about random data give the same answer in m and t. For
			  m we use the polymorphic method. */

		  for(int i=0; i<n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 new Long(r.nextLong())
#endif
					 ;
				
				mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;

				try {
					 m.containsKey(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }

				try {
					 t.containsKey(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }

				ensure( mThrowsNoElement == tThrowsNoElement, "Error: containsKey() divergence in NoSuchElementException (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
				ensure( mThrowsIllegal == tThrowsIllegal, "Error: containsKey() divergence in IllegalArgumentException (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
				if ( !mThrowsNoElement && !mThrowsIllegal ) {
					 ensure( m.containsKey(KEY2OBJ(T)) == t.containsKey(KEY2OBJ(T)), "Error: divergence in keys between t and m (polymorphic method).\n" );
					 
#if #keyclass(Object) && ! #valueclass(Object)
					 if ((m.GET_VALUE(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) || 
						  t.get(KEY2OBJ(T)) != null && 
						  ! VALUE2OBJ(m.GET_VALUE(T)).equals(t.get(KEY2OBJ(T)))) 
#else
						  if ((m.get(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) || 
								t.get(KEY2OBJ(T)) != null && 
								! m.get(KEY2OBJ(T)).equals(t.get(KEY2OBJ(T)))) 
#endif
								{
									 System.out.println("Error: divergence between t and m (polymorphic method).\n");
									 System.exit(-1);
								}
				}
		  }

		  /* Again, we check that inquiries about random data give the same answer in m and t, but
			  for m we use the standard method. */

		  for(int i=0; i<n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 new Long(r.nextLong())
#endif
					 ;

				mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;

				try {
					 m.get(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }

				try {
					 t.get(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }

				ensure( mThrowsNoElement == tThrowsNoElement, "Error: get() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
				ensure( mThrowsIllegal == tThrowsIllegal, "Error: get() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
				if ( !mThrowsNoElement && !mThrowsIllegal ) ensure( valEquals(m.get(KEY2OBJ(T)), t.get(KEY2OBJ(T))), "Error: divergence between t and m (standard method).\n" );
		  }

		  /* Now we put and remove random data in m and t, checking that the result is the same. */

		  for(int i=0; i<20*n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 new Long(r.nextLong())
#endif
					 ;
				VALUE_TYPE U =
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
					 (VALUE_TYPE)r.nextInt()
#elif ! #valueclass(Object)
					 r.NEXT_VALUE()
#else
					 new Long(r.nextLong())
#endif
					 ;



				mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;

				try {
					 rm = m.put(KEY2OBJ(T), VALUE2OBJ(U));
				}
				catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }

				try {
					 rt = t.put(KEY2OBJ(T), VALUE2OBJ(U));
				}
				catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }


				ensure( mThrowsNoElement == tThrowsNoElement, "Error: put() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
				ensure( mThrowsIllegal == tThrowsIllegal, "Error: put() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
				if ( !mThrowsNoElement && !mThrowsIllegal ) ensure( valEquals( rm, rt ), "Error: divergence in put() between t and m.\n" );

				T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 new Long(r.nextLong())
#endif
					 ;


				mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;

				try {
					 rm = m.remove(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }

				try {
					 rt = t.remove(KEY2OBJ(T));
				}
				catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
				catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }


				ensure( mThrowsNoElement == tThrowsNoElement, "Error: remove() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
				ensure( mThrowsIllegal == tThrowsIllegal, "Error: remove() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
				if ( !mThrowsNoElement && !mThrowsIllegal ) ensure( valEquals( rm, rt ), "Error: divergence in remove() between t and m.\n" );
		  }

		  ensure( m.equals(t), "Error: ! m.equals( t ) after removal.\n" );
		  ensure( t.equals(m), "Error: ! t.equals( m ) after removal.\n" );

		  /* Now we check that m actually holds the same data. */
		  
		  for(Iterator i=t.entrySet().iterator(); i.hasNext();  ) {
				java.util.Map.Entry e = (java.util.Map.Entry)i.next();
		      ensure( valEquals(e.getValue(), m.get(e.getKey())), "Error: m and t differ on an entry ("+e+") after removal (iterating on t).\n");
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  
		  for(Iterator i=m.entrySet().iterator(); i.hasNext();  ) {
				Entry e = (Entry)i.next();
		      ensure( valEquals(e.getValue(), t.get(e.getKey())), "Error: m and t differ on an entry ("+e+") after removal (iterating on m).\n" );
		  }

		  /* Now we check that m actually holds the same keys. */
		  
		  for(Iterator i=t.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      ensure( m.containsKey(o), "Error: m and t differ on a key ("+o+") after removal (iterating on t).\n");
		      ensure( m.keySet().contains(o), "Error: m and t differ on a key ("+o+", in keySet()) after removal (iterating on t).\n");
		  }

		  /* Now we check that m actually holds the same keys, but iterating on m. */
		  
		  for(Iterator i=m.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      ensure( t.containsKey(o), "Error: m and t differ on a key after removal (iterating on m).\n");
		      ensure( t.keySet().contains(o), "Error: m and t differ on a key (in keySet()) after removal (iterating on m).\n");
		  }


		  /* Now we check that m actually hold the same values. */
		  
		  for(Iterator i=t.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      ensure( m.containsValue(o), "Error: m and t differ on a value after removal (iterating on t).\n" );
		      ensure( m.values().contains(o), "Error: m and t differ on a value (in values()) after removal (iterating on t).\n");
		  }

		  /* Now we check that m actually hold the same values, but iterating on m. */
		  
		  for(Iterator i=m.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      ensure( t.containsValue(o), "Error: m and t differ on a value after removal (iterating on m).\n");
		      ensure( t.values().contains(o), "Error: m and t differ on a value (in values()) after removal (iterating on m).\n");
		  }

		  /* Now we check that both maps agree on first/last keys. */

		  mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		  try {
				m.firstKey();
		  }
		  catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		  try {
				t.firstKey();
		  }
		  catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		  ensure( mThrowsNoElement == tThrowsNoElement, "Error: firstKey() divergence in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
		  if ( ! mThrowsNoElement ) ensure( t.firstKey().equals( m.firstKey() ), "Error: m and t differ on their first key (" + m.firstKey() + ", " + t.firstKey() +").\n" );

		  mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		  try {
				m.lastKey();
		  }
		  catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		  try {
				t.lastKey();
		  }
		  catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		  ensure( mThrowsNoElement == tThrowsNoElement, "Error: lastKey() divergence in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );

		  if ( ! mThrowsNoElement ) ensure( t.lastKey().equals( m.lastKey() ), "Error: m and t differ on their last key (" + m.lastKey() + ", " + t.lastKey() +").\n");



		  int h = m.hashCode();


		  /* Now we save and read m. */

		  SORTEDMAP m2 = null;
		  
		  try {
				java.io.File ff = new java.io.File("regressionTest");
				java.io.OutputStream os = new java.io.FileOutputStream(ff);
				java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);
				
				oos.writeObject(m);
				oos.close();
				
				java.io.InputStream is = new java.io.FileInputStream(ff);
				java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);
				
				m2 = (SORTEDMAP)ois.readObject();
				ois.close();
				ff.delete();
		  }
		  catch(Exception e) {
				e.printStackTrace();
				System.exit(-1);
		  }

		  ensure( m2.hashCode() == h, "Error: hashCode() changed after save/read.\n" );
		  
		  /* Now we check that m2 actually holds that data. */
		  
		  ensure( m2.equals(t), "Error: ! m2.equals( t ) after save/read.\n" );
		  ensure( t.equals(m2), "Error: ! t.equals( m2 ) after save/read.\n" );

		  /* Now we take out of m everything, and check that it is empty. */

		  for(Iterator i=t.keySet().iterator(); i.hasNext(); ) m2.remove(i.next());

		  ensure( m2.isEmpty(), "Error: m2 is not empty (as it should be).\n" );
				 
		  /* Now we play with iterators. */

		  {
				ListIterator i, j;
				Object J;
				i = (ListIterator)m.keySet().iterator(); 
				j = new LinkedList( t.keySet() ).listIterator(); 

				for( int k = 0; k < n/2; k++ ) {
					 if ( i.hasNext() != j.hasNext() ) {
						  System.out.println("Error: divergence in hasNext().\n");
						  System.exit(-1);
					 }
					 if ( i.hasPrevious() != j.hasPrevious() ) {
						  System.out.println("Error: divergence in hasNext().\n");
						  System.exit(-1);
					 }

					 if ( r.nextFloat() < .8 && i.hasNext() ) {
						  if ( !i.next().equals( J = j.next() ) ) {
								System.out.println("Error: divergence in next().\n");
								System.exit(-1);
						  }

						  if ( r.nextFloat() < 0.05 ) {
								i.remove();
								j.remove();
								t.remove( J );
						  }
					 }
					 else if ( r.nextFloat() < .2 && i.hasPrevious() ) {
						  if ( !i.previous().equals( J = j.previous() ) ) {
								System.out.println("Error: divergence in previous().\n");
								System.exit(-1);
						  }

						  if ( r.nextFloat() < 0.05 ) {
								i.remove();
								j.remove();
								t.remove( J );
						  }
					 }
				}

		  }

		  /* Now we check that m actually holds that data. */
		  
		  ensure( m.equals(t), "Error: ! m.equals( t ) after iteration.\n" );
		  ensure( t.equals(m), "Error: ! t.equals( m ) after iteration.\n" );

		  /* Now we select a pair of keys and create a submap. */

		  if ( ! m.isEmpty() ) {
				ListIterator i;
				Object start = m.firstKey(), end = m.firstKey();
				for( i = (ListIterator)m.keySet().iterator(); i.hasNext() && r.nextFloat() < .3; start = end = i.next() );
				for( ; i.hasNext() && r.nextFloat() < .95; end = i.next() );

				//System.err.println("Checking subMap from " + start + " to " + end + " (level=" + (level+1) + ")..." );
				testMaps( (SORTEDMAP)m.subMap( start, end ), t.subMap( start, end ), n, level + 1 );

				ensure( m.equals(t), "Error: ! m.equals( t ) after subMap.\n" );
				ensure( t.equals(m), "Error: ! t.equals( m ) after subMap.\n" );

				//System.err.println("Checking headMap to " + end + " (level=" + (level+1) + ")..." );
				testMaps( (SORTEDMAP)m.headMap( end ), t.headMap( end ), n, level + 1 );

				ensure( m.equals(t), "Error: ! m.equals( t ) after headMap.\n" );
				ensure( t.equals(m), "Error: ! t.equals( m ) after headMap.\n" );

				//System.err.println("Checking tailMap from " + start + " (level=" + (level+1) + ")..." );
				testMaps( (SORTEDMAP)m.tailMap( start ), t.tailMap( start ), n, level + 1 );

				ensure( m.equals(t), "Error: ! m.equals( t ) after tailMap.\n" );
				ensure( t.equals(m), "Error: ! t.equals( m ) after tailMap.\n" );
		  }
		  

	 }


	 private static void regressionTest( int n ) {
		  TREEMAP m = new TREEMAP();
		  SortedMap t = new TreeMap();
		  topMap = m;
		  k = new Object[n];
		  v = new Object[n];
		  nk = new Object[n];
		  kt = new KEY_TYPE[n];
		  nkt = new KEY_TYPE[n];
		  vt = new VALUE_TYPE[n];

		  for( int i = 0; i < n; i++ ) {
#if #keyclass(Object)
				k[i] = kt[i] = genKey();
				nk[i] = nkt[i] = genKey();
#else
				k[i] = new KEY_CLASS( kt[i] = genKey() );
				nk[i] = new KEY_CLASS( nkt[i] = genKey() );
#endif
#if #valueclass(Object)
				v[i] = vt[i] = genValue();
#else
					 v[i] = new VALUE_CLASS( vt[i] = genValue() );
#endif
		  }
		  
		  /* We add pairs to t. */
		  for( int i = 0; i < n;  i++ ) t.put( k[i], v[i] );
		  
		  /* We add to m the same data */
		  m.putAll(t);

		  testMaps( m, t, n, 0 );

		  System.out.println("Regression test OK.\n");
		  System.exit(0);
	 }


	 public static void main( String args[] ) {
		  int n  = Integer.parseInt(args[1]);
		  
		  if (args[0].equals("speedTest")) speedTest(n);
		  else if (args[0].equals("regressionTest")) regressionTest(n);
	 }

#endif


}

// Local Variables:
// mode: java
// End:
