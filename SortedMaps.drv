/*		 
 * fastutil: Fast & compact type-specific collections for Java
 *
 * Copyright (C) 2002, 2003 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package PACKAGE;

import it.unimi.dsi.fastutil.booleans.*;
import it.unimi.dsi.fastutil.bytes.*;
import it.unimi.dsi.fastutil.shorts.*;
import it.unimi.dsi.fastutil.chars.*;
import it.unimi.dsi.fastutil.ints.*;
import it.unimi.dsi.fastutil.longs.*;
import it.unimi.dsi.fastutil.floats.*;
import it.unimi.dsi.fastutil.doubles.*;
import it.unimi.dsi.fastutil.objects.*;

import it.unimi.dsi.fastutil.Iterators;

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Map;
import java.util.SortedSet;
import java.util.SortedMap;
import java.util.NoSuchElementException;

/** A class providing static methods that do useful things with type-specific maps.
 *
 * @see java.util.Collections
 */

public class SORTEDMAPS {

	private SORTEDMAPS() {}


	/** A class representing an empty sorted map. */

	protected static class EmptySortedMap extends MAPS.EmptyMap implements SORTEDMAP, java.io.Serializable, Cloneable {
		
		public static final long serialVersionUID = -7046029254386353129L;
		
		protected EmptySortedMap() {}
		
		public Comparator comparator() { return null; } 
		
		public STDSORTEDMAP subMap( final KEY_TYPE from, final KEY_TYPE to ) { return EMPTY_MAP; }
		public STDSORTEDMAP headMap( final KEY_TYPE to ) { return EMPTY_MAP; }
		public STDSORTEDMAP tailMap( final KEY_TYPE from ) { return EMPTY_MAP; }

		public KEY_TYPE FIRST_KEY() { throw new NoSuchElementException(); }
		public KEY_TYPE LAST_KEY() { throw new NoSuchElementException(); }

#if ! #keyclass(Object) && ! #keyclass(Reference)
		public Object firstKey() { throw new NoSuchElementException(); }
		public Object lastKey() { throw new NoSuchElementException(); }

		public SortedMap subMap( final Object from, final Object to ) { return EMPTY_MAP; }
		public SortedMap headMap( final Object to ) { return EMPTY_MAP; }
		public SortedMap tailMap( final Object from ) { return EMPTY_MAP; }
#endif

	}



	/** An empty type-specific sorted map (immutable). It is serializable and cloneable. */
	 
	public static final EmptySortedMap EMPTY_MAP = new EmptySortedMap();


	/** A class representing a singleton sorted map. */

	protected static class Singleton extends MAPS.Singleton implements SORTEDMAP, java.io.Serializable, Cloneable {
	
		public static final long serialVersionUID = -7046029254386353129L;
	
		final KEY_COMPARATOR comparator;

		protected Singleton( final KEY_TYPE key, final VALUE_TYPE value, KEY_COMPARATOR comparator ) {
			super( key, value );
			this.comparator = comparator;
		}

		private Singleton( final KEY_TYPE key, final VALUE_TYPE value ) {
			this( key, value, null );
		}

		final int compare( final KEY_TYPE k1, final KEY_TYPE k2 ) {
			return comparator == null ? KEY_CMP( k1, k2 ) : comparator.compare( k1, k2 );
		}

		public Comparator comparator() { return comparator; } 

	
		public STDSORTEDMAP subMap( final KEY_TYPE from, final KEY_TYPE to ) { if ( compare( from, key ) <= 0 && compare( key, to ) <= 0 ) return this; else return EMPTY_MAP; }
		public STDSORTEDMAP headMap( final KEY_TYPE to ) { if ( compare( key, to ) <= 0 ) return this; else return EMPTY_MAP; }
		public STDSORTEDMAP tailMap( final KEY_TYPE from ) { if ( compare( from, key ) <= 0 ) return this; else return EMPTY_MAP; }

		public KEY_TYPE FIRST_KEY() { return key; }
		public KEY_TYPE LAST_KEY() { return key; }

#if ! #keyclass(Object) && ! #keyclass(Reference)
		public Object firstKey() { return KEY2OBJ( key ); }
		public Object lastKey() { return KEY2OBJ( key ); }

		public SortedMap subMap( final Object from, final Object to ) { return subMap( KEY2TYPE( from ), KEY2TYPE( to ) ); }
		public SortedMap headMap( final Object to ) { return headMap( KEY2TYPE( to ) ); }
		public SortedMap tailMap( final Object from ) { return tailMap( KEY2TYPE( from ) ); }
#endif
	}

	/** Returns a type-specific immutable sorted map containing only the specified pair. The returned sorted map is serializable and cloneable.
	 *
	 * @param key the only key of the returned sorted map.
	 * @param value the only value of the returned sorted map.
	 * @return a type-specific immutable sorted map containing just the pair <code>&lt;key,value></code>.
	 */

	public static SORTEDMAP singleton( final KEY_TYPE key, VALUE_TYPE value ) {
		return new Singleton( key, value );
	}

	/** Returns a type-specific immutable sorted map containing only the specified pair. The returned sorted map is serializable and cloneable.
	 *
	 * @param key the only key of the returned sorted map.
	 * @param value the only value of the returned sorted map.
	 * @param comparator the comparator to use in the returned sorted map.
	 * @return a type-specific immutable sorted map containing just the pair <code>&lt;key,value></code>.
	 */

	public static SORTEDMAP singleton( final KEY_TYPE key, VALUE_TYPE value, KEY_COMPARATOR comparator ) {
		return new Singleton( key, value, comparator );
	}

#if ( ! #keyclass( Object ) && ! #keyclass( Reference ) ) || ( ! #valueclass( Object ) && ! #valueclass( Reference ) )

	/** Returns a type-specific immutable sorted map containing only the specified pair. The returned sorted map is serializable and cloneable.
	 *
	 * @param key the only key of the returned sorted map.
	 * @param value the only value of the returned sorted map.
	 * @return a type-specific immutable sorted map containing just the pair <code>&lt;key,value></code>.
	 */

	public static SORTEDMAP singleton( final Object key, final Object value ) {
		return new Singleton( KEY2TYPE( key ), VALUE2TYPE( value ) );
	}

	/** Returns a type-specific immutable sorted map containing only the specified pair. The returned sorted map is serializable and cloneable.
	 *
	 * @param key the only key of the returned sorted map.
	 * @param value the only value of the returned sorted map.
	 * @param comparator the comparator to use in the returned sorted map.
	 * @return a type-specific immutable sorted map containing just the pair <code>&lt;key,value></code>.
	 */

	public static SORTEDMAP singleton( final Object key, final Object value, KEY_COMPARATOR comparator ) {
		return new Singleton( KEY2TYPE( key ), VALUE2TYPE( value ), comparator );
	}

#endif


	protected static class SynchronizedSortedMap extends MAPS.SynchronizedMap implements SORTEDMAP, java.io.Serializable {

		public static final long serialVersionUID = -7046029254386353129L;

		SORTEDMAP sortedMap;
		Object sync;

		SynchronizedSortedMap( final SORTEDMAP m, final Object sync ) {
			super( m, sync );
			sortedMap = m;
		}

		SynchronizedSortedMap( final SORTEDMAP m ) {
			super( m );
			sortedMap = m;
		}

		public Comparator comparator() { synchronized( sync ) { return sortedMap.comparator(); } }

		public STDSORTEDMAP subMap( final KEY_TYPE from, final KEY_TYPE to ) { return new SynchronizedSortedMap( (SORTEDMAP)sortedMap.subMap( from, to ), sync ); }
		public STDSORTEDMAP headMap( final KEY_TYPE to ) { return new SynchronizedSortedMap( (SORTEDMAP)sortedMap.headMap( to ), sync ); }
		public STDSORTEDMAP tailMap( final KEY_TYPE from ) { return new SynchronizedSortedMap( (SORTEDMAP)sortedMap.tailMap( from ), sync ); }

		public KEY_TYPE FIRST_KEY() {  synchronized( sync ) { return sortedMap.FIRST_KEY(); } }
		public KEY_TYPE LAST_KEY() {  synchronized( sync ) { return sortedMap.LAST_KEY(); } }

#if ! #keyclass(Object) && ! #keyclass(Reference)
		public Object firstKey() {  synchronized( sync ) { return sortedMap.firstKey(); } }
		public Object lastKey() {  synchronized( sync ) { return sortedMap.lastKey(); } }

		public SortedMap subMap( final Object from, final Object to ) { return new SynchronizedSortedMap( (SORTEDMAP)sortedMap.subMap( from, to ), sync ); }
		public SortedMap headMap( final Object to ) { return new SynchronizedSortedMap( (SORTEDMAP)sortedMap.headMap( to ), sync ); }
		public SortedMap tailMap( final Object from ) { return new SynchronizedSortedMap( (SORTEDMAP)sortedMap.tailMap( from ), sync ); }
#endif


	}

	/** Returns a synchronized map backed by the specified map.
	 *
	 * @param m the map to be "wrapped" in a synchronized map.
	 * @return a synchronized view of the specified map.
	 * @see java.util.Collections#synchronizedSortedMap(SortedMap)
	 */
	public static SORTEDMAP synchronize( final SORTEDMAP m ) { return new SynchronizedSortedMap( m ); }

	/** Returns a synchronized map backed by the specified map, using an assigned object to synchronize.
	 *
	 * @param m the map to be "wrapped" in a synchronized map.
	 * @param sync an object that will be used to synchronize the access to the sorted map.
	 * @return a synchronized view of the specified map.
	 * @see java.util.Collections#synchronizedSortedMap(SortedMap)
	 */

	public static SORTEDMAP synchronize( final SORTEDMAP m, final Object sync ) { return new SynchronizedSortedMap( m, sync ); }






#ifdef TESTNO

	private static KEY_TYPE GEN_KEY() {
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
		return (KEY_TYPE)(r.nextInt());
#elif !#keyclass(Object) && !#keyclass(Reference)
		return r.NEXT_KEY(); 
#elif #keyclass(Object)
		return Integer.toBinaryString( r.nextInt() );
#else
		return new java.io.Serializable() {};
#endif
	}


	private static void test() {
		int n = 100;
		int c;
		KEY_TYPE k = GEN_KEY();
		SINGLETON m = new SINGLETON( k );
		Map t = java.util.Collections.singleton( KEY2OBJ( k ) );

		long ms;
		boolean mThrowsIllegal, tThrowsIllegal, mThrowsNoElement, tThrowsNoElement, mThrowsIndex, tThrowsIndex, mThrowsUnsupp, tThrowsUnsupp;
		boolean rt = false, rm = false;


		/* Now we check that m and t are equal. */
		if ( !m.equals( t ) || ! t.equals( m ) ) System.err.println("m: " + m + " t: " + t);

		ensure( m.equals( t ), "Error (" + seed + "): ! m.equals( t ) at start" );
		ensure( t.equals( m ), "Error (" + seed + "): ! t.equals( m ) at start" );

		/* Now we check that m actually holds that data. */
		for(Iterator i=t.iterator(); i.hasNext();  ) {
			ensure( m.contains( i.next() ), "Error (" + seed + "): m and t differ on an entry after insertion (iterating on t)" );
		}

		/* Now we check that m actually holds that data, but iterating on m. */
		for(Iterator i=m.iterator(); i.hasNext();  ) {
			ensure( t.contains( i.next() ), "Error (" + seed + "): m and t differ on an entry after insertion (iterating on m)" );
		}

		/* Now we check that inquiries about random data give the same answer in m and t. For
		   m we use the polymorphic method. */

		for(int i=0; i<n;  i++ ) {
			KEY_TYPE T = GEN_KEY();
				
			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				m.contains(T);
			}
			catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { mThrowsIndex = true; }

			try {
				t.contains(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { tThrowsIndex = true; }

			ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + seed + "): contains() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m );
			ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + seed + "): contains() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m );
			ensure( mThrowsIndex == tThrowsIndex, "Error (" + seed + "): contains() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m );
			if ( !mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex) ensure( m.contains(KEY2OBJ(T)) == t.contains(KEY2OBJ(T)), "Error (" + seed + "): divergence in keys between t and m (polymorphic method) " + m );
		}

		/* Again, we check that inquiries about random data give the same answer in m and t, but
		   for m we use the standard method. */

		for(int i=0; i<n;  i++ ) {
			KEY_TYPE T = GEN_KEY();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				m.contains(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { mThrowsIndex = true; }
			catch ( UnsupportedOperationException e ) { mThrowsUnsupp = true; }

			try {
				t.contains(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { tThrowsIndex = true; }
			catch ( UnsupportedOperationException e ) { tThrowsUnsupp = true; }

			ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + seed + "): contains() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m );
			ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + seed + "): contains() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m );
			ensure( mThrowsIndex == tThrowsIndex, "Error (" + seed + "): contains() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m );
			ensure( mThrowsUnsupp == tThrowsUnsupp, "Error (" + seed + "): contains() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m );
			if ( !mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp ) ensure( m.contains(KEY2OBJ(T)) ==  t.contains(KEY2OBJ(T)), "Error (" + seed + "): divergence between t and m (standard method) " + m );
		}

		/* Now we add and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++ ) {
			KEY_TYPE T = GEN_KEY();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.add(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { mThrowsIndex = true; }
			catch ( UnsupportedOperationException e ) { mThrowsUnsupp = true; }

			try {
				rt = t.add(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { tThrowsIndex = true; }
			catch ( UnsupportedOperationException e ) { tThrowsUnsupp = true; }

			if ( KEY_EQUAL( T, k ) && ! mThrowsUnsupp && tThrowsUnsupp ) tThrowsUnsupp = false; // Stupid bug in Collections.singleton()

			ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + seed + "): add() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m );
			ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + seed + "): add() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m );
			ensure( mThrowsIndex == tThrowsIndex, "Error (" + seed + "): add() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m );
			ensure( mThrowsUnsupp == tThrowsUnsupp, "Error (" + seed + "): add() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m );
			if ( !mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp ) ensure( rm == rt, "Error (" + seed + "): divergence in add() between t and m " + m );

			T = GEN_KEY();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.remove(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { mThrowsIndex = true; }
			catch ( UnsupportedOperationException e ) { mThrowsUnsupp = true; }

			try {
				rt = t.remove(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { tThrowsIndex = true; }
			catch ( UnsupportedOperationException e ) { tThrowsUnsupp = true; }


			ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + seed + "): remove() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m );
			ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + seed + "): remove() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m );
			ensure( mThrowsIndex == tThrowsIndex, "Error (" + seed + "): remove() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m );
			ensure( mThrowsUnsupp == tThrowsUnsupp, "Error (" + seed + "): remove() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m );
			if ( !mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp ) ensure( rm == rt, "Error (" + seed + "): divergence in remove() between t and m " + m );
		}

		ensure( m.equals(t), "Error (" + seed + "): ! m.equals( t ) after removal " + m );
		ensure( t.equals(m), "Error (" + seed + "): ! t.equals( m ) after removal " + m );

		/* Now we add and remove random collections in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++ ) {
			KEY_TYPE T = GEN_KEY();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.addAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { mThrowsIndex = true; }
			catch ( UnsupportedOperationException e ) { mThrowsUnsupp = true; }

			try {
				rt = t.addAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { tThrowsIndex = true; }
			catch ( UnsupportedOperationException e ) { tThrowsUnsupp = true; }

			if ( KEY_EQUAL( T, k ) && ! mThrowsUnsupp && tThrowsUnsupp ) tThrowsUnsupp = false; // Stupid bug in Collections.singleton()

			ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + seed + "): addAll() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m );
			ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + seed + "): addAll() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m );
			ensure( mThrowsIndex == tThrowsIndex, "Error (" + seed + "): addAll() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m );
			ensure( mThrowsUnsupp == tThrowsUnsupp, "Error (" + seed + "): addAll() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m );
			if ( !mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp ) ensure( rm == rt, "Error (" + seed + "): divergence in addAll() between t and m " + m );

			T = GEN_KEY();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.removeAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { mThrowsIndex = true; }
			catch ( UnsupportedOperationException e ) { mThrowsUnsupp = true; }

			try {
				rt = t.removeAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }
			catch ( IndexOutOfBoundsException e ) { tThrowsIndex = true; }
			catch ( UnsupportedOperationException e ) { tThrowsUnsupp = true; }


			ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + seed + "): removeAll() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m );
			ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + seed + "): removeAll() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m );
			ensure( mThrowsIndex == tThrowsIndex, "Error (" + seed + "): removeAll() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m );
			ensure( mThrowsUnsupp == tThrowsUnsupp, "Error (" + seed + "): removeAll() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m );
			if ( !mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp ) ensure( rm == rt, "Error (" + seed + "): divergence in removeAll() between t and m " + m );
		}

		ensure( m.equals(t), "Error (" + seed + "): ! m.equals( t ) after map removal " + m );
		ensure( t.equals(m), "Error (" + seed + "): ! t.equals( m ) after map removal " + m );

		/* Now we check that m actually holds the same data. */
		  
		for(Iterator i=t.iterator(); i.hasNext();  ) {
			ensure( m.contains( i.next() ), "Error (" + seed + "): m and t differ on an entry after removal (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */
		  
		for(Iterator i=m.iterator(); i.hasNext();  ) {
			ensure( t.contains( i.next() ), "Error (" + seed + "): m and t differ on an entry after removal (iterating on m)" );
		}

		ensure( m.equals( ((SINGLETON)m).clone() ), "Error (" + seed + "): m does not equal m.clone()" );
		ensure( ((SINGLETON)m).clone().equals( m ), "Error (" + seed + "): m.clone() does not equal m" );

		int h = m.hashCode();

		/* Now we save and read m. */

		SORTEDMAP m2 = null;
		  
		try {
			java.io.File ff = new java.io.File("it.unimi.dsi.fastutil.test");
			java.io.OutputStream os = new java.io.FileOutputStream(ff);
			java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);
				
			oos.writeObject(m);
			oos.close();
				
			java.io.InputStream is = new java.io.FileInputStream(ff);
			java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);
				
			m2 = (SORTEDMAP)ois.readObject();
			ois.close();
			ff.delete();
		}
		catch(Exception e) {
			e.printStackTrace();
			System.exit( 1 );
		}

#if ! #keyclass(Reference)

		ensure( m2.hashCode() == h, "Error (" + seed + "): hashCode() changed after save/read" );
		  
		/* Now we check that m2 actually holds that data. */
		  
		ensure( m2.equals(t), "Error (" + seed + "): ! m2.equals( t ) after save/read" );
		ensure( t.equals(m2), "Error (" + seed + "): ! t.equals( m2 ) after save/read" );
#endif

		System.out.println("Test OK");
		return;
	}



	private static long seed = System.currentTimeMillis(); 
	private static java.util.Random r = new java.util.Random( seed );

	private static java.text.NumberFormat format = new java.text.DecimalFormat( "#,###.00" );
	private static java.text.FieldPosition fp = new java.text.FieldPosition( 0 );

	private static String format( double d ) {
		StringBuffer s = new StringBuffer();
		return format.format( d, s, fp ).toString();
	}

	private static void fatal( String msg ) {
		System.out.println( msg );
		System.exit( 1 );
	}

	private static void ensure( boolean cond, String msg ) {
		if ( cond ) return;
		fatal( msg );
	}

	/** This method expects as first argument a lower-cased type (e.g., "int"),
	 * and as second optional argument a seed. */

	public static void main( String arg[] ) throws Exception {
		if ( arg.length > 1 ) r = new java.util.Random( seed = Long.parseLong( arg[ 1 ] ) );
		  
		try {
			SORTEDMAPS.class.getDeclaredMethod( "test" + arg[ 0 ], new Class[] {} ).invoke( SORTEDMAPS.class, new Object[] {} ); 
		} catch( AssertionError e ) {
			System.err.println( e );
			System.err.println( "seed: " + seed );
		}
	}
	
#endif
	
}

// Local Variables:
// mode: jde
// tab-width: 4
// End:
