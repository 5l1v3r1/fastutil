/*		 
 * fastutil: Fast & compact type-specific collections for Java
 *
 * Copyright (C) 2002, 2003, 2004 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package PACKAGE;

import it.unimi.dsi.fastutil.Iterators;

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Map;
import java.util.SortedSet;
import java.util.SortedMap;
import java.util.NoSuchElementException;

/** A class providing static methods and objects that do useful things with type-specific sorted maps.
 *
 * @see java.util.Collections
 */

public class SORTED_MAPS {

	private SORTED_MAPS() {}


	/** An immutable class representing an empty type-specific sorted map. 
	 *
	 * <P>This class may be useful to implement your own in case you subclass
	 * a type-specific sorted map.
	 */

	public static class EmptySortedMap extends MAPS.EmptyMap implements SORTED_MAP, java.io.Serializable, Cloneable {
		
		public static final long serialVersionUID = -7046029254386353129L;
		
		protected EmptySortedMap() {}
		
		public Comparator comparator() { return null; } 
		
		public STD_SORTED_MAP subMap( final KEY_TYPE from, final KEY_TYPE to ) { return EMPTY_MAP; }
		public STD_SORTED_MAP headMap( final KEY_TYPE to ) { return EMPTY_MAP; }
		public STD_SORTED_MAP tailMap( final KEY_TYPE from ) { return EMPTY_MAP; }

		public KEY_TYPE FIRST_KEY() { throw new NoSuchElementException(); }
		public KEY_TYPE LAST_KEY() { throw new NoSuchElementException(); }

#if ! #keyclass(Object) && ! #keyclass(Reference)
		public SortedMap headMap( Object oto ) { return headMap( KEY2TYPE( oto ) ); }
		public SortedMap tailMap( Object ofrom ) { return tailMap( KEY2TYPE( ofrom ) ); }
		public SortedMap subMap( Object ofrom, Object oto ) { return subMap( KEY2TYPE( ofrom ), KEY2TYPE( oto ) ); }

		public Object firstKey() { return KEY2OBJ( FIRST_KEY() ); }
		public Object lastKey() { return KEY2OBJ( LAST_KEY() ); }
#endif

	}



	/** An empty type-specific sorted map (immutable). It is serializable and cloneable. */
	 
	public static final EmptySortedMap EMPTY_MAP = new EmptySortedMap();


	/** An immutable class representing a type-specific singleton sorted map. 
	 *
	 * <P>This class may be useful to implement your own in case you subclass
	 * a type-specific sorted map.
	 */

	public static class Singleton extends MAPS.Singleton implements SORTED_MAP, java.io.Serializable, Cloneable {
	
		public static final long serialVersionUID = -7046029254386353129L;
	
		protected final KEY_COMPARATOR comparator;

		protected Singleton( final KEY_TYPE key, final VALUE_TYPE value, KEY_COMPARATOR comparator ) {
			super( key, value );
			this.comparator = comparator;
		}

		protected Singleton( final KEY_TYPE key, final VALUE_TYPE value ) {
			this( key, value, null );
		}

		final int compare( final KEY_TYPE k1, final KEY_TYPE k2 ) {
			return comparator == null ? KEY_CMP( k1, k2 ) : comparator.compare( k1, k2 );
		}

		public Comparator comparator() { return comparator; } 

		public Set keySet() { if ( keys == null ) keys = SORTED_SETS.singleton( key, comparator ); return keys; }

		public STD_SORTED_MAP subMap( final KEY_TYPE from, final KEY_TYPE to ) { if ( compare( from, key ) <= 0 && compare( key, to ) < 0 ) return this; else return EMPTY_MAP; }
		public STD_SORTED_MAP headMap( final KEY_TYPE to ) { if ( compare( key, to ) < 0 ) return this; else return EMPTY_MAP; }
		public STD_SORTED_MAP tailMap( final KEY_TYPE from ) { if ( compare( from, key ) <= 0 ) return this; else return EMPTY_MAP; }

		public KEY_TYPE FIRST_KEY() { return key; }
		public KEY_TYPE LAST_KEY() { return key; }

#if ! #keyclass(Object) && ! #keyclass(Reference)
		public SortedMap headMap( Object oto ) { return headMap( KEY2TYPE( oto ) ); }
		public SortedMap tailMap( Object ofrom ) { return tailMap( KEY2TYPE( ofrom ) ); }
		public SortedMap subMap( Object ofrom, Object oto ) { return subMap( KEY2TYPE( ofrom ), KEY2TYPE( oto ) ); }

		public Object firstKey() { return KEY2OBJ( FIRST_KEY() ); }
		public Object lastKey() { return KEY2OBJ( LAST_KEY() ); }
#endif
	}

	/** Returns a type-specific immutable sorted map containing only the specified pair. The returned sorted map is serializable and cloneable.
	 *
	 * <P>Note that albeit the returned map is immutable, its default return value may be changed.
	 *
	 * @param key the only key of the returned sorted map.
	 * @param value the only value of the returned sorted map.
	 * @return a type-specific immutable sorted map containing just the pair <code>&lt;key,value></code>.
	 */

	public static SORTED_MAP singleton( final KEY_TYPE key, VALUE_TYPE value ) {
		return new Singleton( key, value );
	}

	/** Returns a type-specific immutable sorted map containing only the specified pair. The returned sorted map is serializable and cloneable.
	 *
	 * <P>Note that albeit the returned map is immutable, its default return value may be changed.
	 *
	 * @param key the only key of the returned sorted map.
	 * @param value the only value of the returned sorted map.
	 * @param comparator the comparator to use in the returned sorted map.
	 * @return a type-specific immutable sorted map containing just the pair <code>&lt;key,value></code>.
	 */

	public static SORTED_MAP singleton( final KEY_TYPE key, VALUE_TYPE value, KEY_COMPARATOR comparator ) {
		return new Singleton( key, value, comparator );
	}

#if ( ! #keyclass( Object ) && ! #keyclass( Reference ) ) || ( ! #valueclass( Object ) && ! #valueclass( Reference ) )

	/** Returns a type-specific immutable sorted map containing only the specified pair. The returned sorted map is serializable and cloneable.
	 *
	 * <P>Note that albeit the returned map is immutable, its default return value may be changed.
	 *
	 * @param key the only key of the returned sorted map.
	 * @param value the only value of the returned sorted map.
	 * @return a type-specific immutable sorted map containing just the pair <code>&lt;key,value></code>.
	 */

	public static SORTED_MAP singleton( final Object key, final Object value ) {
		return new Singleton( KEY2TYPE( key ), VALUE2TYPE( value ) );
	}

	/** Returns a type-specific immutable sorted map containing only the specified pair. The returned sorted map is serializable and cloneable.
	 *
	 * <P>Note that albeit the returned map is immutable, its default return value may be changed.
	 *
	 * @param key the only key of the returned sorted map.
	 * @param value the only value of the returned sorted map.
	 * @param comparator the comparator to use in the returned sorted map.
	 * @return a type-specific immutable sorted map containing just the pair <code>&lt;key,value></code>.
	 */

	public static SORTED_MAP singleton( final Object key, final Object value, KEY_COMPARATOR comparator ) {
		return new Singleton( KEY2TYPE( key ), VALUE2TYPE( value ), comparator );
	}

#endif


		/** A synchronized wrapper class for sorted maps. */

	public static class SynchronizedSortedMap extends MAPS.SynchronizedMap implements SORTED_MAP, java.io.Serializable {

		public static final long serialVersionUID = -7046029254386353129L;

		protected final SORTED_MAP sortedMap;

		protected SynchronizedSortedMap( final SORTED_MAP m, final Object sync ) {
			super( m, sync );
			sortedMap = m;
		}

		protected SynchronizedSortedMap( final SORTED_MAP m ) {
			super( m );
			sortedMap = m;
		}

		public Comparator comparator() { synchronized( sync ) { return sortedMap.comparator(); } }

		public STD_SORTED_MAP subMap( final KEY_TYPE from, final KEY_TYPE to ) { return new SynchronizedSortedMap( (SORTED_MAP)sortedMap.subMap( from, to ), sync ); }
		public STD_SORTED_MAP headMap( final KEY_TYPE to ) { return new SynchronizedSortedMap( (SORTED_MAP)sortedMap.headMap( to ), sync ); }
		public STD_SORTED_MAP tailMap( final KEY_TYPE from ) { return new SynchronizedSortedMap( (SORTED_MAP)sortedMap.tailMap( from ), sync ); }

		public KEY_TYPE FIRST_KEY() {  synchronized( sync ) { return sortedMap.FIRST_KEY(); } }
		public KEY_TYPE LAST_KEY() {  synchronized( sync ) { return sortedMap.LAST_KEY(); } }

#if ! #keyclass(Object) && ! #keyclass(Reference)
		public Object firstKey() {  synchronized( sync ) { return sortedMap.firstKey(); } }
		public Object lastKey() {  synchronized( sync ) { return sortedMap.lastKey(); } }

		public SortedMap subMap( final Object from, final Object to ) { return new SynchronizedSortedMap( (SORTED_MAP)sortedMap.subMap( from, to ), sync ); }
		public SortedMap headMap( final Object to ) { return new SynchronizedSortedMap( (SORTED_MAP)sortedMap.headMap( to ), sync ); }
		public SortedMap tailMap( final Object from ) { return new SynchronizedSortedMap( (SORTED_MAP)sortedMap.tailMap( from ), sync ); }
#endif


	}

	/** Returns a synchronized type-specific sorted map backed by the given type-specific sorted map.
	 *
	 * @param m the sorted map to be wrapped in a synchronized sorted map.
	 * @return a synchronized view of the specified sorted map.
	 * @see java.util.Collections#synchronizedSortedMap(SortedMap)
	 */
	public static SORTED_MAP synchronize( final SORTED_MAP m ) { return new SynchronizedSortedMap( m ); }

	/** Returns a synchronized type-specific sorted map backed by the given type-specific sorted map, using an assigned object to synchronize.
	 *
	 * @param m the sorted map to be wrapped in a synchronized sorted map.
	 * @param sync an object that will be used to synchronize the access to the sorted sorted map.
	 * @return a synchronized view of the specified sorted map.
	 * @see java.util.Collections#synchronizedSortedMap(SortedMap)
	 */

	public static SORTED_MAP synchronize( final SORTED_MAP m, final Object sync ) { return new SynchronizedSortedMap( m, sync ); }






	/** An unmodifiable wrapper class for sorted maps. */

	public static class UnmodifiableSortedMap extends MAPS.UnmodifiableMap implements SORTED_MAP, java.io.Serializable {

		public static final long serialVersionUID = -7046029254386353129L;

		protected final SORTED_MAP sortedMap;

		protected UnmodifiableSortedMap( final SORTED_MAP m ) {
			super( m );
			sortedMap = m;
		}

		public Comparator comparator() { return sortedMap.comparator(); }

		public STD_SORTED_MAP subMap( final KEY_TYPE from, final KEY_TYPE to ) { return new UnmodifiableSortedMap( (SORTED_MAP)sortedMap.subMap( from, to ) ); }
		public STD_SORTED_MAP headMap( final KEY_TYPE to ) { return new UnmodifiableSortedMap( (SORTED_MAP)sortedMap.headMap( to ) ); }
		public STD_SORTED_MAP tailMap( final KEY_TYPE from ) { return new UnmodifiableSortedMap( (SORTED_MAP)sortedMap.tailMap( from ) ); }

		public KEY_TYPE FIRST_KEY() {  return sortedMap.FIRST_KEY(); }
		public KEY_TYPE LAST_KEY() {  return sortedMap.LAST_KEY(); }

#if ! #keyclass(Object) && ! #keyclass(Reference)
		public Object firstKey() {  return sortedMap.firstKey(); }
		public Object lastKey() {  return sortedMap.lastKey(); }

		public SortedMap subMap( final Object from, final Object to ) { return new UnmodifiableSortedMap( (SORTED_MAP)sortedMap.subMap( from, to ) ); }
		public SortedMap headMap( final Object to ) { return new UnmodifiableSortedMap( (SORTED_MAP)sortedMap.headMap( to ) ); }
		public SortedMap tailMap( final Object from ) { return new UnmodifiableSortedMap( (SORTED_MAP)sortedMap.tailMap( from ) ); }
#endif


	}

	/** Returns an unmodifiable type-specific sorted map backed by the given type-specific sorted map.
	 *
	 * @param m the sorted map to be wrapped in an unmodifiable sorted map.
	 * @return an unmodifiable view of the specified sorted map.
	 * @see java.util.Collections#unmodifiableSortedMap(SortedMap)
	 */
	public static SORTED_MAP unmodifiable( final SORTED_MAP m ) { return new UnmodifiableSortedMap( m ); }



#if defined(TEST) && ! #keyclass(Reference)

	private static long seed = System.currentTimeMillis(); 
	private static java.util.Random r = new java.util.Random( seed );

	private static KEY_TYPE genKey() {
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
		return (KEY_TYPE)(r.nextInt());
#elif !#keyclass(Object) && !#keyclass(Reference)
		return r.NEXT_KEY(); 
#else
		return Integer.toBinaryString( r.nextInt() );
#endif
	}

	private static VALUE_TYPE genValue() {
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
		return (VALUE_TYPE)(r.nextInt());
#elif !#valueclass(Object) && !#valueclass(Reference)
		return r.NEXT_VALUE();
#elif !#valueclass(Reference) || #keyclass(Reference)
		return Integer.toBinaryString( r.nextInt() );
#else
		return new java.io.Serializable() {};
#endif
	}


	private static java.text.NumberFormat format = new java.text.DecimalFormat( "#,###.00" );
	private static java.text.FieldPosition p = new java.text.FieldPosition( 0 );

	private static String format( double d ) {
		StringBuffer s = new StringBuffer();
		return format.format( d, s, p ).toString();
	}

	private static void speedTest( int n, boolean comp ) {
		System.out.println( "There are presently no speed tests for this class." );
	}


	private static boolean valEquals(Object o1, Object o2) {
		return o1 == null ? o2 == null : o1.equals(o2);
	}

	private static void fatal( String msg ) {
		System.out.println( msg );
		System.exit( 1 );
	}

	private static void ensure( boolean cond, String msg ) {
		if ( cond ) return;
		fatal( msg );
	}

	private static Object[] k, v, nk;
	private static KEY_TYPE kt[];
	private static KEY_TYPE nkt[];
	private static VALUE_TYPE vt[];
	private static SORTED_MAP topMap;

	protected static void testMaps( SORTED_MAP m, SortedMap t, int n, int level ) {
		long ms;
		boolean mThrowsIllegal, tThrowsIllegal, mThrowsNoElement, tThrowsNoElement, mThrowsUnsupp, tThrowsUnsupp;
		Object rt = null, rm = null;

		if ( level > 1 ) return;
				

		/* Now we check that both maps agree on first/last keys. */

		mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		try {
			m.firstKey();
		}
		catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		try {
			t.firstKey();
		}
		catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): firstKey() divergence at start in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
		if ( ! mThrowsNoElement ) ensure( t.firstKey().equals( m.firstKey() ), "Error (" + level + ", " + seed + "): m and t differ at start on their first key (" + m.firstKey() + ", " + t.firstKey() +")" );

		mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		try {
			m.lastKey();
		}
		catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		try {
			t.lastKey();
		}
		catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): lastKey() divergence at start in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );


		if ( ! mThrowsNoElement ) ensure( t.lastKey().equals( m.lastKey() ), "Error (" + level + ", " + seed + "): m and t differ at start on their last key (" + m.lastKey() + ", " + t.lastKey() +")");


		/* Now we check that m and t are equal. */
		if ( !m.equals( t ) || ! t.equals( m ) ) System.err.println("m: " + m + " t: " + t);

		ensure( m.equals( t ), "Error (" + level + ", " + seed + "): ! m.equals( t ) at start" );
		ensure( t.equals( m ), "Error (" + level + ", " + seed + "): ! t.equals( m ) at start" );



		/* Now we check that m actually holds that data. */
		for(Iterator i=t.entrySet().iterator(); i.hasNext();  ) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			ensure( valEquals(e.getValue(), m.get(e.getKey())), "Error (" + level + ", " + seed + "): m and t differ on an entry ("+e+") after insertion (iterating on t)" );
		}

		/* Now we check that m actually holds that data, but iterating on m. */
		for(Iterator i=m.entrySet().iterator(); i.hasNext();  ) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			ensure( valEquals(e.getValue(), t.get(e.getKey())), "Error (" + level + ", " + seed + "): m and t differ on an entry ("+e+") after insertion (iterating on m)" );
		}

		/* Now we check that m actually holds the same keys. */
		for(Iterator i=t.keySet().iterator(); i.hasNext();  ) {
			Object o = i.next();
			ensure( m.containsKey(o), "Error (" + level + ", " + seed + "): m and t differ on a key ("+o+") after insertion (iterating on t)" );
			ensure( m.keySet().contains(o), "Error (" + level + ", " + seed + "): m and t differ on a key ("+o+", in keySet()) after insertion (iterating on t)" );
		}

		/* Now we check that m actually holds the same keys, but iterating on m. */
		for(Iterator i=m.keySet().iterator(); i.hasNext();  ) {
			Object o = i.next();
			ensure( t.containsKey(o), "Error (" + level + ", " + seed + "): m and t differ on a key after insertion (iterating on m)" );
			ensure( t.keySet().contains(o), "Error (" + level + ", " + seed + "): m and t differ on a key (in keySet()) after insertion (iterating on m)" );
		}


		/* Now we check that m actually hold the same values. */
		for(Iterator i=t.values().iterator(); i.hasNext();  ) {
			Object o = i.next();
			ensure( m.containsValue(o), "Error (" + level + ", " + seed + "): m and t differ on a value after insertion (iterating on t)" );
			ensure( m.values().contains(o), "Error (" + level + ", " + seed + "): m and t differ on a value (in values()) after insertion (iterating on t)" );
		}

		/* Now we check that m actually hold the same values, but iterating on m. */
		for(Iterator i=m.values().iterator(); i.hasNext();  ) {
			Object o = i.next();
			ensure( t.containsValue(o), "Error (" + level + ", " + seed + "): m and t differ on a value after insertion (iterating on m)");
			ensure( t.values().contains(o), "Error (" + level + ", " + seed + "): m and t differ on a value (in values()) after insertion (iterating on m)");
		}

		/* Now we check that inquiries about random data give the same answer in m and t. For
		   m we use the polymorphic method. */

		for(int i=0; i<n;  i++ ) {
			KEY_TYPE T = genKey();
				
			mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;

			try {
				m.containsKey(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }

			try {
				t.containsKey(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }

			ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): containsKey() divergence in NoSuchElementException (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
			ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): containsKey() divergence in IllegalArgumentException (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
			if ( !mThrowsNoElement && !mThrowsIllegal ) {
				ensure( m.containsKey(KEY2OBJ(T)) == t.containsKey(KEY2OBJ(T)), "Error (" + level + ", " + seed + "): divergence in keys between t and m (polymorphic method)" );
					 
#if #keyclass(Object) && ! ( #valueclass(Object) || #valueclass(Reference) )
				if ((m.GET_VALUE(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) || 
					t.get(KEY2OBJ(T)) != null && 
					! VALUE2OBJ(m.GET_VALUE(T)).equals(t.get(KEY2OBJ(T)))) 
#else
					if ((m.get(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) || 
						t.get(KEY2OBJ(T)) != null && 
						! m.get(KEY2OBJ(T)).equals(t.get(KEY2OBJ(T)))) 
#endif
						{
							System.out.println("Error (" + level + ", " + seed + "): divergence between t and m (polymorphic method)");
							System.exit( 1 );
						}
			}
		}

		/* Again, we check that inquiries about random data give the same answer in m and t, but
		   for m we use the standard method. */

		for(int i=0; i<n;  i++ ) {
			KEY_TYPE T = genKey();

			mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;

			try {
				m.get(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }

			try {
				t.get(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }

			ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): get() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
			ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): get() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
			if ( !mThrowsNoElement && !mThrowsIllegal ) ensure( valEquals(m.get(KEY2OBJ(T)), t.get(KEY2OBJ(T))), "Error (" + level + ", " + seed + "): divergence between t and m (standard method)" );
		}

		/* Now we put and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++ ) {
			KEY_TYPE T = genKey();
			VALUE_TYPE U = genValue();

			mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.put(KEY2OBJ(T), VALUE2OBJ(U));
			}
			catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }
			catch ( UnsupportedOperationException e ) { mThrowsUnsupp = true; }

			try {
				rt = t.put(KEY2OBJ(T), VALUE2OBJ(U));
			}
			catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }
			catch ( UnsupportedOperationException e ) { tThrowsUnsupp = true; }

			ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): put() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
			ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): put() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
			ensure( mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): put() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m );
			if ( !mThrowsNoElement && !mThrowsIllegal && !mThrowsUnsupp ) ensure( valEquals( rm, rt ), "Error (" + level + ", " + seed + "): divergence in put() between t and m (" + rt + ", " + rm + ")" );

			T = genKey();

			mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.remove(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { mThrowsIllegal = true; }
			catch ( UnsupportedOperationException e ) { mThrowsUnsupp = true; }

			try {
				rt = t.remove(KEY2OBJ(T));
			}
			catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
			catch ( IllegalArgumentException e ) { tThrowsIllegal = true; }
			catch ( UnsupportedOperationException e ) { tThrowsUnsupp = true; }


			ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): remove() divergence in NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
			ensure( mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): remove() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ")" );
			ensure( mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): remove() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m );
			if ( !mThrowsNoElement && !mThrowsIllegal && !mThrowsUnsupp ) ensure( valEquals( rm, rt ), "Error (" + level + ", " + seed + "): divergence in remove() between t and m (" + rt + ", " + rm + ")" );
		}

		ensure( m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals( t ) after removal" );
		ensure( t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals( m ) after removal" );

		/* Now we check that m actually holds the same data. */
		  
		for(Iterator i=t.entrySet().iterator(); i.hasNext();  ) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			ensure( valEquals(e.getValue(), m.get(e.getKey())), "Error (" + level + ", " + seed + "): m and t differ on an entry ("+e+") after removal (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */
		  
		for(Iterator i=m.entrySet().iterator(); i.hasNext();  ) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			ensure( valEquals(e.getValue(), t.get(e.getKey())), "Error (" + level + ", " + seed + "): m and t differ on an entry ("+e+") after removal (iterating on m)" );
		}

		/* Now we check that m actually holds the same keys. */
		  
		for(Iterator i=t.keySet().iterator(); i.hasNext();  ) {
			Object o = i.next();
			ensure( m.containsKey(o), "Error (" + level + ", " + seed + "): m and t differ on a key ("+o+") after removal (iterating on t)");
			ensure( m.keySet().contains(o), "Error (" + level + ", " + seed + "): m and t differ on a key ("+o+", in keySet()) after removal (iterating on t)");
		}

		/* Now we check that m actually holds the same keys, but iterating on m. */
		  
		for(Iterator i=m.keySet().iterator(); i.hasNext();  ) {
			Object o = i.next();
			ensure( t.containsKey(o), "Error (" + level + ", " + seed + "): m and t differ on a key after removal (iterating on m)");
			ensure( t.keySet().contains(o), "Error (" + level + ", " + seed + "): m and t differ on a key (in keySet()) after removal (iterating on m)");
		}


		/* Now we check that m actually hold the same values. */
		  
		for(Iterator i=t.values().iterator(); i.hasNext();  ) {
			Object o = i.next();
			ensure( m.containsValue(o), "Error (" + level + ", " + seed + "): m and t differ on a value after removal (iterating on t)" );
			ensure( m.values().contains(o), "Error (" + level + ", " + seed + "): m and t differ on a value (in values()) after removal (iterating on t)");
		}

		/* Now we check that m actually hold the same values, but iterating on m. */
		  
		for(Iterator i=m.values().iterator(); i.hasNext();  ) {
			Object o = i.next();
			ensure( t.containsValue(o), "Error (" + level + ", " + seed + "): m and t differ on a value after removal (iterating on m)");
			ensure( t.values().contains(o), "Error (" + level + ", " + seed + "): m and t differ on a value (in values()) after removal (iterating on m)");
		}

		/* Now we check that both maps agree on first/last keys. */

		mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		try {
			m.firstKey();
		}
		catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		try {
			t.firstKey();
		}
		catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): firstKey() divergence in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );
		if ( ! mThrowsNoElement ) ensure( t.firstKey().equals( m.firstKey() ), "Error (" + level + ", " + seed + "): m and t differ on their first key (" + m.firstKey() + ", " + t.firstKey() +")" );

		mThrowsNoElement = mThrowsIllegal = tThrowsNoElement = tThrowsIllegal = false;
		  
		try {
			m.lastKey();
		}
		catch ( NoSuchElementException e ) { mThrowsNoElement = true; }
		try {
			t.lastKey();
		}
		catch ( NoSuchElementException e ) { tThrowsNoElement = true; }
		  
		ensure( mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): lastKey() divergence in NoSuchElementException  (" + mThrowsNoElement + ", " + tThrowsNoElement + ")" );

		if ( ! mThrowsNoElement ) ensure( t.lastKey().equals( m.lastKey() ), "Error (" + level + ", " + seed + "): m and t differ on their last key (" + m.lastKey() + ", " + t.lastKey() +")");

		/* Now we check cloning. */

		if ( level == 0 ) {
			ensure( m.equals( ((Singleton)m).clone() ), "Error (" + level + ", " + seed + "): m does not equal m.clone()" );
			ensure( ((Singleton)m).clone().equals( m ), "Error (" + level + ", " + seed + "): m.clone() does not equal m" );
			m = (SORTED_MAP)((Singleton)m).clone();
		}

		int h = m.hashCode();


		/* Now we save and read m. */

		SORTED_MAP m2 = null;
		  
		try {
			java.io.File ff = new java.io.File("it.unimi.dsi.fastutil.test");
			java.io.OutputStream os = new java.io.FileOutputStream(ff);
			java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);
				
			oos.writeObject(m);
			oos.close();
				
			java.io.InputStream is = new java.io.FileInputStream(ff);
			java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);
				
			m2 = (SORTED_MAP)ois.readObject();
			ois.close();
			ff.delete();
		}
		catch(Exception e) {
			e.printStackTrace();
			System.exit( 1 );
		}

#if !#valueclass(Reference)
		ensure( m2.hashCode() == h, "Error (" + level + ", " + seed + "): hashCode() changed after save/read" );
		  
		/* Now we check that m2 actually holds that data. */
		  
		ensure( m2.equals(t), "Error (" + level + ", " + seed + "): ! m2.equals( t ) after save/read" );
		ensure( t.equals(m2), "Error (" + level + ", " + seed + "): ! t.equals( m2 ) after save/read" );
		/* Now we take out of m everything, and check that it is empty. */
#endif
	  
		/* Now we play with iterators. */
		  
		{
			java.util.ListIterator i, j;
			Object J;
			i = (java.util.ListIterator)m.entrySet().iterator(); 
			j = new java.util.LinkedList( t.entrySet() ).listIterator(); 

			for( int k = 0; k < 2*n; k++ ) {
				ensure( i.hasNext() == j.hasNext(), "Error (" + level + ", " + seed + "): divergence in hasNext()" );
				ensure( i.hasPrevious() == j.hasPrevious(), "Error (" + level + ", " + seed + "): divergence in hasPrevious()" );

				if ( r.nextFloat() < .8 && i.hasNext() ) {
					ensure( ((java.util.Map.Entry)i.next()).getKey().equals( J = ((Map.Entry)j.next()).getKey() ), "Error (" + level + ", " + seed + "): divergence in next()" );

				}
				else if ( r.nextFloat() < .2 && i.hasPrevious() ) {
					ensure( ((java.util.Map.Entry)i.previous()).getKey().equals( J = ((Map.Entry)j.previous()).getKey() ), "Error (" + level + ", " + seed + "): divergence in previous()" );

				}

				ensure( i.nextIndex() == j.nextIndex(), "Error (" + level + ", " + seed + "): divergence in nextIndex()" );
				ensure( i.previousIndex() == j.previousIndex(), "Error (" + level + ", " + seed + "): divergence in previousIndex()" );

			}
		}

		{
			boolean badPrevious = false;
			Object previous = null;
			it.unimi.dsi.fastutil.BidirectionalIterator i;
			java.util.ListIterator j;
			Object I, J;
			KEY_TYPE from = genKey();
			j = new java.util.LinkedList( t.keySet() ).listIterator(); 
			while( j.hasNext() ) {
				Object k = j.next();
				if ( ((Comparable)k).compareTo( KEY2OBJ( from ) ) > 0 ) {
					badPrevious = true;
					j.previous();
					break;
				}
				previous = k;
			}

			i = (it.unimi.dsi.fastutil.BidirectionalIterator)((SORTED_SET)m.keySet()).iterator( from ); 

			for( int k = 0; k < 2*n; k++ ) {
				ensure( i.hasNext() == j.hasNext(), "Error (" + level + ", " + seed + "): divergence in hasNext() (iterator with starting point " + from + ")" );
				ensure( i.hasPrevious() == j.hasPrevious() || badPrevious && ( i.hasPrevious() == ( previous != null ) ), "Error (" + level + ", " + seed + "): divergence in hasPrevious() (iterator with starting point " + from + ")" + badPrevious );

				if ( r.nextFloat() < .8 && i.hasNext() ) {
					ensure( ( I = i.next() ).equals( J = j.next() ), "Error (" + level + ", " + seed + "): divergence in next() (" + I + ", " + J + ", iterator with starting point " + from + ")" );
					//System.err.println("Done next " + I + " " + J + "  " + badPrevious);

					badPrevious = false;

					if ( r.nextFloat() < 0.5 ) {
					}
				}
				else if ( !badPrevious && r.nextFloat() < .2 && i.hasPrevious() ) {
					ensure( ( I = i.previous() ).equals( J = j.previous() ), "Error (" + level + ", " + seed + "): divergence in previous() (" + I + ", " + J + ", iterator with starting point " + from + ")" );

					if ( r.nextFloat() < 0.5 ) {
					}
				}
			}

		}

		/* Now we check that m actually holds that data. */
		  
		ensure( m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals( t ) after iteration" );
		ensure( t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals( m ) after iteration" );

		/* Now we select a pair of keys and create a submap. */

		if ( ! m.isEmpty() ) {
			java.util.ListIterator i;
			Object start = m.firstKey(), end = m.firstKey();
			for( i = (java.util.ListIterator)m.keySet().iterator(); i.hasNext() && r.nextFloat() < .3; start = end = i.next() );
			for( ; i.hasNext() && r.nextFloat() < .95; end = i.next() );
				
			//System.err.println("Checking subMap from " + start + " to " + end + " (level=" + (level+1) + ")..." );
			testMaps( (SORTED_MAP)m.subMap( start, end ), t.subMap( start, end ), n, level + 1 );

			ensure( m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals( t ) after subMap" );
			ensure( t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals( m ) after subMap" );

			//System.err.println("Checking headMap to " + end + " (level=" + (level+1) + ")..." );
			testMaps( (SORTED_MAP)m.headMap( end ), t.headMap( end ), n, level + 1 );

			ensure( m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals( t ) after headMap" );
			ensure( t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals( m ) after headMap" );

			//System.err.println("Checking tailMap from " + start + " (level=" + (level+1) + ")..." );
			testMaps( (SORTED_MAP)m.tailMap( start ), t.tailMap( start ), n, level + 1 );

			ensure( m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals( t ) after tailMap" );
			ensure( t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals( m ) after tailMap" );
		}
		  

	}


	private static void test() {
		int n = 1;
		k = new Object[n];
		v = new Object[n];
		nk = new Object[n];
		kt = new KEY_TYPE[n];
		nkt = new KEY_TYPE[n];
		vt = new VALUE_TYPE[n];
			   

		for( int i = 0; i < n; i++ ) {
#if #keyclass(Object)
			k[i] = kt[i] = genKey();
			nk[i] = nkt[i] = genKey();
#else
			k[i] = new KEY_CLASS( kt[i] = genKey() );
			nk[i] = new KEY_CLASS( nkt[i] = genKey() );
#endif
#if #valueclass(Object) || #valueclass(Reference)
			v[i] = vt[i] = genValue();
#else
			v[i] = new VALUE_CLASS( vt[i] = genValue() );
#endif
		}
		  
		SORTED_MAP m = new Singleton( kt[0], vt[0] );
		topMap = m;
		SortedMap t1 = new java.util.TreeMap();
		t1.put( k[0], v[0] );
		SortedMap t = java.util.Collections.unmodifiableSortedMap( t1 );

		testMaps( m, t, n, 0 );

		System.out.println("Test OK");
		return;
	}


	public static void main( String args[] ) {
		if ( args.length > 1 ) r = new java.util.Random( seed = Long.parseLong( args[ 1 ] ) );
		  
		try {
			test();
		} catch( Throwable e ) {
			e.printStackTrace( System.err );
			System.err.println( "seed: " + seed );
		}
	}

#endif

	
}

// Local Variables:
// mode: jde
// tab-width: 4
// End:
