4.2 -> 4.2.1

- Removed about a dozen spurious final modifiers from methods.

- Made rehash() protected, so that everybody can play with different
  rehashing strategies.

- trim() in array lists wasn't doing the right thing, because trim(int)
  wasn't doing it in the first place. Now if n is smaller than the size
  of the list, we trim at the list size (previously we were doing nothing).

4.1 -> 4.2

- Improved array methods: now all methods on objects (e.g., grow()) return an
  array of the same type of the array that was passed to them, similarly to
  toArray() in collections.

- Fixed missing macro substitution for empty iterator methods. In any
  case, they were already deprecated.

4.0 -> 4.1

- New classes for custom hashing methods (mainly thought for
  arrays). Correspondingly, methods for arrays have been implemented in
  the static containers.

- BasicEntry now throws an UnsupportedOperationException on calls to
  setValue(). If you ever used that method, you got wierd results, as
  it does not update the underlying map. The method is now implemented
  correctly in open hash maps, in which previously did not correctly
  update the underying map.

- Reimplemented copy of an entire array using clone().

- Fixed a bug in clear() for indirect heaps (the inversion array was not
  being cleared).

- Indirect priority queue interfaces now feature an optional allChanged()
  method that can be used to force a complete heap rebuild. It is implemented by
  all current array-based and head-based concrete classes.

3.1 -> 4.0

- IMPORTANT: The optimized methods that a type-specific must provide now
  include an addElements() method that quickly adds an array of elements. As
  usual, the method is fully implemented by the type-specific abstract lists.

- IMPORTANT: The abstract generic version of get(), put() and remove() for maps
  with non-object keys or values now always return null to denote a missing
  key. They used to return an object-wrapped default return value.

- Completely new and comprehensive implementation of priority queues, both
  direct and indirect. Implementations are by heaps and by flat arrays. There
  are also static containers with all relevant heap methods, for people
  wanting to do their own thing.

- New static containers for comparators.

- All singletons, empty sets and snychronized wrappers are public so
  you can inherit from them.

- Abstract maps now provide keySet() and values() based on entrySet().

- New abstract classes for sorted sets and maps with delegators to
  type-specific methods.
	
- New public methods in Arrays and in type-specific Arrays classes for checking
  ranges.

- New static methods for type-specific arrays that allow to grow, enlarge
  and trim them with ease.

- Clarified abstract implementation of default return values, and implemented
  clarified specification. Just a couple of method in hash maps were not
  already compliant.

- The pour() method now returns a list. The previous version was returning
  a linked hash set, which was rather nonsensical anyway, since an iterator
  build on the returned set could have been different from the original iterator.
  You can always pour an iterator into a set by providing the set explicitly.

- An exception-throwing implementation of some methods in AbstractSet
  was missing. Same for AbstractCollection, AbstractMap and AbstractList.

- New basic inner entry class for abstract maps, which makes it easier to write
  entrySet() methods for classes that do not have their own entries.

- Added missing get(Object) method in AbstractMap (just delegates to
  the type-specific version).

- For lazy people, now containsKey() and containsValue() in AbstractMap
  are defined by looking into keySet() and values().

- Fixed a few methods of EMPTY_LIST which were throwing exception
  semantically (see the introduction).

- The interval iterators are now list iterators, except for longs.

- Fixed a bug in size() for array lists (reducing the size of an array
  would lead to an exception).

- Fixed double bug in hash tables: first of all, on very small sizes adding
  growthFactor would have left the size unchanged, giving rise to infinite
  loops. (Thanks to Heikki Uusitalo for reporting this bug.) Second, growthFactor
  was not being used *at all* by hash maps.

- Fixed entries emitted by singleton maps. Now they are type-specific.

- Fixed a number of minor glitches in gencsource.sh, and added some comments.

- HashCommon.removed has been renamed HashCommon.REMOVED.

- Boolean objects are now generated using valueOf() instead of the constructor.

- New type-specific wrappers for list iterators.

3.0 -> 3.1

- IMPORTANT: it.unimi.dsi.fastutil.Iterators methods have
  been spread in type-specific static containers.

- New Stack interface, implemented by type-specific lists.

- New static container classes Collections, Sets, and Lists.
  Presently they just provide empty containers.

- New type-specific static contains (e.g., IntSets) providing
  singletons and synchronized wrappers.

- Entry sets now have entries that are equal() to entries
  coming from corresponding maps in java.util.

- Spelling everywhere changed to Pure American. "synchronized" in code and
  "synchronise" in text side-by-side were looking really wierd...

3.0 -> 3.0.1

- New unwrap() methods for type-specific collections.

- Fixed old-as-world-bug, apparently wide but that evidently no one ever
  noticed: AbstractMap was not serialisable, and, as a result, the default
  return value was not serialised  (I find sincerely counterintuitive that
  making a class serialisable doesn't do the same for its supertypes). It
  wasn't ever even *documented* as preserved, so probably everyone thought
  this was my idea, too. Too bad this breaks once more serialisation
  compatibility. Since I had to break some serialisation anyway, I decided
  to eliminate the residual serialisation of p in hash table classes, too
  (which breaks serialisation for all hash-based classes).

2.60 -> 3.0

- IMPORTANT: All classes have been repackaged following the type of
  elements/keys. Sources will have to be retouched (just to change
  the import clause) and recompiled.
	
- IMPORTANT: Because of an unavoidable name clash in the new type-specific list
  interface, the method remove(int) of IntCollection has been renamed rem(int).
  The only really unpleasant effect is that you must use rem(int) on variables of
  type IntCollection that are not of type IntSet (as IntSet reinstates
  remove(int) in its right place)--for instance, IntList.

- Brand-new implementation of type-specific lists, with all the features you'd
  expect and more.

- Insertions for readObject() in hash tables are now handled in a special way
  (20% faster).

- Implemented linear-time tree reconstruction for readObject() (in practice, more
  than twice faster).

- Fixed a problem with serialisation of hash tables: the table would have
  been reloaded with the same p, even if it was preposterous. We still
  save p, however, to avoid breaking serialisation compatibility.

- Fixed missing implementation of type-specific sets, which should
  have extended type-specific collections, but they weren't.

- The default return value is now protected.

- New family of pour() methods that pour an iterator into a set.

- New programmable growth factor for hash-table-based classes.

- Eliminated a few useless method calls in tree map.

- Wide range of complex assertions, which are compiled in or out using the
  "private static final boolean" idiom.

- For references we now use System.identityHashCode(); this shouldn't change
  much, but it seems definitely more sensible.

- Fixed major bug in subSet()/subMap(): creating a subMap of a tailMap (or
  headMap) a right extreme (left, resp.) equal to 0 would have caused the
  creation of a tailMap (or headMap, resp.), discarding the extreme. Very,
  very unlikely, but it happened in a test.

- Fixed small bug in standard remove() method of submaps, which would have
  returned a default return value wrapped in a suitable object instead of
  null on non-existing keys.

2.52 -> 2.60

- IMPORTANT: Major overhaul of iterators. Now iterators must be skippable,
  so previous implementation of type-specific iterator interfaces will
  not work. However, new abstract classes allow to build iterator with ease
  by providing for free the skipping logic, and many useful static methods in
  Iterators allow to generate type-specific iterators wrapping standard
  iterators, arrays, etc.

- Better strategy for clear() on hash tables: we don't do anything only
  if all entries are free (which means that an empty table with deleted
  entry will be cleared).

2.51 -> 2.52

- IMPORTANT: The package name has changed to it.unimi.dsi.fastutil to be
  uniform with JPackage conventions. However, this means that you must manually
  erase the old one and update your sources.

- clear() doesn't do anything on empty hash tables.

2.50 -> 2.51
- New trim(int) method to reduce a hash table size avoiding to
  make it too small.

- serialVersionUID is now fixed, to avoid future incompatibilities.

2.11 -> 2.50

- IMPORTANT: The Collection interface now prescribes an iterator
  method with a type-specific name (e.g., intIterator()) that
  returns directly a type-specific iterator.

- New Reference maps and sets that allow to store more quickly
  canonised objects.

- New linked maps mimicking java.util's, but with a boatload
  of additional features.

- Small bug fix: the get(Object) method would return null
  instead of the default return value for maps with object
  keys.

- Major bug fix: iterating backwards on submaps was leading
  to unpredictable results.

- Major bug fix: cloning maps would have caused inconsistent behaviour.

- Major code redistribution: now whenever possible wrappers 
  belong to abstract superclasses.

2.1 -> 2.11

- Now we cache the hash of an object before entering
  the hash table loop.

2.0 -> 2.1

- A simple optimisation in hash-table inner loops has given
  quite a performance boost under certain conditions (we do
  not compute the secondary hashing if it is not necessary). Inspired
  by Gnu Trove.
- The trim() method would have in fact trimmed nothing, just
  rehashed the table.
- The computed maxFill value was sligtly too small.
- Also tree sets now have constructors from arrays.
- More internal methods have been made final.

1.3 -> 2.0

- ALL MAPS AND SETS HAVE NEW NAMES DEPENDING ON THE IMPLEMENTATION.
- Introducing new high-performance, low memory-footprint implementation of
  SortedMap and SortedSet.
- Two tree implementations are available: RB trees and
  AVL trees. Both implementations are threaded. See the README.
- Fixed a bug in hashCode() and contains() for HashMap.drv (it was
  considering keys only!).
- Fixed a bug in contains() for entrySet() in all maps (it was using
  VALUE_EQUAL to test equality for values given as objects).
- I realised that a default return value can be useful also for maps and sets
  returning objects, so now you have it. It is even independent for submaps and
  subsets.
- Classes are no longer final. The performance gain is around 1%, and
  the decrease in usefulness is orders of magnitudes greater.
- We now check equality using first hashCode() and then equals().
- The tests for speed now warm up the trees by doing repeated insertions
  and deletions, so that the benefits of a better balancing criterion
  are more evident.
- The regression tests are much more stringent.
- Fixed hashCode() for hash maps (wasn't conforming to the Map interface
  specification).
- Implemented linear cloning for tree classes.
