/*		 
 * fastUtil 2.0: Fast & compact specialized utility classes for Java
 *
 * Copyright (C) 2002 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package it.unimi.dsi.fastUtil;

import java.util.*;
import java.io.*;

/** A type-specific tree map with a very fast, small-footprint implementation.
 */

public final class TREEMAP extends ABSTRACT_MAP implements Serializable, SORTEDMAP {

	 /** A reference to the root entry. */
	 public transient Entry tree;

	 /** Number of entries in the map. */
	 private int count;

	 /** The first key in this map. */
	 private transient Entry firstEntry;

	 /** The last key in this map. */
	 private transient Entry lastEntry;

	 /** Cached set of entries and keys. */
	 private transient volatile Set entries, keys;

	 /** Cached collection of values. */
	 private transient volatile Collection values;

	 private transient KEY_TYPE key;
	 private transient VALUE_TYPE value;

	 /** The value of this variable remembers, after an <code>insert()</code> 
	  * or a <code>delete()</code>, whether the <em>domain</em> of the map
	  * has been modified. */
	 private transient boolean modified;

	 /** The value of this variable remembers, after an <code>insert()</code> 
	  * or a <code>delete()</code>, the entry that during the operation we
	  * possibly created or removed. */
	 private transient Entry change;

	 /** The value of this variable remembers, after a <code>delete()</code>,
	  * the entry that during the operation was deleted. Note that 
	  * if {@link #change} != {@link deleted}, then this entry is still in the
	  * map, but it contains the key and value previously stored in {@link #change}. */
	 private transient Entry deleted;

	 /** The value of this variable remembers, after an <code>insert()</code> 
	  * or a <code>delete()</code>, the value previously associated to the
	  * given key, if any. */
	 private transient VALUE_TYPE oldValue;

	 /** This map's comparator, as provided in the constructor. */
	 private Comparator storedComparator;

	 /** This map's actual comparator; it may differ from {@link #storedComparator} because it is
		  always a type-specific comparator, so it could be derived from the former by wrapping. */
	 private transient KEY_COMPARATOR actualComparator;

	 /** A fake {@link Entry} that is used as a result of the {@link Entry#left()} and
	  * {@link Entry#right()} methods to denote the empty subtree. It has the big advantage
	  * of having dereferenceable left/right pointers and a level that is smaller 
	  * than that of any node. */
	 private static Entry sentinel = new Entry();


	 /** Creates a new empty tree map. 
	  */

	 public TREEMAP() {
		  tree = null;
		  count = 0;
	 }

	 /** Generates the comparator that will be actually used.
	  *
	  * <P>When a specific {@link Comparator} is specified and stored in {@link
	  * #storedComparator}, we must check whether it is type-specific.  If it is
	  * so, we can used directly, and we store it in {@link #actualComparator}. Otherwise,
	  * we generate on-the-fly an anonymous class that wraps the non-specific {@link Comparator}
	  * and makes it into a type-specific one.
	  */
	 private void setActualComparator() {
#if #keyclass(Object)
		  actualComparator = storedComparator;
#else
		  /* If the provided comparator is already type-specific, we use it. Otherwise,
			  we use a wrapper anonymous class to fake that it is type-specific. */
		  if ( storedComparator == null || storedComparator instanceof KEY_COMPARATOR ) actualComparator = (KEY_COMPARATOR)storedComparator;
		  else actualComparator =	new KEY_COMPARATOR() {
				public int compare( KEY_TYPE k1, KEY_TYPE k2 ) {
					 return storedComparator.compare( KEY2OBJ( k1 ), KEY2OBJ( k2 ) );
				}
				public int compare( Object ok1, Object ok2 ) {
					 return storedComparator.compare( ok1, ok2 );
				}
		  };
#endif
	 }
	 

	 /** Creates a new empty tree map with the given comparator.
	  *
	  * @param comparator a {@link #Comparator}.
	  */

	 public TREEMAP( final Comparator c ) {
		  this();
		  storedComparator = c;
		  setActualComparator();
	 }


	 /** Creates a new tree map copying a given map.
	  *
	  * @param m a {@link Map} to be copied into the new tree map. 
	  */
	 
	 public TREEMAP( Map m ) {
		  this();
		  putAll( m );
	 }

	 /** Creates a new tree map copying a given sorted map (and its {@link Comparator}).
	  *
	  * @param m a {@link SortedMap} to be copied into the new tree map. 
	  */
	 
	 public TREEMAP( SortedMap m ) {
		  this( m.comparator() );
		  putAll( m );
	 }

	 /*
	  * The following private methods implements some basic building blocks used by
	  * all accessors.  They are (and should be maintained) identical to those used in TreeSet.drv.
	  */



	 /** Compares two keys in the right way. 
	  *
	  * @param k1 the first key.
	  * @param k2 the second key.
	  * @return a number smaller than, equal to or greater than 0, as usual
	  * (i.e., when k1 &lt; k2, k1 = k2 or k1 &gt; k2, respectively).
	  */
	 
    protected int compare( KEY_TYPE k1, KEY_TYPE k2 ) {
		  return actualComparator == null ? KEY_CMP( k1, k2 ) : actualComparator.compare( k1, k2 );
    }



	 /** Returns the entry corresponding to the given key, if it is in the tree; <code>null</code>, otherwise.
	  *
	  * @param k the key to search for.
	  * @return the corresponding entry, or <code>null</code> if no entry with the given key exists.
	  */

   private Entry findKey( KEY_TYPE k ) {
		 Entry e = tree == null ? sentinel : tree;
		 int cmp;
		 
		 while ( e != sentinel && ( cmp = compare( k, e.key ) ) != 0 ) 
			  e = cmp < 0 ? e.left() : e.right();
		 
		 return e == sentinel ? null : e;
   }

	 /** The value of this variable remembers during an <code>insert()</code> 
	  * whether we ever turned left. */
	 private transient boolean turnedLeft;

	 /** The value of this variable remembers during an <code>insert()</code> 
	  * whether we ever turned right. */
	 private transient boolean turnedRight;


	 /** Inserts a new pair in the map.
	  *
	  * <P>After execution of this method, {@link #modified} is true iff a new
	  * entry has been inserted. Otherwise, {@link #oldValue} contains the value
	  * previously associated with the key.
	  *
	  * @param k a key.
	  * @param v a value.
	  * @return the previous value associated to the key (or the default return value, if there 
	  * was no existing entry with the same key).
	  */

	 
	 private VALUE_TYPE insert( final KEY_TYPE k, final VALUE_TYPE v ) {
		  oldValue = defRetValue; // This will hold the old value.
		  change = null; // This will hold the new entry.
		  modified = turnedLeft = turnedRight = false;
		  key = k;
		  value = v;

		  if ( tree == null ) { // The case of the empty tree is treated separately.
				count++;
				tree = change = new Entry( k, v );
				modified = true;
		  }
		  else tree = insertRec( tree );

		  if ( modified ) { // We update last/first if we actually changed the map domain.
				if ( ! turnedLeft ) lastEntry = change;
				if ( ! turnedRight ) firstEntry = change;
		  }

		  // We null everything to avoid residual references.
		  change = null;
#if #keyclass(Object)
		  key = null;
#endif
#if #valueclass(Object)
		  value = null;
#endif
		  return oldValue;
	 }


	 /** Inserts recursively a given pair in a nonempty tree.
	  *
	  * <P>After execution of this method, {@link #modified} is true iff
	  * a new entry has been inserted. Otherwise, {@link #oldValue} contains the value previously
	  * associated with the key. Moreover, {@link #turnedRight} if true iff we
	  * turned right during the search; analogously for {@link #turnedLeft}.
	  *
	  * @param e a tree (i.e., an {@link Entry}).
	  * @return the new tree, that is, the {@link Entry} that is now at the top of the tree.
	  */

   private Entry insertRec( Entry e ) {

		 final int cmp = compare( key, e.key );
		 
		 if ( cmp < 0 ) {
			  turnedLeft = true;
			  if ( e.left() != sentinel ) e.left = insertRec( e.left );
			  else {
					/* <P>This method we create a new {@link Entry} (marked as a leaf) and
					 * link it at the left of <code>e</code>. The {@link Entry#right} pointer
					 * of the new entry is <code>e</code>, whereas its {@link Entry#left} pointer
					 * is the {@link Entry#left} pointer of <code>e</code>. */
					count++;
					final Entry l = change = new Entry( key, value );
					
					modified = true;
					
					l.right = e;
					l.left = e.left;
					
					e.pred( false );
					e.left = l;
			  }

			  if ( ! modified ) return e; // Fast exit.
		 } 
		 else if ( cmp > 0 ) {
			  turnedRight = true;
			  if ( e.right() != sentinel ) e.right = insertRec( e.right );
			  else {
					/* <P>We create a new {@link Entry} (marked as a leaf) and
					 * link it at the right of <code>e</code>. The {@link Entry#left} pointer
					 * of the new entry is <code>e</code>, whereas its {@link Entry#right} pointer
					 * is the {@link Entry#right} pointer of <code>e</code>. */
					count++;
					final Entry r = change = new Entry( key, value );
					
					modified = true;
					
					r.left = e;
					r.right = e.right;
					
					e.succ( false );
					e.right = r;
			  }

			  if ( ! modified ) return e; // Fast exit.
		 }
		 else {
			  oldValue = e.value;
			  e.value = value;
			  return e;
		 }

		 e = e.skew();
		 e = e.split();

		 return e;
   }
	 
	 
	 /** Deletes an entry from the map.
	  *
	  * <P>After execution of this method, {@link #modified} is true iff an 
	  * entry has been deleted. In this case, {@link #oldValue} contains the value
	  * previously associated with the key.
	  *
	  * @param k a key.
	  * @return the value previously associated to the key (or the default return value, if there 
	  * was no existing entry with the given key).
	  */
	 
	 private VALUE_TYPE delete( final KEY_TYPE k ) {
		  oldValue = defRetValue;
		  change = deleted = null;
		  modified = false;
		  key = k;

		  if ( tree == null ) return defRetValue;

		  tree = deleteRec( null, tree );

#if #keyclass(Object)
		  key = null;
#endif

		  return oldValue;
	 }

	 /** Deletes recursively an entry from a tree.
	  *
	  * <P>After execution of this method, {@link #modified} is true iff an 
	  * entry has been deleted. In this case, {@link #oldValue} contains the value
	  * previously associated with the key.
	  *
	  * @param p the parent of the second argument (i.e., an {@link Entry}.
	  * @param e a tree (i.e., an {@link Entry}.
	  * @return the new tree, that is, the {@link Entry} that is now at the top of the tree.
	  */

	 private Entry deleteRec( Entry p, Entry e ) {
		  change = e;

		  if ( compare( key, e.key ) < 0 ) {
				if ( e.left() != sentinel ) {
					 e.left = deleteRec( e, e.left );
					 if ( e.left == e ) { // This handles the case of e.left being now a predecessor.
						  e.pred( true );
						  e.left = e == firstEntry ? null : p;
					 }
				}
		  }
		  else  {
				deleted = e;
				if ( e.right() != sentinel ) e.right = deleteRec( e, e.right );
		  }
				
		  if ( e == change && deleted != null && key == deleted.key ) {

				oldValue = deleted.value;
				deleted.key = e.key;
				deleted.value = e.value;

				modified = true;
				//deleted = null;
				count--;

				if ( p != null ) {
					 if ( p.right == e ) {
						  if ( e.succ() ) p.succ( true );  // This handles the case of e being a leaf to the right of p.
						  else if ( e.right.pred() ) e.right.left = p; // This handles the case of e being a right subtree and e.right a leaf.
					 }
					 else if ( e.right() != sentinel && e.right.pred() ) e.right.left = e.left; // This handles the case of e being a left subtree of p with a right leaf.
				}

				// If we are deleting the first or last entry, we must update our state accordingly.
				if ( e.right == null ) lastEntry = e.left;
				if ( e.left == null ) firstEntry = e.right;

				return e.right;
		  }

		  if ( e.left().level() < e.level() - 1 || e.right().level() < e.level() - 1 ) {
				e.decLevel();
				if ( e.right().level() > e.level() ) e.right().level( e.level() );
				e = e.skew();
				if ( e.right() != sentinel ) e.right = e.right.skew();
				if ( e.right().right() != sentinel ) e.right.right = e.right.right.skew();
				e = e.split();
				if ( e.right() != sentinel ) e.right = e.right.split();
		  }

		  return e;
	 }
	 

	private boolean searchRef( Entry e, Entry s ) {
		 if ( e.right == s ) { System.err.println("Got right reference to " + s + " in " + e); return true; }
		 if ( e.left == s ) { System.err.println("Got left reference to " + s + " in " + e); return true; }
		 if ( ! e.pred() && searchRef( e.left, s ) ) return true;
		 if ( ! e.succ() && searchRef( e.right, s ) ) return true;
		 return false;
	 }
	 
	 public Object put( final Object ok, final Object ov ) {
		  insert( KEY2TYPE(ok), VALUE2TYPE(ov) );
		  return ! modified ? VALUE2OBJ( oldValue ) : null;
	 }


#if ! ( #valueclass(Object) && #keyclass(Object) )
	 public VALUE_TYPE put(final KEY_TYPE k, final VALUE_TYPE v) {
		  return insert( k, v );
	 }
#endif

   public Object remove(final Object ok) {
		 if ( ok == null ) throw new IllegalArgumentException();
		 delete( KEY2TYPE( ok ) );
		 deleted = change = null;
		 return modified ? VALUE2OBJ( oldValue ) : null;
   }

#if ! #valueclass(Object) 
	 
	 public boolean containsValue(final Object v) {
		  return containsValue( VALUE2TYPE( v ) );
	 }

#endif

	 public boolean containsValue(final VALUE_TYPE v) {
		  final TreeIterator i = new TreeIterator();
		  VALUE_TYPE ev;
		  
		  while( i.hasNext() ) {
				ev = ((Entry)i.next()).value;
				if ( VALUE_EQUAL( ev, v ) ) return true;
		  }
		  
		  return false;
	 }


	 public void clear() {
		  count = 0;
		  tree = null;
		  entries = null;
		  values = null;
		  keys = null;
		  firstEntry = lastEntry = null;
	 }

	 
	 /** This class represent an entry in a tree map.
	  *
	  * <P>Note that since the class is recursive, it can be
	  * considered equivalently a tree.
	  */

    private static final class Entry implements MAP.Entry {

		  final static int SUCC_MASK = 1 << 31;
		  final static int PRED_MASK = 1 << 30;
		  final static int LEVEL_MASK = ~( SUCC_MASK | PRED_MASK );

		  KEY_TYPE key;
		  VALUE_TYPE value;

		  Entry left, right;
		  int mix;

		  Entry() {}

		  Entry( Object k, Object v ) {
				this.key = KEY2TYPE( k );
				this.value = VALUE2TYPE( v );
				mix = 1 | SUCC_MASK | PRED_MASK;
		  }

#if ! #keyclass(Object) || ! #valueclass(Object) 
		  
		  Entry( KEY_TYPE k, VALUE_TYPE v ) {
				this.key = k;
				this.value = v;
				mix = 1 | SUCC_MASK | PRED_MASK;
		  }
		  
#endif

		  public Entry left() {
				if ( ( mix & PRED_MASK ) != 0 || left == null ) return TREEMAP.sentinel;
				else return left;
		  }
		  
		  public Entry right() {
				if ( ( mix & SUCC_MASK ) != 0 || right == null ) return TREEMAP.sentinel;
				else return right;
		  }
		  

		  public boolean pred() {
				return ( mix & PRED_MASK ) != 0;
		  }
		  
		  public boolean succ() {
				return ( mix & SUCC_MASK ) != 0;
		  }
		  
		  public void pred( boolean pred ) {
				if ( pred ) mix |= PRED_MASK;
				else mix &= ~PRED_MASK;
		  }
		  
		  public void succ( boolean succ ) {
				if ( succ ) mix |= SUCC_MASK;
				else mix &= ~SUCC_MASK;
		  }
		  
		  public int level() {
				return mix & LEVEL_MASK ;
		  }

		  public void level( int level ) {
				mix &= ~LEVEL_MASK;
				mix |= level;
		  }

		  public void incLevel() {
				mix++;
		  }
		  
		  public void decLevel() {
				mix--;
		  }
		  
		  public Object getKey() {
				return KEY2OBJ(key);
		  }
		  
#if ! #keyclass(Object)
		  public KEY_TYPE ENTRY_GET_KEY() {
				return key;
		  }
#endif
		  
		  public Object getValue() {
				return VALUE2OBJ(value);
		  }
		  
#if ! #valueclass(Object)
		  public VALUE_TYPE ENTRY_GET_VALUE() {
				return value;
		  }
#endif
		  
		  public VALUE_TYPE setValue(final VALUE_TYPE value) {
				final VALUE_TYPE oldValue = this.value;
				this.value = value;
				return oldValue;
		  }
		  
#if ! #valueclass(Object)
		  
		  public Object setValue(final Object value) {
				return VALUE2OBJ(setValue(VALUE2TYPE(value)));
		  }
		  
#endif
		  
		  public boolean equals(Object o) {
				if (!(o instanceof Entry)) return false;
				Entry e = (Entry)o;
				
				return KEY_EQUAL(key, e.key) && VALUE_EQUAL(value, e.value);
		  }
		  
		  public int hashCode() {
				return KEY2INT(key) ^ VALUE2INT(value);
		  }
		  
		  
		  public String toString() {
				return key + "=>" + value;
		  }
		  

		  /** Splits this tree.
			*/
		  Entry split() {
				if ( this != sentinel && right().right().level() == level() ) {
					 /* Firstly, we save the current right pointer. */
					 final Entry t = right;
					 
					 /* Then, if our right subtree contains a predecessor, we set the
						 subtree as our successor. */
					 if ( ! t.pred() ) right = t.left;
					 
					 succ( t.pred() );
					 
					 t.left = this;
					 t.pred( false );
					 t.incLevel();
					 
					 return t;
				}
				return this;
		  }
		  
		  /** Skews to this tree.
			*/
		  Entry skew() {
				if ( this != sentinel && left().level() == level() ) {
					 /* Firstly, we save the current left pointer. */
					 final Entry t = left;
					 
					 /* Then, if our left subtree contains a successor, we set the
						 subtree as our predecessor. */
					 if ( ! t.succ() ) left = t.right;
					 
					 pred( t.succ() );
					 
					 t.right = this;
					 t.succ( false );
					 
					 return t;
				}
				return this;
		  }
		  
		  public void printDebug() {
				printDebug(0);
		  }

		  public void printDebug(int level) {
				if ( pred() ) {
					 for (int i = 0; i < level; i++)
						  System.err.print("  ");
					 System.err.println("pred: " + left );
				}
				else if (left != null)
					 left.printDebug(level +1 );
				for (int i = 0; i < level; i++)
					 System.err.print("  ");
				System.err.println(key + "=" + value + " (" + level() + ")");
				if ( succ() ) {
					 for (int i = 0; i < level; i++)
						  System.err.print("  ");
					 System.err.println("succ: " + right );
				}
				else if (right != null)
					 right.printDebug(level + 1);
		  }
    }
	 
   public void printDebug() {
      System.err.println("size: " + count);
      if (tree != null) tree.printDebug();
   }

	 public boolean containsKey( KEY_TYPE k ) {
		  return findKey( k ) != null;
	 }
	 
	 public int size() {
		  return count;
	 }
	 
	 public boolean isEmpty() {
		  return count == 0;
	 }
	 
	 
	 public Object get( final Object ok ) {
		  final Entry e = findKey( KEY2TYPE( ok ) );
		  return e == null ? (VALUE_CLASS)null : e.getValue();
	 }
	 

#if !#keyclass(Object)

	 public VALUE_TYPE get(final KEY_TYPE k) {
		  final Entry e = findKey( k );
		  
		  return e == null ? defRetValue : e.value;
	 }
	 

	 public VALUE_TYPE remove(final KEY_TYPE k) {
		  final VALUE_TYPE v = delete( k );
		  change = deleted = null;
		  return v;
	 }
	 
	 public boolean containsKey(final Object ok) {
		  return containsKey( KEY2TYPE( ok ) );
	 }
	 
#else
#if !#valueclass(Object)

	 public VALUE_TYPE GET_VALUE( final Object k ) {
		  if ( k == null ) throw new IllegalArgumentException();
		  final Entry e = findKey( k );
		  return e == null ? defRetValue : e.value;
	 }


	 public VALUE_TYPE REMOVE_VALUE( final Object k ) {
		  if ( k == null ) throw new IllegalArgumentException();
		  final VALUE_TYPE v = delete( k );
		  change = deleted = null;
		  return v;
	 }

#endif
#endif


	 public KEY_TYPE FIRST_KEY() {
		  TREEMAP.Entry e = tree;
		  
		  if (e == null) throw new NoSuchElementException();
		  while ( e.left != null ) e = e.left;
		  return e.ENTRY_GET_KEY();
	 }
	 
	 public KEY_TYPE LAST_KEY() {
		  TREEMAP.Entry e = tree;
		  
		  if (e == null) throw new NoSuchElementException();
		  while (e.right != null) e = e.right;
		  return e.ENTRY_GET_KEY();
	 }
	 
#if !#keyclass(Object)
	 public Object firstKey() {
		  return KEY2OBJ( FIRST_KEY() );
	 }
	 
	 public Object lastKey() {
		  return KEY2OBJ( LAST_KEY() );
	 }

#endif


	 private class TreeIterator implements ListIterator {
		  Entry 
				prev, // The entry that will be returned by the next call to previous() (or null if no previous entry exists).
				next, // The entry that will be returned by the next call to next() (or null if no next entry exists).
				curr; // The last entry that was returned (or null if we did not iterate or used remove()).
		  int index = 0;
		  
		  TreeIterator() {
				next = firstEntry;
		  }

		  public boolean hasNext() { return next != null; }
		  public boolean hasPrevious() { return prev != null; }

		  protected void updateNext() {
				next = next.right;
				if ( next != null && ! curr.pred() ) while ( next.left() != sentinel ) next = next.left;
		  }

		  protected Entry nextEntry() {
				if ( ! hasNext() ) throw new NoSuchElementException();
				curr = prev = next;
				index++;
				updateNext();
				return curr;
		  }

		  public Object next() { return nextEntry(); }

		  protected void updatePrevious() {
				prev = prev.left;
				if ( prev != null && ! curr.pred() ) while ( prev.right() != sentinel ) prev = prev.right;
		  }

		  protected Entry previousEntry() {
				if ( ! hasPrevious() ) throw new NoSuchElementException();
				curr = next = prev;
				index--;
				updatePrevious();
				return curr;
		  }

		  public Object previous() { return previousEntry(); }

		  public int nextIndex() {
				if ( ! hasNext() ) throw new NoSuchElementException();
				return index;
		  }

		  public int previousIndex() {
				if ( ! hasPrevious() ) throw new NoSuchElementException();
				return index - 1;
		  }

		  public void remove() {
				if ( curr == null ) throw new IllegalStateException();
				/* If the last operation was a next(), we are removing an entry that preceeds
					the current index, and thus we must decrement it. */
				if ( curr == prev ) index--;
				next = prev = curr;
				updatePrevious();
				updateNext();
				TREEMAP.this.delete( curr.key );

				/* It could happen that the entry we chose as next is exactly the
				one that gets deleted (as deletion is performed by copying a
				suitable entry over the one to be deleted and then removing the
				source of the copy).  In this case, next will point to a removed
				entry (change); it should instead point to the destination of the
				copy (deleted), which is certainly the entry immediately after the
				deleted one. */
				if ( next == change ) next = deleted;
				change = deleted = curr = null;
		  }

		  public void set( Object o ) {
				throw new UnsupportedOperationException();
		  }

		  public void add( Object o ) {
				throw new UnsupportedOperationException();
		  }
	 }

	 private class SubmapIterator extends TreeIterator {
		  Entry 
				first, // The first entry in the map.
				last; // The last entry in the map.
		  boolean top, bottom;
		  
		  SubmapIterator( KEY_TYPE from, boolean bottom, KEY_TYPE to, boolean top ) {
				first = tree;
				while ( first != sentinel && ( bottom || TREEMAP.this.compare( from, first.key ) < 0 ) ) first = first.left();
				if ( first == sentinel ) first = null;

				last = tree;
				while ( last != sentinel && ( top || TREEMAP.this.compare( to, last.key ) > 0 ) ) last = last.right();
				if ( last == sentinel ) last = null;
		  }

		  protected void updatePrevious() {
				super.updatePrevious();
				if ( ! bottom && TREEMAP.this.compare( prev.key, first.key ) < 0 ) prev = null;
		  }

		  protected void updateNext() {
				super.updateNext();
				if ( ! top && TREEMAP.this.compare( next.key, last.key ) > 0 ) next = null;
		  }

	 }


    public Set entrySet() {
		  if ( entries == null ) entries = new AbstractSet() {
					 public Iterator iterator() {
						  return new TreeIterator();
					 }

					 public boolean contains(Object o) {
						  if (!(o instanceof Map.Entry)) return false;
						  final Map.Entry e = (Map.Entry)o;
						  final Map.Entry f = findKey( KEY2TYPE( e.getKey() ) );
						  return e.equals( f );
					 }					 

					 public boolean remove(Object o) {
						  if (!(o instanceof Map.Entry)) return false;
						  final Map.Entry e = (Map.Entry)o;
						  final Entry f = findKey( KEY2TYPE( e.getKey() ) );
						  if ( f != null ) TREEMAP.this.remove( f.key );
						  change = deleted = null;
						  return f != null;
					 }

					 public int size() {
						  return count;
					 }
					 
					 public void clear() {
						  TREEMAP.this.clear();
					 }
					 
				};

		  return entries;
	 }

	 private class KeyIterator extends TreeIterator implements KEY_LIST_ITERATOR {
		  public KEY_TYPE NEXT_KEY() { return nextEntry().key; }
		  public KEY_TYPE PREV_KEY() { return previousEntry().key; }
#if !#keyclass(Object)
		  public Object next() { return KEY2OBJ( nextEntry().key ); }
		  public Object previous() { return KEY2OBJ( previousEntry().key ); }
#endif									
	 };

	 public Set keySet() {
		  if ( keys == null ) keys = new KEY_ABSTRACT_SET() {

					 public Iterator iterator() {
						  return new KeyIterator();
					 }

					 public boolean contains( KEY_TYPE k ) {
						  return containsKey( k );
					 }					 

					 public boolean remove( KEY_TYPE k ) {
						  TREEMAP.this.remove( k );
						  return modified;
					 }					 

#if ! #keyclass( Object )

					 public boolean contains( Object ok ) {
						  return containsKey( ok );
					 }					 

					 public boolean remove( Object ok ) {
						  return remove( KEY2TYPE( ok ) );
					 }

#endif

					 public int size() {
						  return count;
					 }
					 
					 public void clear() {
						  TREEMAP.this.clear();
					 }
					 
				};

		  return keys;
	 }

	 private class ValueIterator extends TreeIterator implements VALUE_LIST_ITERATOR {
		  public VALUE_TYPE NEXT_VALUE() { return nextEntry().value; }
		  public VALUE_TYPE PREV_VALUE() { return previousEntry().value; }
#if !#valueclass(Object)
		  public Object next() { return VALUE2OBJ( nextEntry().value ); }
		  public Object previous() { return VALUE2OBJ( previousEntry().value ); }
#endif									
	 };


    public Collection values() {
		  if ( values == null ) values = new VALUE_ABSTRACT_COLLECTION() {
					 public Iterator iterator() {
						  return new ValueIterator();
					 }

					 public boolean contains( VALUE_TYPE k ) {
						  return containsValue( k );
					 } 

#if ! #valueclass( Object )

					 public boolean contains( Object ok ) {
						  return containsValue( ok );
					 }					 

#endif

					 public int size() {
						  return count;
					 }
					 
					 public void clear() {
						  TREEMAP.this.clear();
					 }
					 
				};

		  return values;
	 }

	 public Comparator comparator() {
		  return storedComparator;
	 }

	 public SortedMap headMap( Object to  ) {
		  return new Submap( KEY_NULL, true, KEY2TYPE( to ), false );
	 }

	 public SortedMap tailMap( Object from ) {
		  return new Submap( KEY2TYPE( from ), false, KEY_NULL, true );
	 }

	 public SortedMap subMap( Object from, Object to ) {
		  return new Submap( KEY2TYPE( from ), false, KEY2TYPE( to ), false );
	 }

#if !#keyclass(Object)
	 public SORTEDMAP headMap( KEY_TYPE to ) {
		  return new Submap( KEY_NULL, true, to, false );
	 }

	 public SORTEDMAP tailMap( KEY_TYPE from ) {
		  return new Submap( from, false, KEY_NULL, true );
	 }

	 public SORTEDMAP subMap( KEY_TYPE from, KEY_TYPE to ) {
		  return new Submap( from, false, to, false );
	 }
#endif


	 private class Submap extends ABSTRACT_MAP implements Serializable, SORTEDMAP {
		  KEY_TYPE from, to;
		  boolean bottom, top;

		  public Submap( KEY_TYPE from, boolean bottom, KEY_TYPE to, boolean top ) {
				this.from = from;
				this.bottom = bottom;
				this.to = to;
				this.top = top;
		  }

		  public void clear() {
				final SubmapIterator i = new SubmapIterator( from, bottom, to, top );
				while( i.hasNext() ) {
					 i.next();
					 i.remove();
				}
		  }

		  private boolean in( KEY_TYPE k ) {
				return ( bottom || TREEMAP.this.compare( k, from ) >= 0 ) &&
					 ( top || TREEMAP.this.compare( k, to ) < 0 );
		  }

		  public Set entrySet() {
				if ( entries == null ) entries = new AbstractSet() {
						  public Iterator iterator() {
								return new SubmapIterator( from, bottom, to, top );
						  }

						  public boolean contains(Object o) {
								if (!(o instanceof Map.Entry)) return false;
								final Map.Entry e = (Map.Entry)o;
								final TREEMAP.Entry f = findKey( KEY2TYPE( e.getKey() ) );
								return f != null && in( f.key ) && e.equals( f );
						  }					 

						  public boolean remove(Object o) {
								if (!(o instanceof Map.Entry)) return false;
								final Map.Entry e = (Map.Entry)o;
								final TREEMAP.Entry f = findKey( KEY2TYPE( e.getKey() ) );
								if ( f != null && in( f.key ) ) TREEMAP.this.remove( f.key );
								change = deleted = null;
								return f != null;
						  }

						  public int size() {
								int c = 0;
								for( Iterator i = iterator(); i.hasNext(); i.next() ) c++;
								return c;
						  }
					 

						  public boolean isEmpty() {
								return ! iterator().hasNext();
						  }

						  public void clear() {
								TREEMAP.this.clear();
						  }
					 
					 };

				return entries;
		  }

		  public Set keySet() {
				return null; // TODO
		  }
		  public Collection values() {
				return null; // TODO
		  }

		  public boolean containsKey( final KEY_TYPE k ) {
				return in( k ) && TREEMAP.this.containsKey( k );
		  }

#if !#keyclass(Object) 
		  public boolean containsKey( final Object ok ) {
				return containsKey( KEY2TYPE( ok ) );
		  }
#endif


#if ! #valueclass(Object) 
		  
		  public boolean containsValue(final Object v) {
				return containsValue( VALUE2TYPE( v ) );
		  }
		  
#endif

		  public boolean containsValue(final VALUE_TYPE v) {
				final SubmapIterator i = new SubmapIterator( from, bottom, to, top );
				VALUE_TYPE ev;
				
				while( i.hasNext() ) {
					 ev = ((TREEMAP.Entry)i.next()).value;
					 if ( VALUE_EQUAL( ev, v ) ) return true;
				}
				
				return false;
		  }
		  


		  public Object get( final Object ok ) {
				return ! in( KEY2TYPE( ok ) ) ? null : TREEMAP.this.get( ok );
		  }
		  
		  
#if ! #keyclass(Object)
		  public VALUE_TYPE get(final KEY_TYPE k) {
				return ! in( k ) ? defRetValue : TREEMAP.this.get( k );
		  }
#elif ! #valueclass(Object)
		  public VALUE_TYPE GET_VALUE(final Object k) {
				return ! in( k ) ? defRetValue: TREEMAP.this.GET_VALUE( k );
		  }
#endif
		  
		  
		  public Object put( final Object ok, final Object ov ) {
				if ( ! in( KEY2TYPE( ok ) ) ) throw new IllegalArgumentException(); 
				return put( ok, ov );
		  }

		  
#if ! ( #valueclass(Object) && #keyclass(Object) )
		  public VALUE_TYPE put(final KEY_TYPE k, final VALUE_TYPE v) {
				if ( ! in( k ) ) throw new IllegalArgumentException(); 
				return put( k, v );
		  }
#endif


		  public Object remove( final Object ok ) {
				if ( ! in( KEY2TYPE( ok ) ) ) throw new IllegalArgumentException(); 
				return TREEMAP.this.remove( ok );
		  }

#if ! #keyclass(Object)
		  public VALUE_TYPE remove( final KEY_TYPE k ) {
				if ( ! in( k ) ) throw new IllegalArgumentException(); 
				return TREEMAP.this.remove( k );
		  }
#elif ! #valueclass(Object)
		  public VALUE_TYPE REMOVE_VALUE( final Object k ) {
				if ( ! in( k ) ) throw new IllegalArgumentException(); 
				return TREEMAP.this.REMOVE_VALUE( k );
		  }
#endif

		  public int size() {
				final SubmapIterator i = new SubmapIterator( from, bottom, to, top );
				int n = 0;
				
				while( i.hasNext() ) {
					 n++;
					 i.next();
				}
				
				return n;
		  }


		  public boolean isEmpty() {
				return entrySet().iterator().hasNext();
		  }

		  
		  public Comparator comparator() {
				return storedComparator;
		  }
		  
		  public SortedMap headMap( final Object oto ) {
				final KEY_TYPE to = KEY2TYPE( oto );

				if ( top ) return new Submap( from, bottom, to, false );
				return compare( to, this.to ) < 0 ? new Submap( from, bottom, to, false ) : this;
		  }
		  
		  public SortedMap tailMap( final Object ofrom ) {
				final KEY_TYPE from = KEY2TYPE( ofrom );

				if ( bottom ) return new Submap( from, false, to, top );
				return compare( from, this.from ) > 0 ? new Submap( from, false, to, top ) : this;
		  }
		  
		  public SortedMap subMap( final Object ofrom, final Object oto ) {
				KEY_TYPE to = KEY2TYPE( oto );
				KEY_TYPE from = KEY2TYPE( ofrom );

				if ( top && bottom ) return new Submap( from, false, to, false );
				if ( ! top ) to = compare( to, this.to ) < 0 ? to : this.to;
				if ( ! bottom ) from = compare( from, this.from ) > 0 ? from : this.from;
				if ( from == this.from && to == this.to ) return this;
				return new Submap( from, false, to, false );
		  }

#if !#keyclass(Object)
		  public SORTEDMAP headMap( final KEY_TYPE to ) {
				if ( top ) return new Submap( from, bottom, to, false );
				return compare( to, this.to ) < 0 ? new Submap( from, bottom, to, false ) : this;
		  }
		  
		  public SORTEDMAP tailMap( final KEY_TYPE from ) {
				if ( bottom ) return new Submap( from, false, to, top );
				return compare( from, this.from ) > 0 ? new Submap( from, false, to, top ) : this;
		  }
		  
		  public SORTEDMAP subMap( KEY_TYPE from, KEY_TYPE to ) {
				if ( top && bottom ) return new Submap( from, false, to, false );
				if ( ! top ) to = compare( to, this.to ) < 0 ? to : this.to;
				if ( ! bottom ) from = compare( from, this.from ) > 0 ? from : this.from;
				if ( from == this.from && to == this.to ) return this;
				return new Submap( from, false, to, false );
		  }
#endif


		  public KEY_TYPE FIRST_KEY() {
				if ( bottom ) return firstEntry.key;
				TREEMAP.Entry e = tree;
				
				// We descend the tree on the left until we find a keys greater than from 
 				while( e.left() != sentinel && compare( from, e.left.key ) < 0 ) e = e.left;
				// If we're on the first key, we return it.
				if ( e.key == from || e.right == null ) return from;

				return firstEntry.key; // TODO
		  }
	 
		  public KEY_TYPE LAST_KEY() {
				if ( top ) return lastEntry.key;
				return lastEntry.key; // TODO
		  }
	 
#if !#keyclass(Object)
		  public Object firstKey() {
				return KEY2OBJ( FIRST_KEY() );
		  }
	 
		  public Object lastKey() {
				return KEY2OBJ( LAST_KEY() );
		  }

#endif

	 }
	 

    private void writeObject(java.io.ObjectOutputStream s) throws IOException {
		  int n = count;
		  Iterator i = new TreeIterator();
		  Entry e;

		  s.defaultWriteObject();

		  while(n-- != 0) {
				e = (Entry)i.next();
				s.WRITE_KEY( e.key );
				s.WRITE_VALUE( e.value );
		  }
    }

    private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
		  s.defaultReadObject();
		  tree = null;
		  /* The storedComparator is now correctly set, but we must restore
			  on-the-fly the actualComparator. */
		  setActualComparator();

		  int count = this.count;
		  this.count = 0;

		  /* This is not very good. There are linear-time ways of rebuilding a
		  tree.  Maybe in the next release... */

		  while(count-- != 0) put(s.READ_KEY(), s.READ_VALUE());
    }



#ifndef NDEBUG

	 private static Random r = new Random();

	 private static KEY_TYPE genKey() {
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
		  return (KEY_TYPE)(r.nextInt());
#elif ! #keyclass(Object)
		  return r.NEXT_KEY(); 
#else
		  return new Long( r.nextLong() );
#endif
	 }

	 private static VALUE_TYPE genValue() {
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
		  return (VALUE_TYPE)(r.nextInt());
#elif ! #valueclass(Object)
		  return r.NEXT_VALUE();
#else
		  return new Long( r.nextLong() );
#endif
	 }

	 private static void speedTest( int n ) {
		  int i;
		  MAP m;
		  SortedMap t;
		  Object[] k = new Object[n], v = new Object[n], nk = new Object[n];
		  KEY_TYPE kt[] = new KEY_TYPE[n];
		  KEY_TYPE nkt[] = new KEY_TYPE[n];
		  VALUE_TYPE vt[] = new VALUE_TYPE[n];
		  long ms;

		  for( int j = 0; j < 10; j++ ) {

				if ( j > 0 ) System.out.println();

				t = new TreeMap();
				m = new TREEMAP();

				for( i = 0; i < n; i++ ) {
#if #keyclass(Object)
					 k[i] = kt[i] = genKey();
					 nk[i] = nkt[i] = genKey();
#else
					 k[i] = new KEY_CLASS( kt[i] = genKey() );
					 nk[i] = new KEY_CLASS( nkt[i] = genKey() );
#endif
#if #valueclass(Object)
					 v[i] = vt[i] = genValue();
#else
					 v[i] = new VALUE_CLASS( vt[i] = genValue() );
#endif
				}

				/* We add pairs to t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.put( k[i], v[i] );
				System.out.println("Added "+n+" pairs in old TreeMap (actual size: " + t.size() + ") in "+((System.currentTimeMillis() - ms)) / 1000.0+" s");

				/* We add pairs to m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.put( kt[i], vt[i] );
				System.out.println("Added "+n+" pairs in new TreeMap (actual size: " + m.size() + ") in "+((System.currentTimeMillis() - ms)) / 1000.0+" s");

				/* We check for pairs in t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.get( k[i] );
				System.out.println("Examined "+n+" existing pairs in old TreeMap in "+((System.currentTimeMillis() - ms)) / 1000.0+" s" );

				/* We check for pairs in m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.get( kt[i] );
				System.out.println("Examined "+n+" existing pairs in new TreeMap in "+((System.currentTimeMillis() - ms)) / 1000.0+" s" );

				/* We check for pairs not in t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.get( nk[i] );
				System.out.println("Examined "+n+" unexisting pairs in old TreeMap in "+((System.currentTimeMillis() - ms)) / 1000.0+" s" );

				/* We check for pairs not in m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.get( nkt[i] );
				System.out.println("Examined "+n+" unexisting pairs in new TreeMap in "+((System.currentTimeMillis() - ms)) / 1000.0+" s" );

				/* We iterate on t. */
				ms = System.currentTimeMillis();
				for( Iterator it = t.keySet().iterator(); it.hasNext(); it.next() );
				System.out.println("Iterated on old TreeMap in "+((System.currentTimeMillis() - ms)) / 1000.0+" s");

				/* We iterate on m. */
				ms = System.currentTimeMillis();
				for( KEY_ITERATOR it = (KEY_ITERATOR)m.keySet().iterator(); it.hasNext(); it.NEXT_KEY() );
				System.out.println("Iterated on new TreeMap in "+((System.currentTimeMillis() - ms)) / 1000.0+" s");

				/* We delete pairs not in t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.remove( nk[i] );
				System.out.println("Removed "+n+" unexisting pairs in old TreeMap in "+((System.currentTimeMillis() - ms)) / 1000.0+" s" );

				/* We delete pairs not in m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.remove( nkt[i] );
				System.out.println("Removed "+n+" unexisting pairs in new TreeMap in "+((System.currentTimeMillis() - ms)) / 1000.0+" s" );
	 
				/* We delete pairs in t. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) t.remove( k[i] );
				System.out.println("Removed "+n+" existing pairs in old TreeMap in "+((System.currentTimeMillis() - ms)) / 1000.0+" s" );

				/* We delete pairs in m. */
				ms = System.currentTimeMillis();
				for( i = 0; i < n;  i++ ) m.remove( kt[i] );
				System.out.println("Removed "+n+" existing pairs in new TreeMap in "+((System.currentTimeMillis() - ms)) / 1000.0+" s" );


		  }


	 }


	 private static boolean valEquals(Object o1, Object o2) {
		  return o1 == null ? o2 == null : o1.equals(o2);
	 }


	 private static void regressionTest( int n ) {
		  TREEMAP m = new TREEMAP();
		  SortedMap t = new TreeMap();
		  Object[] k = new Object[n], v = new Object[n], nk = new Object[n];
		  KEY_TYPE kt[] = new KEY_TYPE[n];
		  KEY_TYPE nkt[] = new KEY_TYPE[n];
		  VALUE_TYPE vt[] = new VALUE_TYPE[n];
		  long ms;

		  for( int i = 0; i < n; i++ ) {
#if #keyclass(Object)
				k[i] = kt[i] = genKey();
				nk[i] = nkt[i] = genKey();
#else
				k[i] = new KEY_CLASS( kt[i] = genKey() );
				nk[i] = new KEY_CLASS( nkt[i] = genKey() );
#endif
#if #valueclass(Object)
				v[i] = vt[i] = genValue();
#else
					 v[i] = new VALUE_CLASS( vt[i] = genValue() );
#endif
		  }
		  
		  Random r = new Random();
				
		  /* We add pairs to t. */
		  ms = System.currentTimeMillis();
		  for( int i = 0; i < n;  i++ ) t.put( k[i], v[i] );
		  
		  /* We add to m the same data */
		  m.putAll(t);

		  if (!m.equals(t)) System.out.println("Error: !m.equals(t) after insertion.\n");
		  if (!t.equals(m)) System.out.println("Error: !t.equals(m) after insertion.\n");

		  /* Now we check that m actually holds that data. */
		  for(Iterator i=t.entrySet().iterator(); i.hasNext();  ) {
				java.util.Map.Entry e = (java.util.Map.Entry)i.next();
		      if (!valEquals(e.getValue(), m.get(e.getKey()))) 
					 System.out.println("Error: m and t differ on an entry ("+e+") after insertion (iterating on t).\n");
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  for(Iterator i=m.entrySet().iterator(); i.hasNext();  ) {
				Entry e = (Entry)i.next();
		      if (!valEquals(e.getValue(), t.get(e.getKey()))) 
					 System.out.println("Error: m and t differ on an entry ("+e+") after insertion (iterating on m).\n");
		  }

		  /* Now we check that m actually holds the same keys. */
		  for(Iterator i=t.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!m.containsKey(o)) {
					 System.out.println("Error: m and t differ on a key ("+o+") after insertion (iterating on t).\n");
					 System.exit(-1);
				}
		      if (!m.keySet().contains(o)) {
					 System.out.println("Error: m and t differ on a key ("+o+", in keySet()) after insertion (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually holds the same keys, but iterating on m. */
		  for(Iterator i=m.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!t.containsKey(o)) {
					 System.out.println("Error: m and t differ on a key after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		      if (!t.keySet().contains(o)) {
					 System.out.println("Error: m and t differ on a key (in keySet()) after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		  }


		  /* Now we check that m actually hold the same values. */
		  for(Iterator i=t.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!m.containsValue(o)) {
					 System.out.println("Error: m and t differ on a value after insertion (iterating on t).\n");
					 System.exit(-1);
				}
		      if (!m.values().contains(o)) {
					 System.out.println("Error: m and t differ on a value (in values()) after insertion (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually hold the same values, but iterating on m. */
		  for(Iterator i=m.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!t.containsValue(o)) {
					 System.out.println("Error: m and t differ on a value after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		      if (!t.values().contains(o)) {
					 System.out.println("Error: m and t differ on a value (in values()) after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that inquiries about random data give the same answer in m and t. For
			  m we use the polymorphic method. */

		  for(int i=0; i<n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 new Long(r.nextLong())
#endif
					 ;

				if (m.containsKey(KEY2OBJ(T)) != t.containsKey(KEY2OBJ(T))) {
					 System.out.println("Error: divergence in keys between t and m (polymorphic method).\n");
					 System.exit(-1);
				}

#if #keyclass(Object) && ! #valueclass(Object)
				if ((m.GET_VALUE(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) || 
					 t.get(KEY2OBJ(T)) != null && 
					 ! VALUE2OBJ(m.GET_VALUE(T)).equals(t.get(KEY2OBJ(T)))) 
#else
					 if ((m.get(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) || 
						  t.get(KEY2OBJ(T)) != null && 
						  ! m.get(KEY2OBJ(T)).equals(t.get(KEY2OBJ(T)))) 
#endif
						  {
								System.out.println("Error: divergence between t and m (polymorphic method).\n");
								System.exit(-1);
						  }
		  }

		  /* Again, we check that inquiries about random data give the same answer in m and t, but
			  for m we use the standard method. */

		  for(int i=0; i<n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 new Long(r.nextLong())
#endif
					 ;
				if (!valEquals(m.get(KEY2OBJ(T)), t.get(KEY2OBJ(T)))) {
					 System.out.println("Error: divergence between t and m (standard method).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we put and remove random data in m and t, checking that the result is the same. */

		  for(int i=0; i<20*n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 new Long(r.nextLong())
#endif
					 ;
				VALUE_TYPE U =
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
					 (VALUE_TYPE)r.nextInt()
#elif ! #valueclass(Object)
					 r.NEXT_VALUE()
#else
					 new Long(r.nextLong())
#endif
					 ;
				if (!valEquals(m.put(KEY2OBJ(T), VALUE2OBJ(U)), t.put(KEY2OBJ(T), VALUE2OBJ(U)))) {
					 System.out.println("Error: divergence in put() between t and m.\n");
					 System.exit(-1);
				}
				T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY()
#else
					 new Long(r.nextLong())
#endif
					 ;
				if (!valEquals(m.remove(KEY2OBJ(T)), t.remove(KEY2OBJ(T)))) {
					 System.out.println("Error: divergence in remove() between t and m.\n");
					 System.exit(-1);
				}
		  }

		  if (!m.equals(t)) System.out.println("Error: !m.equals(t) after removal.\n");
		  if (!t.equals(m)) System.out.println("Error: !t.equals(m) after removal.\n");

		  /* Now we check that m actually holds the same data. */
		  
		  for(Iterator i=t.entrySet().iterator(); i.hasNext();  ) {
				java.util.Map.Entry e = (java.util.Map.Entry)i.next();
		      if (!valEquals(e.getValue(), m.get(e.getKey()))) {
					 System.out.println("Error: m and t differ on an entry ("+e+") after removal (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  
		  for(Iterator i=m.entrySet().iterator(); i.hasNext();  ) {
				Entry e = (Entry)i.next();
		      if (!valEquals(e.getValue(), t.get(e.getKey()))) {
					 System.out.println("Error: m and t differ on an entry ("+e+") after removal (iterating on m).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually holds the same keys. */
		  
		  for(Iterator i=t.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!m.containsKey(o)) {
					 System.out.println("Error: m and t differ on a key ("+o+") after removal (iterating on t).\n");
					 System.exit(-1);
				}
		      if (!m.keySet().contains(o)) {
					 System.out.println("Error: m and t differ on a key ("+o+", in keySet()) after removal (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually holds the same keys, but iterating on m. */
		  
		  for(Iterator i=m.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!t.containsKey(o)) {
					 System.out.println("Error: m and t differ on a key after removal (iterating on m).\n");
					 System.exit(-1);
				}
		      if (!t.keySet().contains(o)) {
					 System.out.println("Error: m and t differ on a key (in keySet()) after removal (iterating on m).\n");
					 System.exit(-1);
				}
		  }


		  /* Now we check that m actually hold the same values. */
		  
		  for(Iterator i=t.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!m.containsValue(o)) {
					 System.out.println("Error: m and t differ on a value after removal (iterating on t).\n");
					 System.exit(-1);
				}
		      if (!m.values().contains(o)) {
					 System.out.println("Error: m and t differ on a value (in values()) after removal (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually hold the same values, but iterating on m. */
		  
		  for(Iterator i=m.values().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!t.containsValue(o)) {
					 System.out.println("Error: m and t differ on a value after removal (iterating on m).\n");
					 System.exit(-1);
				}
		      if (!t.values().contains(o)) {
					 System.out.println("Error: m and t differ on a value (in values()) after removal (iterating on m).\n");
					 System.exit(-1);
				}
		  }


		  int h = m.hashCode();


		  /* Now we save and read m. */
		  
		  try {
				java.io.File ff = new java.io.File("regressionTest");
				java.io.OutputStream os = new java.io.FileOutputStream(ff);
				java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);
				
				oos.writeObject(m);
				oos.close();
				
				java.io.InputStream is = new java.io.FileInputStream(ff);
				java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);
				
				m = (TREEMAP)ois.readObject();
				ois.close();
				ff.delete();
		  }
		  catch(Exception e) {
				e.printStackTrace();
				System.exit(-1);
		  }

		  if (m.hashCode() != h) System.out.println("Error: hashCode() changed after save/read.\n");
		  
		  /* Now we check that m actually holds that data. */
		  
		  for(Iterator i=t.keySet().iterator(); i.hasNext();  ) {
				Object o = i.next();
		      if (!valEquals(m.get(o),t.get(o))) {
					 System.out.println("Error: m and t differ on an entry after save/read.\n");
					 System.exit(-1);
				}
		  }

		  /* Now we take out of m everything, and check that it is empty. */

		  for(Iterator i=t.keySet().iterator(); i.hasNext(); ) m.remove(i.next()); 

		  if (!m.isEmpty())  {
				System.out.println("Error: m is not empty (as it should be).\n");
				System.exit(-1);
		  }


		  System.out.println("Regression test OK.\n");
		  System.exit(0);
	 }


	 public static void main( String args[] ) {
		  int n  = Integer.parseInt(args[1]);
		  
		  if (args[0].equals("speedTest")) speedTest(n);
		  else if (args[0].equals("regressionTest")) regressionTest(n);
	 }

#endif


}

// Local Variables:
// mode: java
// End:
