/*		 
 * fastutil: Fast & compact type-specific collections for Java
 *
 * Copyright (C) 2002, 2003, 2004 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package PACKAGE;

import VALUE_PACKAGE.VALUE_COLLECTION;
import VALUE_PACKAGE.VALUE_ABSTRACT_COLLECTION;
import VALUE_PACKAGE.VALUE_ITERATOR;
import VALUE_PACKAGE.VALUE_ABSTRACT_ITERATOR;
import it.unimi.dsi.fastutil.HashCommon;

import java.util.Iterator;
import java.util.Map;
import java.util.Collection;
import java.util.Set;

/** An abstract class providing basic methods for maps implementing a type-specific interface.
 *
 * <P>This class handles directly a default return
 * value} (including {@linkplain #defaultReturnValue() methods to access
 * it}). Instances of classes inheriting from this class have just to return
 * <code>defRetValue</code> to denote lack of a key in type-specific methods. The value
 * is serialized.
 *
 * <P>Optional operations just throw an {@link
 * UnsupportedOperationException}. Generic versions of accessors delegate to
 * the corresponding type-specific counterparts following the interface rules
 * (they take care of returning <code>null</code> on a missing key).
 *
 * <P>As a further help, this class provides a {@link BasicEntry BasicEntry} inner class
 * that implements a type-specific version of {@link java.util.Map.Entry}; it
 * is particularly useful for those classes that do not implement their own
 * entries (e.g., most immutable maps).
 */

public abstract class ABSTRACT_MAP implements MAP, java.io.Serializable {

	protected ABSTRACT_MAP() {}

	/**
	 * The default return value for <code>get()</code>, <code>put()</code> and
	 * <code>remove()</code>.  
	 */

	protected VALUE_TYPE defRetValue;
	 
	
	public void setDefRetValue( final VALUE_TYPE rv ) {
		defaultReturnValue( rv );
	}

	public VALUE_TYPE getDefRetValue() {
		return defaultReturnValue();
	}


	public void defaultReturnValue( final VALUE_TYPE rv ) {
		defRetValue = rv;
	}

	public VALUE_TYPE defaultReturnValue() {
		return defRetValue;
	}


	public VALUE_TYPE put( KEY_TYPE key, VALUE_TYPE value ) {
		throw new UnsupportedOperationException();
	}

	public VALUE_TYPE REMOVE_VALUE( KEY_TYPE key ) {
		throw new UnsupportedOperationException();
	}

	public void clear() {
		throw new UnsupportedOperationException();
	}


#if ! #keyclass(Object) && ! #keyclass(Reference) || ! #valueclass(Object) && ! #valueclass(Reference)
                                                                                                                                             
	/** Delegates to the corresponding type-specific method, taking care of returning <code>null</code> on a missing key.
	 *
	 * <P>This method must check whether the provided key is in the map using <code>containsKey()</code>. Thus,
	 * it probes the map <em>twice</em>. Implementors of subclasses should override it with a more efficient method.
	 */
	public Object get( Object ok ) {
		KEY_TYPE k = KEY2TYPE( ok );
		return containsKey( k ) ? VALUE2OBJ( GET_VALUE( k ) ) : null;
	}
                                                                                                                                             
	/** Delegates to the corresponding type-specific method, taking care of returning <code>null</code> on a missing key. 
	 *
	 * <P>This method must check whether the provided key is in the map using <code>containsKey()</code>. Thus,
	 * it probes the map <em>twice</em>. Implementors of subclasses should override it with a more efficient method.
	 */
	public Object put( Object ok, Object ov ) {
		KEY_TYPE k = KEY2TYPE( ok );
		VALUE_TYPE v = put( k, VALUE2TYPE( ov ) );
		return containsKey( k ) ? VALUE2OBJ( v ) : null;
	}
                                                                                                                                             
	/** Delegates to the corresponding type-specific method, taking care of returning <code>null</code> on a missing key. 
	 *
	 * <P>This method must check whether the provided key is in the map using <code>containsKey()</code>. Thus,
	 * it probes the map <em>twice</em>. Implementors of subclasses should override it with a more efficient method.
	 */
	public Object remove( Object ok ) {
		KEY_TYPE k = KEY2TYPE( ok );
		VALUE_TYPE v = REMOVE_VALUE( k );
		return containsKey( k ) ? VALUE2OBJ( v ) : null;
	}
#endif
                                                                                                                                             
#if ! #valueclass(Object) && ! #valueclass(Reference)
	public boolean containsValue( Object ov ) {
		return containsValue( VALUE2TYPE( ov ) );
	}
#endif

#if ! #keyclass(Object) && ! #keyclass(Reference)
	public boolean containsKey( Object ok ) {
		return containsKey( KEY2TYPE( ok ) );
	}
#endif


	/** Checks whether the given value is contained in {@link #values()}. */
	public boolean containsValue( VALUE_TYPE v ) {
		return ((VALUE_COLLECTION)values()).contains( v );
	}

	/** Checks whether the given value is contained in {@link #keySet()}. */
	public boolean containsKey( KEY_TYPE k ) {
		return ((SET)keySet()).contains( k );
	}

	/** Puts all pairs in the given map.
	 * If the map implements the interface of this map,
	 * it uses the faster iterators.
	 *
	 * @param m a map.
	 */
	 
	public void putAll(Map m) {
		int n = m.size();
		Iterator i = m.entrySet().iterator();

		if (m instanceof MAP) {
			MAP.Entry e;
			while(n-- != 0) {
				e = (MAP.Entry)i.next();
				put(e.ENTRY_GET_KEY(), e.ENTRY_GET_VALUE());
			}
		}
		else {
			Map.Entry e;
			while(n-- != 0) {
				e = (Map.Entry)i.next();
				put(e.getKey(), e.getValue());
			}
		} 
	}

	public boolean isEmpty() {
		return size() == 0;
	}

	/** This class provides a basic but complete type-specific entry class for all those maps implementations
	 * that do not have entries on their own (e.g., most immutable maps). 
	 *
	 * <P>This class does not implement {@link java.util.Map.Entry#setValue(Object) setValue()}, as the modification
	 * would not be reflected in the base map.
	 */

	public static class BasicEntry implements MAP.Entry {
		protected KEY_TYPE key;
		protected VALUE_TYPE value;

		public BasicEntry( final Object key, final Object value ) {
			this.key = KEY2TYPE(key);
			this.value = VALUE2TYPE(value);
		}

#if ! #keyclass(Object) && ! #keyclass(Reference) || ! #valueclass(Object) && ! #valueclass(Reference)
		  
		public BasicEntry( final KEY_TYPE key, final VALUE_TYPE value ) {
			this.key = key;
			this.value = value;
		}
		  
#endif

		public Object getKey() {
			return KEY2OBJ(key);
		}
		  
#if ! #keyclass(Object) && !#keyclass(Reference)
		public KEY_TYPE ENTRY_GET_KEY() {
			return key;
		}
#endif

		public Object getValue() {
			return VALUE2OBJ(value);
		}
		  
#if ! #valueclass(Object) && ! #valueclass(Reference)
		public VALUE_TYPE ENTRY_GET_VALUE() {
			return value;
		}
#endif

		public VALUE_TYPE setValue( final VALUE_TYPE value ) {
			throw new UnsupportedOperationException();
		}
		  
#if ! #valueclass(Object) && ! #valueclass(Reference)
		  
		public Object setValue( final Object value ) {
			return VALUE2OBJ(setValue(VALUE2TYPE(value)));
		}

#endif

		public boolean equals( final Object o ) {
			if (!(o instanceof Map.Entry)) return false;
			Map.Entry e = (Map.Entry)o;
				
			return KEY_EQUALS( key, KEY2TYPE( e.getKey() ) ) && VALUE_EQUAL( value, VALUE2TYPE( e.getValue() ) );
		}
		  
		public int hashCode() {
			return KEY2INT(key) ^ VALUE2INT(value);
		}
		  
		  
		public String toString() {
			return key + "->" + value;
		}
	}


	/** Returns a type-specific-set view of the keys of this map.
	 *
	 * <P>The view is backed by the set returned by {@link #entrySet()}. Note that
	 * <em>no attempt is made at caching the result of this method</em>, as this would
	 * require adding some attributes that lightweight implementations would
	 * not need. Subclasses may easily override this policy by calling
	 * this method and caching the result, but implementors are encouraged to
	 * write more efficient ad-hoc implementations.
	 *
	 * @return a set view of the keys of this map; it may be safely cast to a type-specific interface.
	 */


	public Set keySet() {
		return new ABSTRACT_SET() {

				public boolean contains( final KEY_TYPE k ) { return containsKey( k ); }

				public int size() { return ABSTRACT_MAP.this.size(); }

				public KEY_ITERATOR KEY_ITERATOR_METHOD() {
					return new KEY_ABSTRACT_ITERATOR() {
							final Iterator i = entrySet().iterator();

							public KEY_TYPE NEXT_KEY() { return ((MAP.Entry)i.next()).ENTRY_GET_KEY(); };

							public boolean hasNext() { return i.hasNext(); }
						};
				}
			};
	}

	/** Returns a type-specific-set view of the values of this map.
	 *
	 * <P>The view is backed by the set returned by {@link #entrySet()}. Note that
	 * <em>no attempt is made at caching the result of this method</em>, as this would
	 * require adding some attributes that lightweight implementations would
	 * not need. Subclasses may easily override this policy by calling
	 * this method and caching the result, but implementors are encouraged to
	 * write more efficient ad-hoc implementations.
	 *
	 * @return a set view of the values of this map; it may be safely cast to a type-specific interface.
	 */


	public Collection values() {
		return new VALUE_ABSTRACT_COLLECTION() {

				public boolean contains( final VALUE_TYPE k ) { return containsValue( k ); }

				public int size() { return ABSTRACT_MAP.this.size(); }

				public VALUE_ITERATOR VALUE_ITERATOR_METHOD() {
					return new VALUE_ABSTRACT_ITERATOR() {
							final Iterator i = entrySet().iterator();

							public VALUE_TYPE NEXT_VALUE() { return ((MAP.Entry)i.next()).ENTRY_GET_VALUE(); };

							public boolean hasNext() { return i.hasNext(); }
						};
				}
			};
	}


	/** Returns a hash code for this map.
	 *
	 * The hash code of a map is computed by summing the hash codes of its entries.
	 *
	 * @return a hash code for this map.
	 */

	public int hashCode() {
		int h = 0, n = size();
		Iterator i = entrySet().iterator();

		while( n-- != 0 ) h += i.next().hashCode();
		return h;
	}

	public boolean equals(Object o) {
		if ( o == this ) return true;
		if ( ! ( o instanceof Map ) ) return false;

		Map m = (Map)o; 
		if ( m.size() != size() ) return false; 
		return entrySet().containsAll( m.entrySet() ); 
	}


	public String toString() {
		final StringBuffer s = new StringBuffer();
		final Iterator i = entrySet().iterator();
		int n = size();
		MAP.Entry e;
		boolean first = true;

		s.append("{");

		while(n-- != 0) {
			if (first) first = false;
			else s.append(", ");

			e = (MAP.Entry)i.next();

#if #keyclass(Object) || #keyclass(Reference)
			if (this == e.getKey()) s.append("(this map)"); else
#endif
				s.append(String.valueOf(e.ENTRY_GET_KEY()));
			s.append("=>");
#if #valueclass(Object) || #valueclass(Reference)
			if (this == e.getValue()) s.append("(this map)"); else
#endif
				s.append(String.valueOf(e.ENTRY_GET_VALUE()));
		}

		s.append("}");
		return s.toString();
	}
	 

}

// Local Variables:
// mode: jde
// tab-width: 4
// End:
