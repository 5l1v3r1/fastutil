Welcome to fastutil 3.0, a collection of type-specific Java classes that
implement the map, set and list interfaces of the java.util package.

fastutil provides a huge collection of specialised classes generated starting
from a parameterised version; the classes are much more compact and much faster
than the general ones. Please read the package documentation for more
information.

The compiled code is contained in the jar file, and should be installed where
you keep Java extensions. Note that the jar file is huge, due to the large
number of classes: if you plan to ship your own jar with some fastutil classes
included, you should look at AutoJar to extract automatically the necessary
classes.

NOTE: fastutil 3.0 broke (once again) source-code compatibility because the
introduction of type-specific lists made it necessary to change the name of the
polymorphic remove() method of an IntCollection. Moreover, the huge number
of classes required a division in subpackages. Please see the documentation.

NOTE: fastutil 2.52 broke again source-code compatibility with previous
versions, as the package name is now it.unimi.dsi.fastutil (as opposed to
it.unimi.dsi.fastUtil), but you can keep your old (<2.52) fastUtil.jar around
to get a smooth transition.

NOTE: fastutil 2.0 broke source-code compatibility with previous versions, as
(almost) all classes got new names, but you can keep your old (<2.0) fastutil
jar around with another name (say, fastUtil13.jar) to get a smooth transition.

The Java sources are generated using a C preprocessor. The gencsources.sh
script will generate the (fake) C sources from the driver files. They include
the driver code and some #define that customise the environment.  Then, you
have to "make jar" to get the actual Java sources and the jar file and "make
docs" to create the API documentation. Note that you need ant
(http://jakarta.apache.org/ant/).

If you define the TEST make variable (e.g., make jar TEST=1), a main method
will be compiled in each class: it performs a behavioural test or a speed test
on n elements, when called with arguments "test n [f]" or "speedTest
n [f]", respectively (the optional argument f is the load factor for hash-based
classes). Using "speedComp n [f]" will perform a speed test, but the same test
will be performed on the standard java.util class first. You should use a
server-type JVM if available.

The tests are repeated several times, and the first data is discarded (it is
just used to warm up the JVM). They include adding elements (Add/Put), 
removing existing (RemYes) and non-existing entries (RemNo), enquiring existing
(Yes) and non-existing entries (No), iterating forward (IterFor) and, where
available, backward (IterBack).

                                          seba (vigna@acm.org)
