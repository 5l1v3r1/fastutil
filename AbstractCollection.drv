/*		 
 * fastutil 2.61: Fast & compact specialized utility classes for Java
 *
 * Copyright (C) 2002, 2003 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package it.unimi.dsi.fastutil;

import java.util.*;
import java.util.AbstractCollection; // workaround to force @see/@link

/** An abstract class providing basic methods for collections implementing a type-specific interface.
 *
 * <P>In particular, this class provide {@link #iterator()}, {@link #add(Object)}, {@link #remove(Object)} and
 * {@link #contains(Object)} methods that just call the type-specific counterpart. 
 */

public abstract class ABSTRACT_COLLECTION implements COLLECTION {

	protected ABSTRACT_COLLECTION() {};

#if ! #keyclass(Object) && ! #keyclass(Reference)

	public KEY_TYPE[] toArray( KEY_TYPE a[] ) {
		return TO_KEY_ARRAY( a );
	}


	public KEY_TYPE[] TO_KEY_ARRAY() {
		return TO_KEY_ARRAY( null );
	}

	public KEY_TYPE[] TO_KEY_ARRAY( KEY_TYPE a[] ) {
		if ( a == null || a.length < size() ) a = new KEY_TYPE[ size() ];
		Iterators.unwrap( KEY_ITERATOR_METHOD(), a );
		return a;
	}

	/** Adds all elements of the given type-specific collection to this collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */

	public boolean addAll( COLLECTION c ) {
		boolean retVal = false;
		final KEY_ITERATOR i = c.KEY_ITERATOR_METHOD();
		int n = c.size();

		while( n-- != 0 ) if ( add( i.NEXT_KEY() ) ) retVal = true;
		return retVal;
	}

	/** Checks whether this collection contains all elements from the given type-specific collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection contains all elements of the argument.
	 */

	public boolean containsAll( COLLECTION c ) {
		final KEY_ITERATOR i = c.KEY_ITERATOR_METHOD();
		int n = c.size();

		while( n-- != 0 ) if ( ! contains( i.NEXT_KEY() ) ) return false;

		return true;
	}

	/** Retains in this collection only elements from the given type-specific collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */

	public boolean retainAll( COLLECTION c ) {
		boolean retVal = false;
		int n = size();

		final KEY_ITERATOR i = KEY_ITERATOR_METHOD();

		while( n-- != 0 ) {
			if ( ! c.contains( i.NEXT_KEY() ) ) {
				i.remove();
				retVal = true;
			}
		}

		return retVal;
	}

	/** Remove from this collection all elements in the given type-specific collection.
	 *
	 * @param c a type-specific collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */

	public boolean removeAll( COLLECTION c ) {
		boolean retVal = false;
		int n = c.size();

		final KEY_ITERATOR i = c.KEY_ITERATOR_METHOD();

		while( n-- != 0 ) if ( REMOVE( i.NEXT_KEY() ) ) retVal = true;

		return retVal;
	}

#endif

	public Object[] toArray() {
		return toArray( (Object[])null );
	}

	public Object[] toArray( Object a[] ) {
		if ( a == null ) a = new Object[ size() ];
		else if ( a.length < size() ) a = (Object[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size() );
		Iterators.unwrap( iterator(), a );
		return a;
	}

	/** Adds all elements of the given collection to this collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */

	public boolean addAll( Collection c ) {
		boolean retVal = false;
		final Iterator i = c.iterator();
		int n = c.size();

		while( n-- != 0 ) if ( add( i.next() ) ) retVal = true;
		return retVal;
	}



	public boolean add( KEY_TYPE k ) {
		throw new UnsupportedOperationException();
	}
	 
	public boolean REMOVE( KEY_TYPE k ) {
		throw new UnsupportedOperationException();
	}


	/** A commodity method that delegates to the corresponding type-specific method. */
	public Iterator iterator() {
		return KEY_ITERATOR_METHOD();
	}

#if ! #keyclass(Object) && ! #keyclass(Reference)

	/** A commodity method that delegates to the corresponding type-specific method. */
	public boolean add( Object o ) {
		return add( KEY2TYPE( o ) );
	}

	/** A commodity method that delegates to the corresponding type-specific method. */
	public boolean remove( final Object o ) {
		return REMOVE( KEY2TYPE( o ) );
	}

	/** A commodity method that delegates to the corresponding type-specific method. */
	public boolean contains( final Object o ) {
		return contains( KEY2TYPE( o ) );
	}
#endif

	/** Checks whether this collection contains all elements from the given collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection contains all elements of the argument.
	 */

	public boolean containsAll( Collection c ) {
		int n = c.size();

		final Iterator i = c.iterator();
		while( n-- != 0 ) if ( ! contains( i.next() ) ) return false;

		return true;
	}


	/** Retains in this collection only elements from the given collection.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */

	public boolean retainAll( Collection c ) {
		boolean retVal = false;
		int n = size();

		final Iterator i = iterator();
		while( n-- != 0 ) {
			if ( ! c.contains( i.next() ) ) {
				i.remove(); 
				retVal = true;
			}
		}

		return retVal;
	}

	/** Remove from this collection all elements in the given collection.
	 * If the collection is an instance of this class, it uses faster iterators.
	 *
	 * @param c a collection.
	 * @return <code>true</code> if this collection changed as a result of the call.
	 */

	public boolean removeAll( Collection c ) {
		boolean retVal = false;
		int n = c.size();

		final Iterator i = c.iterator();
		while( n-- != 0 ) if ( remove( i.next() ) ) retVal = true;

		return retVal;
	}

	public boolean isEmpty() {
		return size() == 0;
	}

	public String toString() {
		final StringBuffer s = new StringBuffer();
		final KEY_ITERATOR i = KEY_ITERATOR_METHOD();
		int n = size();
		KEY_TYPE k;
		boolean first = true;

		s.append("{");

		while(n-- != 0) {
			if (first) first = false;
			else s.append(", ");
			k = i.NEXT_KEY();
#if #keyclass(Object) || #keyclass(Reference)
			if (this == k) s.append("(this collection)"); else
#endif
				s.append(String.valueOf(k));
		}

		s.append("}");
		return s.toString();
	}
	 
}

// Local Variables:
// mode: jde
// tab-width: 4
// End:
