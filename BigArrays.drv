/*		 
 * fastutil: Fast & compact type-specific collections for Java
 *
 * Copyright (C) 2009 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * Copyright (C) 1999 CERN - European Organization for Nuclear Research.
 *
 *   Permission to use, copy, modify, distribute and sell this software and
 *   its documentation for any purpose is hereby granted without fee,
 *   provided that the above copyright notice appear in all copies and that
 *   both that copyright notice and this permission notice appear in
 *   supporting documentation. CERN makes no representations about the
 *   suitability of this software for any purpose. It is provided "as is"
 *   without expressed or implied warranty. 
 */

package PACKAGE;

import it.unimi.dsi.fastutil.BigArrays;
import it.unimi.dsi.fastutil.Hash;
import static it.unimi.dsi.fastutil.BigArrays.start;
import static it.unimi.dsi.fastutil.BigArrays.segment;
import static it.unimi.dsi.fastutil.BigArrays.displacement;
import static it.unimi.dsi.fastutil.BigArrays.SEGMENT_SHIFT;
import static it.unimi.dsi.fastutil.BigArrays.SEGMENT_MASK;
import static it.unimi.dsi.fastutil.BigArrays.SEGMENT_SIZE;

#if #keys(primitive)

/** A class providing static methods and objects that do useful things with <em>big arrays</em>&mdash;arrays
 * longer than 2<sup>31</sup>&minus;1 represented by multiple arrays.
 *
 * @see BigArrays
 */

public class BIG_ARRAYS {

#else

import java.util.Comparator;

/** A class providing static methods and objects that do useful things with <em>big arrays</em>&mdash;arrays
 * longer than 2<sup>31</sup>&minus;1 represented by multiple arrays.
 *
 * <P><strong>Warning:</strong> creating arrays 
 * using {@linkplain java.lang.reflect.Array#newInstance(Class,int) reflection}, as it
 * happens in {@link #ensureCapacity(Object[][],long,long)} and {@link #grow(Object[][],long,long)},
 * is <em>significantly slower</em> than using <code>new</code>. This phenomenon is particularly
 * evident in the first growth phases of an array reallocated with doubling (or similar) logic.
 *
 * @see BigArrays
 */

public class BIG_ARRAYS {

#endif

	/** The inverse of the golden ratio times 2<sup>16</sup>. */
	public static final long ONEOVERPHI = 106039;

	private BIG_ARRAYS() {}

	/** A static, final, empty big array. */
	public final static KEY_TYPE[][] EMPTY_BIG_ARRAY = {};

	/** Returns the element of the given big array of specified index.
	 * 
	 * @param bigArray a big array.
	 * @param index a position in the big array.
	 * @return the element of the big array at the specified position.
	 */
	public static KEY_GENERIC KEY_GENERIC_TYPE get( final KEY_GENERIC_TYPE[][] bigArray, final long index ) {
		return bigArray[ segment( index ) ][ displacement( index ) ];
	}
	
	/** Sets the element of the given big array of specified index.
	 * 
	 * @param bigArray a big array.
	 * @param index a position in the big array.
	 */
	public static KEY_GENERIC void set( final KEY_GENERIC_TYPE[][] bigArray, final long index, KEY_GENERIC_TYPE value ) {
		bigArray[ segment( index ) ][ displacement( index ) ] = value;
	}
	
	/** Swaps the element of the given big array of specified indices.
	 * 
	 * @param bigArray a big array.
	 * @param first a position in the big array.
	 * @param second a position in the big array.
	 */
	public static KEY_GENERIC void swap( final KEY_GENERIC_TYPE[][] bigArray, final long first, final long second ) {
		final KEY_GENERIC_TYPE t = bigArray[ segment( first ) ][ displacement( first ) ];
		bigArray[ segment( first ) ][ displacement( first ) ] = bigArray[ segment( second ) ][ displacement( second ) ];
		bigArray[ segment( second ) ][ displacement( second ) ] = t;
	}
	
#if #keys(primitive) && ! #keyclass(Boolean)
	/** Adds the specified increment the element of the given big array of specified index.
	 * 
	 * @param bigArray a big array.
	 * @param index a position in the big array.
	 * @param incr the increment
	 */
	public static void add( final KEY_GENERIC_TYPE[][] bigArray, final long index, KEY_GENERIC_TYPE incr ) {
		bigArray[ segment( index ) ][ displacement( index ) ] += incr;
	}

	/** Multiplies by the specified factor the element of the given big array of specified index.
	 * 
	 * @param bigArray a big array.
	 * @param index a position in the big array.
	 * @param factor the factor
	 */
	public static void mul( final KEY_GENERIC_TYPE[][] bigArray, final long index, KEY_GENERIC_TYPE factor ) {
		bigArray[ segment( index ) ][ displacement( index ) ] *= factor;
	}

	/** Increments the element of the given big array of specified index.
	 * 
	 * @param bigArray a big array.
	 * @param index a position in the big array.
	 */
	public static void incr( final KEY_GENERIC_TYPE[][] bigArray, final long index ) {
		bigArray[ segment( index ) ][ displacement( index ) ]++;
	}

	/** Decrements the element of the given big array of specified index.
	 * 
	 * @param bigArray a big array.
	 * @param index a position in the big array.
	 */
	public static void decr( final KEY_GENERIC_TYPE[][] bigArray, final long index ) {
		bigArray[ segment( index ) ][ displacement( index ) ]--;
	}


#endif


	/** Returns the length of the given big array.
	 * 
	 * @param bigArray a big array.
	 * @return the length of the given big array.
	 */
	public static KEY_GENERIC long length( final KEY_GENERIC_TYPE[][] bigArray ) {
		final int length = bigArray.length;
		return length == 0 ? 0 : start( length - 1 ) + bigArray[ length - 1 ].length;
	}
	
	/** Copies a big array from the specified source big array, beginning at the specified position, to the specified position of the destination big array. 
	 * 
	 * @param srcBigArray the source big array.
	 * @param srcPos the starting position in the source big array.
	 * @param destBigArray the destination big array.
	 * @param destPos the starting position in the destination data.
	 */
	public static KEY_GENERIC void copy( final KEY_GENERIC_TYPE[][] srcBigArray, final long srcPos, final KEY_GENERIC_TYPE[][] destBigArray, final long destPos, long length ) {
		if ( destPos <= srcPos ) {
			int srcSegment = segment( srcPos );
			int destSegment = segment( destPos );
			int srcDispl = displacement( srcPos );
			int destDispl = displacement( destPos );
			int l;
			while( length > 0 ) {
				l = (int)Math.min( length, Math.min( srcBigArray[ srcSegment ].length - srcDispl, destBigArray[ destSegment ].length - destDispl ) );
				System.arraycopy( srcBigArray[ srcSegment ], srcDispl, destBigArray[ destSegment ], destDispl, l );
				if ( ( srcDispl += l ) == SEGMENT_SIZE ) {
					srcDispl = 0;
					srcSegment++;
				}
				if ( ( destDispl += l ) == SEGMENT_SIZE ) {
					destDispl = 0;
					destSegment++;
				}
				length -= l;
			}
		}
		else {
			int srcSegment = segment( srcPos + length );
			int destSegment = segment( destPos + length  );
			int srcDispl = displacement( srcPos + length  );
			int destDispl = displacement( destPos + length  );
			int l;
			while( length > 0 ) {
				if ( srcDispl == 0 ) {
					srcDispl = SEGMENT_SIZE;
					srcSegment--;
				}
				if ( destDispl == 0 ) {
					destDispl = SEGMENT_SIZE;
					destSegment--;
				}
				l = (int)Math.min( length, Math.min( srcDispl, destDispl ) );
				System.arraycopy( srcBigArray[ srcSegment ], srcDispl - l, destBigArray[ destSegment ], destDispl - l, l );
				srcDispl -= l;
				destDispl -= l;
				length -= l;
			}
		}
	}
	
#if #keyclass(Object)	
	/** Creates a new big array using a the given one as prototype. 
	 *
	 * <P>This method returns a new big array of the given length whose element
	 * are of the same class as of those of <code>prototype</code>. In case
	 * of an empty big array, it tries to return {@link #EMPTY_BIG_ARRAY}, if possible.
	 *
	 * @param prototype a big array that will be used to type the new one.
	 * @param length the length of the new big array.
	 * @return a new big array of given type and length.
	 */

	public static <K> K[][] newBigArray( final K[][] prototype, final long length ) {
		return newBigArray( prototype.getClass().getComponentType(), length );
	}

	/** Creates a new big array using a the given one as component type. 
	 *
	 * <P>This method returns a new big array 
	 * are of class <code>prototype</code>. In case
	 * of an empty big array, it tries to return {@link #EMPTY_BIG_ARRAY}, if possible.
	 *
	 * @param prototype a big array that will be used to type the new one.
	 * @param length the length of the new big array.
	 * @return a new big array of given type and length.
	 */

	@SuppressWarnings("unchecked")
	private static <K> K[][] newBigArray( Class<?> componentType, final long length ) {
		if ( length == 0 && componentType == Object[].class ) return KEY_GENERIC_BIG_ARRAY_CAST EMPTY_BIG_ARRAY;
		final int baseLength = (int)((length + SEGMENT_MASK) >> SEGMENT_SHIFT);
		K[][] base = (K[][])java.lang.reflect.Array.newInstance( componentType, baseLength );
		final int residual = (int)(length & SEGMENT_MASK);
		if ( residual != 0 ) {
			for( int i = 0; i < baseLength - 1; i++ ) base[ i ] = (K[])java.lang.reflect.Array.newInstance( componentType.getComponentType(), SEGMENT_SIZE );
			base[ baseLength - 1 ] = (K[])java.lang.reflect.Array.newInstance( componentType.getComponentType(), (int)(length & SEGMENT_MASK) );
		}
		else for( int i = 0; i < baseLength; i++ ) base[ i ] = (K[])java.lang.reflect.Array.newInstance( componentType.getComponentType(), SEGMENT_SIZE );

		return base;
	}
#endif

	/** Creates a new big array.
	 *
	 * @param length the length of the new big array.
	 * @return a new big array of given length.
	 */

	public static KEY_TYPE[][] newBigArray( final long length ) {
		if ( length == 0 ) return EMPTY_BIG_ARRAY;
		final int baseLength = (int)((length + SEGMENT_MASK) >> SEGMENT_SHIFT);
		KEY_TYPE[][] base = new KEY_TYPE[ baseLength ][];
		final int residual = (int)(length & SEGMENT_MASK);
		if ( residual != 0 ) {
			for( int i = 0; i < baseLength - 1; i++ ) base[ i ] = new KEY_TYPE[ SEGMENT_SIZE ];
			base[ baseLength - 1 ] = new KEY_TYPE[ (int)(length & SEGMENT_MASK) ];
		}
		else for( int i = 0; i < baseLength; i++ ) base[ i ] = new KEY_TYPE[ SEGMENT_SIZE ];
		
		return base;
	}

#if #keyclass(Object)
	/** Turns a standard array into a big array.
	 *
	 * <P>Note that the returned big array might contain as a segment the original array.
	 *
	 * @param array an array.
	 * @return a new big array with the same length and content of <code>array</code>.
	 */

	@SuppressWarnings("unchecked")
	public static <K> K[][] wrap( final K[] array ) {
		if ( array.length == 0 && array.getClass() == Object[].class ) return KEY_GENERIC_BIG_ARRAY_CAST EMPTY_BIG_ARRAY;
		if ( array.length <= SEGMENT_SIZE ) {
			final K[][] bigArray = (K[][])java.lang.reflect.Array.newInstance( array.getClass(), 1 );
			bigArray[ 0 ] = array;
			return bigArray;
		}
		final K[][] bigArray = newBigArray( array.getClass(), array.length );
		for( int i = 0; i < bigArray.length; i++ ) System.arraycopy( array, (int)start( i ), bigArray[ i ], 0, bigArray[ i ].length );
		return bigArray;
	}

#else
	/** Turns a standard array into a big array.
	 *
	 * <P>Note that the returned big array might contain as a segment the original array.
	 *
	 * @param array an array.
	 * @return a new big array with the same length and content of <code>array</code>.
	 */

	public static KEY_TYPE[][] wrap( final KEY_TYPE[] array ) {
		if ( array.length == 0 ) return EMPTY_BIG_ARRAY;
		if ( array.length <= SEGMENT_SIZE ) return new KEY_TYPE[][] { array };
		final KEY_TYPE[][] bigArray = newBigArray( array.length );
		for( int i = 0; i < bigArray.length; i++ ) System.arraycopy( array, (int)start( i ), bigArray[ i ], 0, bigArray[ i ].length );
		return bigArray;
	}
#endif
	/** Ensures that a big array can contain the given number of entries.
	 *
	 * <P>If you cannot foresee whether this big array will need again to be
	 * enlarged, you should probably use <code>grow()</code> instead.
	 *
	 * @param bigArray a big array.
	 * @param length the new minimum length for this big array.
	 * @return <code>array</code>, if it contains <code>length</code> entries or more; otherwise,
	 * a big array with <code>length</code> entries whose first <code>array.length</code>
	 * entries are the same as those of <code>array</code>.
	 */
	public static KEY_GENERIC KEY_GENERIC_TYPE[][] ensureCapacity( final KEY_GENERIC_TYPE[][] bigArray, final long length ) {
		final long oldLength = length( bigArray );
		if ( length > oldLength ) {
			final KEY_GENERIC_TYPE t[][] =
#if #keyclass(Object)
				newBigArray( bigArray, length );
#else
				newBigArray( length );
#endif
			copy( bigArray, 0, t, 0, oldLength );
			return t;
		}
		return bigArray;
	}

	/** Ensures that a big array can contain the given number of entries, preserving just a part of the big array.
	 *
	 * @param bigArray a big array.
	 * @param length the new minimum length for this big array.
	 * @param preserve the number of elements of the big array that must be preserved in case a new allocation is necessary.
	 * @return <code>array</code>, if it can contain <code>length</code> entries or more; otherwise,
	 * a big array with <code>length</code> entries whose first <code>preserve</code>
	 * entries are the same as those of <code>array</code>.
	 */
	public static KEY_GENERIC KEY_GENERIC_TYPE[][] ensureCapacity( final KEY_GENERIC_TYPE[][] bigArray, final long length, final long preserve ) {
		if ( length > length( bigArray ) ) {
			final KEY_GENERIC_TYPE t[][] =
#if #keyclass(Object)
				newBigArray( bigArray, length );
#else
				newBigArray( length );
#endif
			copy( bigArray, 0, t, 0, preserve );
			return t;
		}
		return bigArray;
	}

	/** Grows the given big array to the maximum between the given length and
	 * the current length divided by the golden ratio, provided that the given
	 * length is larger than the current length.
	 *
	 * <P> Dividing by the golden ratio (&phi;) approximately increases the big array
	 * length by 1.618. If you want complete control on the big array growth, you
	 * should probably use <code>ensureCapacity()</code> instead.
	 *
	 * @param bigArray a big array.
	 * @param length the new minimum length for this big array.
	 * @return <code>array</code>, if it can contain <code>length</code>
	 * entries; otherwise, a big array with
	 * max(<code>length</code>,<code>array.length</code>/&phi;) entries whose first
	 * <code>array.length</code> entries are the same as those of <code>array</code>.
	 * */

	public static KEY_GENERIC KEY_GENERIC_TYPE[][] grow( final KEY_GENERIC_TYPE[][] bigArray, final long length ) {
		final long oldLength = length( bigArray );
		if ( length > oldLength ) {
			final long newLength = Math.max( ( ONEOVERPHI * oldLength ) >>> 16, length );
			final KEY_GENERIC_TYPE t[][] =
#if #keyclass(Object)
				newBigArray( bigArray, newLength );
#else
				newBigArray( newLength );
#endif
			copy( bigArray, 0, t, 0, oldLength );
			return t;
		}
		return bigArray;
	}

	/** Grows the given big array to the maximum between the given length and
	 * the current length divided by the golden ratio, provided that the given
	 * length is larger than the current length, preserving just a part of the big array.
	 *
	 * <P> Dividing by the golden ratio (&phi;) approximately increases the big array
	 * length by 1.618. If you want complete control on the big array growth, you
	 * should probably use <code>ensureCapacity()</code> instead.
	 *
	 * @param bigArray a big array.
	 * @param length the new minimum length for this big array.
	 * @param preserve the number of elements of the big array that must be preserved in case a new allocation is necessary.
	 * @return <code>array</code>, if it can contain <code>length</code>
	 * entries; otherwise, a big array with
	 * max(<code>length</code>,<code>array.length</code>/&phi;) entries whose first
	 * <code>preserve</code> entries are the same as those of <code>array</code>.
	 * */

	public static KEY_GENERIC KEY_GENERIC_TYPE[][] grow( final KEY_GENERIC_TYPE[][] bigArray, final long length, final long preserve ) {
		final long oldLength = length( bigArray );
		if ( length > oldLength ) {
			final long newLength = Math.max( ( ONEOVERPHI * oldLength ) >>> 16, length );

			final KEY_GENERIC_TYPE t[][] =
#if #keyclass(Object)
				newBigArray( bigArray, newLength );
#else
				newBigArray( newLength );
#endif
			copy( bigArray, 0, t, 0, preserve );

			return t;
		}
		return bigArray;

	}

	/** Trims the given big array to the given length.
	 *
	 * @param bigArray a big array.
	 * @param length the new maximum length for the big array.
	 * @return <code>array</code>, if it contains <code>length</code>
	 * entries or less; otherwise, a big array with
	 * <code>length</code> entries whose entries are the same as
	 * the first <code>length</code> entries of <code>array</code>.
	 * 
	 */

	public static KEY_GENERIC KEY_GENERIC_TYPE[][] trim( final KEY_GENERIC_TYPE[][] bigArray, final long length ) {
		if ( length >= length( bigArray ) ) return bigArray;
		final KEY_GENERIC_TYPE t[][] =
#if #keyclass(Object)
			newBigArray( bigArray, length );
#else
			newBigArray( length );
#endif
		copy( bigArray, 0, t, 0, length );
		return t;
	}

	/** Sets the length of the given big array.
	 *
	 * @param bigArray a big array.
	 * @param length the new length for the big array.
	 * @return <code>array</code>, if it contains exactly <code>length</code>
	 * entries; otherwise, if it contains <em>more</em> than
	 * <code>length</code> entries, a big array with <code>length</code> entries
	 * whose entries are the same as the first <code>length</code> entries of
	 * <code>array</code>; otherwise, a big array with <code>length</code> entries
	 * whose first <code>array.length</code> entries are the same as those of
	 * <code>array</code>.
	 * 
	 */

	public static KEY_GENERIC KEY_GENERIC_TYPE[][] setLength( final KEY_GENERIC_TYPE[][] bigArray, final long length ) {
		final long oldLength = length( bigArray );
		if ( length == oldLength ) return bigArray;
		if ( length < oldLength ) return trim( bigArray, length );
		return ensureCapacity( bigArray, length );
	}

	/** Returns a copy of a portion of a big array.
	 *
	 * @param bigArray a big array.
	 * @param offset the first element to copy.
	 * @param length the number of elements to copy.
	 * @return a new big array containing <code>length</code> elements of <code>array</code> starting at <code>offset</code>.
	 */

	public static KEY_GENERIC KEY_GENERIC_TYPE[][] copy( final KEY_GENERIC_TYPE[][] bigArray, final long offset, final long length ) {
		ensureOffsetLength( bigArray, offset, length );
		final KEY_GENERIC_TYPE[][] a = 
#if #keyclass(Object)
			newBigArray( bigArray, length );
#else
			newBigArray( length );
#endif
		copy( bigArray, offset, a, 0, length );
		return a;
	}

	/** Returns a copy of a big array.
	 *
	 * @param bigArray a big array.
	 * @return a copy of <code>array</code>.
	 */

	public static KEY_GENERIC KEY_GENERIC_TYPE[][] copy( final KEY_GENERIC_TYPE[][] bigArray ) {
		final KEY_GENERIC_TYPE[][] base = bigArray.clone();
		for( int i = base.length; i-- != 0; ) base[ i ] = bigArray[ i ].clone();
		return base;
	}

	/** Fills the given big array with the given value.
	 *
	 * <P>This method uses a backward loop. It is significantly faster than the corresponding
	 * method in {@link java.util.Arrays}.
	 *
	 * @param bigArray a big array.
	 * @param value the new value for all elements of the big array.
	 */

	public static KEY_GENERIC void fill( final KEY_GENERIC_TYPE[][] bigArray, final KEY_GENERIC_TYPE value ) {
		for( int i = bigArray.length; i-- != 0; ) ARRAYS.fill( bigArray[ i ], value );
	}

	/** Fills a portion of the given big array with the given value.
	 *
	 * <P>If possible (i.e., <code>from</code> is 0) this method uses a
	 * backward loop. In this case, it is significantly faster than the
	 * corresponding method in {@link java.util.Arrays}.
	 *
	 * @param bigArray a big array.
	 * @param from the starting index of the portion to fill.
	 * @param to the end index of the portion to fill.
	 * @param value the new value for all elements of the specified portion of the big array.
	 */

	public static KEY_GENERIC void fill( final KEY_GENERIC_TYPE[][] bigArray, final long from, long to, final KEY_GENERIC_TYPE value ) {
		final long length = length( bigArray );
		BigArrays.ensureFromTo( length, from, to );
		int fromSegment = segment( from );
		int toSegment = segment( to );
		int fromDispl = displacement( from );
		int toDispl = displacement( to );
		if ( fromSegment == toSegment ) {
			ARRAYS.fill( bigArray[ fromSegment ], fromDispl, toDispl, value );
			return;
		}

		ARRAYS.fill( bigArray[ toSegment ], 0, toDispl, value );
		while( --toSegment > fromSegment ) ARRAYS.fill( bigArray[ toSegment ], value );
		ARRAYS.fill( bigArray[ fromSegment ], fromDispl, SEGMENT_SIZE, value );
	}


	/** Returns true if the two big arrays are elementwise equal.
	 *
	 * <P>This method uses a backward loop. It is significantly faster than the corresponding
	 * method in {@link java.util.Arrays}.
	 *
	 * @param a1 a big array.
	 * @param a2 another big array.
	 * @return true if the two big arrays are of the same length, and their elements are equal.
	 */

	public static KEY_GENERIC boolean equals( final KEY_GENERIC_TYPE[][] a1, final KEY_GENERIC_TYPE a2[][] ) {
		if ( length( a1 ) != length( a2 ) ) return false;
		int i = a1.length, j;
		KEY_GENERIC_TYPE[] t, u;
		while( i-- != 0 ) {
			t = a1[ i ];
			u = a2[ i ];
			j = t.length;
			while( j-- != 0 ) if (! KEY_EQUALS( t[ j ], u[ j ] ) ) return false;
		}
		return true;
	}

	/* Returns a string representation of the contents of the specified array. 
	 *
	 * The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Returns "null" if <code>a</code> is null.
	 * @param a  the array whose string representation to return.
	 * @return the string represetation of <code>a</code>.
	 */

	public static KEY_GENERIC String toString( final KEY_GENERIC_TYPE[][] a ) {
		if ( a == null ) return "null";
		final long last = length( a ) - 1;
		if ( last == - 1 ) return "[]";
		final StringBuilder b = new StringBuilder();
		b.append('[');
		for ( long i = 0; ; i++ ) {
			b.append( String.valueOf( get( a, i ) ) );
			if ( i == last ) return b.append(']').toString();
			b.append(", ");
        }
	}


	/** Ensures that a range given by its first (inclusive) and last (exclusive) elements fits a big array.
	 *
	 * <P>This method may be used whenever a big array range check is needed.
	 *
	 * @param a a big array.
	 * @param from a start index (inclusive).
	 * @param to an end index (inclusive).
	 * @throws IllegalArgumentException if <code>from</code> is greater than <code>to</code>.
	 * @throws ArrayIndexOutOfBoundsException if <code>from</code> or <code>to</code> are greater than the big array length or negative.
	 */
	public static KEY_GENERIC void ensureFromTo( final KEY_GENERIC_TYPE[][] a, final long from, final long to ) {
		BigArrays.ensureFromTo( length( a ), from, to );
	}

	/** Ensures that a range given by an offset and a length fits a big array.
	 *
	 * <P>This method may be used whenever a big array range check is needed.
	 *
	 * @param a a big array.
	 * @param offset a start index.
	 * @param length a length (the number of elements in the range).
	 * @throws IllegalArgumentException if <code>length</code> is negative.
	 * @throws ArrayIndexOutOfBoundsException if <code>offset</code> is negative or <code>offset</code>+<code>length</code> is greater than the big array length.
	 */
	public static KEY_GENERIC void ensureOffsetLength( final KEY_GENERIC_TYPE[][] a, final long offset, final long length ) {
		BigArrays.ensureOffsetLength( length( a ), offset, length );
	}


	/** A type-specific content-based hash strategy for big arrays. */

	private static final class BigArrayHashStrategy KEY_GENERIC implements Hash.Strategy<KEY_GENERIC_TYPE[][]>, java.io.Serializable {
    	public static final long serialVersionUID = -7046029254386353129L;
    
		public int hashCode( final KEY_GENERIC_TYPE[][] o ) {
			return java.util.Arrays.deepHashCode( o );
		}
		
		public boolean equals( final KEY_GENERIC_TYPE[][] a, final KEY_GENERIC_TYPE[][] b ) {
			return BIG_ARRAYS.equals( a, b );
		}
	}

	/** A type-specific content-based hash strategy for big arrays.
	 *
	 * <P>This hash strategy may be used in custom hash collections whenever keys are
	 * big arrays, and they must be considered equal by content. This strategy
	 * will handle <code>null</code> correctly, and it is serializable.
	 */

	@SuppressWarnings({"unchecked", "rawtypes"})
	public final static Hash.Strategy HASH_STRATEGY = new BigArrayHashStrategy();

	private static final int SMALL = 7;
	private static final int MEDIUM = 40;

	private static KEY_GENERIC void vecSwap( final KEY_GENERIC_TYPE[][] x, long a, long b, final long n ) {
		for( int i = 0; i < n; i++, a++, b++ ) swap( x, a, b );
	}
 
	private static KEY_GENERIC long med3( final KEY_GENERIC_TYPE x[][], final long a, final long b, final long c, KEY_COMPARATOR KEY_GENERIC comp ) {
		int ab = comp.compare( get( x, a ), get( x, b ) );
		int ac = comp.compare( get( x, a ), get( x, c ) );
		int bc = comp.compare( get( x, b ), get( x, c ) );
		return ( ab < 0 ?
			( bc < 0 ? b : ac < 0 ? c : a ) :
			( bc > 0 ? b : ac > 0 ? c : a ) );
	}

	public static KEY_GENERIC void quickSort( final KEY_GENERIC_TYPE[][] x, final long from, final long to, final KEY_COMPARATOR KEY_GENERIC comp ) {
		final long len = to - from;
		// Insertion sort on smallest arrays
		if ( len < SMALL ) {
			for ( long i = from; i < to; i++ )
			for ( long j = i; j > from && comp.compare( get( x, j - 1 ), get( x, j ) ) > 0; j-- ) swap( x, j, j - 1 );
			return;
		}

		// Choose a partition element, v
		long m = from + len / 2;	 // Small arrays, middle element
		if ( len > SMALL ) {
			long l = from;
			long n = to - 1;
			if ( len > MEDIUM ) {		// Big arrays, pseudomedian of 9
				long s = len / 8;
				l = med3( x, l, l + s, l + 2 * s, comp );
				m = med3( x, m - s, m, m + s, comp );
				n = med3( x, n - 2 * s, n - s, n, comp );
			}
			m = med3( x, l, m, n, comp ); // Mid-size, med of 3
		}
		
		final KEY_GENERIC_TYPE v = get( x, m );

		// Establish Invariant: v* (<v)* (>v)* v*
		long a = from, b = a, c = to - 1, d = c;
		while(true) {
			int comparison;
			while ( b <= c && ( comparison = comp.compare( get( x, b ), v ) ) <= 0 ) {
				if ( comparison == 0 ) swap( x, a++, b );
				b++;
			}
			while (c >= b && ( comparison = comp.compare( get( x, c ), v ) ) >=0 ) {
				if ( comparison == 0 ) swap( x, c, d-- );
				c--;
			}
			if ( b > c ) break;
			swap( x, b++, c-- );
		}

		// Swap partition elements back to middle
		long s, n = to;
		s = Math.min( a - from, b - a );
		vecSwap( x, from, b - s, s );
		s = Math.min( d - c, n - d- 1 );
		vecSwap( x, b, n - s, s );

		// Recursively sort non-partition-elements
		if ( ( s = b - a ) > 1 ) quickSort( x, from, from + s, comp );
		if ( ( s = d - c ) > 1 ) quickSort( x, n - s, n, comp );

	}

	@SuppressWarnings("unchecked")
	private static KEY_GENERIC long med3( final KEY_GENERIC_TYPE x[][], final long a, final long b, final long c ) {
		int ab = KEY_CMP( get( x, a ), get( x, b ) );
		int ac = KEY_CMP( get( x, a ), get( x, c ) );
		int bc = KEY_CMP( get( x, b ), get( x, c ) );
		return ( ab < 0 ?
			( bc < 0 ? b : ac < 0 ? c : a ) :
			( bc > 0 ? b : ac > 0 ? c : a ) );
	}

	@SuppressWarnings("unchecked")
	public static KEY_GENERIC void quickSort( final KEY_GENERIC_TYPE[][] x, final long from, final long to ) {
		final long len = to - from;
		// Insertion sort on smallest arrays
		if ( len < SMALL ) {
			for ( long i = from; i < to; i++ )
			for ( long j = i; j > from && KEY_CMP( get( x, j - 1 ), get( x, j ) ) > 0; j-- ) swap( x, j, j - 1 );
			return;
		}

		// Choose a partition element, v
		long m = from + len / 2;	 // Small arrays, middle element
		if ( len > SMALL ) {
			long l = from;
			long n = to - 1;
			if ( len > MEDIUM ) {		// Big arrays, pseudomedian of 9
				long s = len / 8;
				l = med3( x, l, l + s, l + 2 * s );
				m = med3( x, m - s, m, m + s );
				n = med3( x, n - 2 * s, n - s, n );
			}
			m = med3( x, l, m, n ); // Mid-size, med of 3
		}
		
		final KEY_GENERIC_TYPE v = get( x, m );

		// Establish Invariant: v* (<v)* (>v)* v*
		long a = from, b = a, c = to - 1, d = c;
		while(true) {
			int comparison;
			while ( b <= c && ( comparison = KEY_CMP( get( x, b ), v ) ) <= 0 ) {
				if ( comparison == 0 ) swap( x, a++, b );
				b++;
			}
			while (c >= b && ( comparison = KEY_CMP( get( x, c ), v ) ) >=0 ) {
				if ( comparison == 0 ) swap( x, c, d-- );
				c--;
			}
			if ( b > c ) break;
			swap( x, b++, c-- );
		}

		// Swap partition elements back to middle
		long s, n = to;
		s = Math.min( a - from, b - a );
		vecSwap( x, from, b - s, s );
		s = Math.min( d - c, n - d- 1 );
		vecSwap( x, b, n - s, s );

		// Recursively sort non-partition-elements
		if ( ( s = b - a ) > 1 ) quickSort( x, from, from + s );
		if ( ( s = d - c ) > 1 ) quickSort( x, n - s, n );

	}

#if ! #keyclass(Boolean)

	/**
	 * Searches the list for the specified value using
	 * the binary search algorithm.  The list must <strong>must</strong> be
	 * sorted (as by the sort method) prior to making this call.  If
	 * it is not sorted, the results are undefined: in particular, the call
	 * may enter an infinite loop.  If the list contains multiple elements
	 * equal to the specified key, there is no guarantee which of the multiple elements
	 * will be found.
	 *
	 * @param a the list to be searched.
	 * @param key the value to be searched for.
	 * @param from the leftmost search position, inclusive.
	 * @param to the rightmost search position, inclusive.
	 * @return index of the search key, if it is contained in the list;
	 *             otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The <i>insertion
	 *             point</i> is defined as the the point at which the value would
	 *             be inserted into the list: the index of the first
	 *             element greater than the key, or <tt>list.length</tt>, if all
	 *             elements in the list are less than the specified key.  Note
	 *             that this guarantees that the return value will be &gt;= 0 if
	 *             and only if the key is found.
	 * @see java.util.Arrays
	 */
	@SuppressWarnings({"unchecked","rawtypes"})
	public static KEY_GENERIC int binarySearch( final KEY_GENERIC_TYPE[][] a, int from, int to, final KEY_GENERIC_TYPE key ) {
		KEY_GENERIC_TYPE midVal;
		while (from <= to) {
			final int mid = (from + to) >>> 1;
			midVal = get( a, mid );
#if #keys(primitive)
			if (midVal < key) from = mid + 1;
			else if (midVal > key) to = mid - 1;
			else return mid;
#else
			final int cmp = ((Comparable)midVal).compareTo( key );
			if ( cmp < 0 ) from = mid + 1;
			else if (cmp > 0) to = mid - 1;
			else return mid;
#endif
        }
		return -( from + 1 );
	}

	public static KEY_GENERIC int binarySearch( final KEY_GENERIC_TYPE[][] a, final KEY_TYPE key ) {
		return binarySearch( a, 0, a.length, key );
	}

	public static KEY_GENERIC int binarySearch( final KEY_GENERIC_TYPE[][] a, int from, int to, final KEY_GENERIC_TYPE key, final KEY_COMPARATOR KEY_GENERIC c ) {
		KEY_GENERIC_TYPE midVal;
		while (from <= to) {
			final int mid = (from + to) >>> 1;
			midVal = get( a, mid );
			final int cmp = c.compare( midVal, key );
			if ( cmp < 0 ) from = mid + 1;
			else if (cmp > 0) to = mid - 1;
			else return mid; // key found
		}
		return -( from + 1 );
	}

	public static KEY_GENERIC int binarySearch( final KEY_GENERIC_TYPE[][] a, final KEY_GENERIC_TYPE key, final KEY_COMPARATOR KEY_GENERIC c ) {
		return binarySearch( a, 0, a.length, key, c );
	}

#endif


#if #keyclass(Integer)
#ifdef TEST

	private static long seed = System.currentTimeMillis(); 
	private static java.util.Random r = new java.util.Random( seed );

	private static KEY_TYPE genKey() {
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
		return (KEY_TYPE)(r.nextInt());
#elif #keys(primitive)
		return r.NEXT_KEY(); 
#elif #keyclass(Object)
		return Integer.toBinaryString( r.nextInt() );
#else 
		return new java.io.Serializable() {};
#endif
	}

	private static Object[] k, v, nk;
	private static KEY_TYPE kt[];
	private static KEY_TYPE nkt[];
	private static BIG_ARRAY_BIG_LIST topList;

	protected static void speedTest( int n, boolean b ) {}
	
	protected static void test( int n ) {
		KEY_TYPE[][] a = BIG_ARRAYS.newBigArray( n );
		for( int i = 0; i < n; i++ ) set( a, i, i );
		BIG_ARRAYS.copy( a, 0, a, 1, n - 2 );
		assert a[ 0 ][ 0 ] == 0;
		for( int i = 0; i < n - 2; i++ ) assert get( a, i + 1 ) == i;

		for( int i = 0; i < n; i++ ) set( a, i, i );
		BIG_ARRAYS.copy( a, 1, a, 0, n - 1 );
		for( int i = 0; i < n - 1; i++ ) assert get( a, i ) == i + 1;

		for( int i = 0; i < n; i++ ) set( a, i, i );
		KEY_TYPE[] b = new KEY_TYPE[ n ];
		for( int i = 0; i < n; i++ ) b[ i ] = i;
		
		assert equals( wrap( b ), a );

		System.out.println("Test OK");
		return;

	}


	public static void main( String args[] ) {
		int n  = Integer.parseInt(args[1]);
		if ( args.length > 2 ) r = new java.util.Random( seed = Long.parseLong( args[ 2 ] ) );

		try {
			if ("speedTest".equals(args[0]) || "speedComp".equals(args[0])) speedTest( n, "speedComp".equals(args[0]) );
			else if ( "test".equals( args[0] ) ) test(n);
		} catch( Throwable e ) {
			e.printStackTrace( System.err );
			System.err.println( "seed: " + seed );
		}
	}

#endif
#endif

}
