/*
 * Copyright (C) 2002 Sebastiano Vigna 
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *	
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *	
 * You should have received a copy of the GNU General Public License along
 * with this program; see the file COPYING.  If not, write to the Free
 * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 */

package it.unimi.dsi.fastUtil;

import java.util.*;
import java.io.*;

/**  A type-specific hash set with with a very fast, small-footprint implementation.
 */

public final class HASHSET_NAME extends ABSTRACT_SET_NAME implements Serializable, Hash, SET_NAME {
	 /** The array of keys. */
	 private transient KEY_TYPE key[];

	 /** The array of occupancy states. */
	 private transient byte state[];

	 /** The acceptable load factor. */
	 private final float loadFactor;
	 
	 /** Index into the prime list, giving the current table size. */
	 private int p;

	 /** Table size. Must be the p-th item of {@link Hash#primes}. */
	 private transient int n;

	 /** Secondary jump for conflict resolution. Must be the p-th item of {@link Hash#prevPrimes}. */
	 private transient int n2;

	 /** Number of entries in the set. */
	 private int count;

	 /** Number of used buckets in the set. May be larger than {@link #count} if there are items in state {@link #REMOVED}.  */
	 private transient int used;



	 /** Creates a new hash set.
	  *
	  * The actual table size is the least available prime greater than n/f.
	  *
	  * @param n the expected number of elements in the hash set. 
	  * @param f the load factor.
	  * @see Hash#primes
	  */
	 
	 public HASHSET_NAME( int n, float f ) {
		  int l = 0;
		  if ( f <= 0 || f > 1 ) throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
		  if ( n < 0 ) throw new IllegalArgumentException("Hash table size must be nonnegative");

		  while( primes[++l] < (int)(n / f) );

		  this.loadFactor = f;
		  this.n = primes[l];
		  n2 = prevPrimes[l];
		  p = l;
		  key = new KEY_TYPE[this.n];
		  state = new byte[this.n];
	 }
	 
	 
	 /** Creates a new hash set with {@link Hash.DEFAULT_LOAD_FACTOR} as load factor.
	  *
	  * @param n the expected number of elements in the hash set. 
	  */
	 
	 public HASHSET_NAME(int n) {
		  this(n, Hash.DEFAULT_LOAD_FACTOR);
	 }


	 /** Creates a new hash set with {@link Hash.DEFAULT_INITIAL_SIZE} elements
	  * and {@link Hash.DEFAULT_LOAD_FACTOR} as load factor.
	  */
	 
	 public HASHSET_NAME() {
		  this(Hash.DEFAULT_INITIAL_SIZE, Hash.DEFAULT_LOAD_FACTOR);
	 }
 

	 /** Creates a new hash set copying a given collection.
	  *
	  * @param c a {@link Collection} to be copied into the new hash set. 
	  */
	 
	 public HASHSET_NAME( Collection c ) {
		  this(c.size());
		  addAll(c);
	 }


	 /** Creates a new set copying the elements of an array.
	  *
	  * @param a an array to be copied into the new hash set. 
	  */
	 
	 public HASHSET_NAME( KEY_TYPE[] a ) {
		  this( a.length );
		  int i = a.length;
		  while(i-- != 0) add(a[i]);
	 }


	 public boolean add(Object ok) {

		  final int n = this.n;
		  final KEY_TYPE key[] = this.key, k = KEY2TYPE(ok);
		  final byte state[] = this.state;

		  // Primary hash
		  int h = (int)(( (HASH(k) % n) + n ) % n);
		  // Secondary hash
		  final int m = (int)(( (HASH(k) % n2) + n2 ) % n2) + 1;
		  
		  //System.err.print("Putting in " + k + " with hash " + h + " (" + m + ")..." );

		  while( ! KEY_EQUAL(key[h], k) && state[h] != FREE ) h = ( h + m ) % n;
		  
		  if ( state[h] != BUSY ) {
				if ( state[h] == FREE ) used++;
				state[h] = BUSY;
				count++;
				key[h] = k;
				if ( count < used/2 ) rehash( p ); // Too many removed entries, let's collect
				if ( used >= n * loadFactor ) rehash( Math.min(p+16, primes.length-1) ); // Table too filled, let's rehash
				return true;
		  }

		  return false;
	 }
	 

#if ! ( #keyclass(Object) )


	 public boolean add(KEY_TYPE k) {
		  final int n = this.n;
		  final KEY_TYPE key[] = this.key;
		  final byte state[] = this.state;

		  // Primary hash
		  int h = (int)(( (HASH(k) % n) + n ) % n);
		  // Secondary hash
		  final int m = (int)(( (HASH(k) % n2) + n2 ) % n2) + 1;
		  
		  //System.err.print("Putting in " + k + ", " + v + " with hash " + h + " (" + m + ")..." );

		  while( ! KEY_EQUAL( key[h], k ) && state[h] != FREE ) h = ( h + m ) % n;
		  
		  if ( state[h] != BUSY ) {
				if ( state[h] == FREE ) used++;
				state[h] = BUSY;
				count++;
				key[h] = k;
				if ( count < used/2 ) rehash( p ); // Too many removed entries, let's collect
				if ( used >= n * loadFactor ) rehash( Math.min(p+16, primes.length-1) ); // Table too filled, let's rehash
				return true;
		  }

		  return false;
	 }


#endif


	 public boolean remove(Object ok) {

		  final int n = this.n;
		  final KEY_TYPE key[] = this.key, k = KEY2TYPE(ok);
		  final byte state[] = this.state;

		  int h = (int)(( (HASH(k) % n) + n ) % n);
		  final int m = (int)(( (HASH(k) % n2 ) + n2 ) % n2) + 1;
		  
		  //System.err.println("Putting in " + k + ", " + v + " with hash " + h + " (" + m + ")" );

		  while( ! KEY_EQUAL(key[h], k) && state[h] != FREE ) h = ( h + m ) % n;
		  
		  if ( state[h] == BUSY ) {
				state[h] = REMOVED;
				count--;
				
				return true;
		  }
		  else return false;
	 }

	 public void clear() {
		  this.count = 0;
		  this.used = 0;
		  Arrays.fill(state, FREE);
#if #keyclass(Object)
		  Arrays.fill(key, null);
#endif
	 }


#if !#keyclass(Object)
	 /** Adds all elements of the given collection to the set.
	  * If the collection implements the interface of this set,
	  * it uses the faster iterators.
	  *
	  * @param c a collection.
	  */

	 public boolean addAll(Collection c) {
		  if (c instanceof SET_NAME) {
				boolean retVal = false;
				for(KEY_ITERATOR_NAME i = (KEY_ITERATOR_NAME)c.iterator(); i.hasNext(); ) if (add(i.NEXT_KEY_TYPE_CAP())) retVal = true;
				return retVal;
		  }
		  else return super.addAll(c);
	 }


	 /** Checks whether the set contains all elements from the given collection.
	  * If the collection implements the interface of this set,
	  * it uses the faster iterators.
	  *
	  * @param c a collection.
	  */

	 public boolean containsAll(Collection c) {
		  if (c instanceof SET_NAME) {
				for(KEY_ITERATOR_NAME i = (KEY_ITERATOR_NAME)c.iterator(); i.hasNext(); ) if (!contains(i.NEXT_KEY_TYPE_CAP())) return false;
				return true;
		  }
		  else return super.containsAll(c);
	 }
#endif

	 /* We override the method in the type-specific {@link AbstractCollection}
		 with a faster version without iterators. */

    public KEY_TYPE[] TO_KEY_TYPE_CAP_ARRAY( KEY_TYPE a[] ) {
		  final KEY_TYPE key[] = this.key, result[];
		  final int n = this.n, count = this.count;
		  final byte state[] = this.state;
		  int i, j, pos = 0;

		  if (a == null || a.length < count) result = new KEY_TYPE[count];
		  else result = a;

		  for(i=j=0; i<count; i++) {
				while( state[pos] != BUSY ) pos++;
				result[j++] = key[pos++];
		  }

		  return result;
    }


	 /** Returns an iterator on this set. 
	  * The iterator can be safely cast to a type-specific iterator.
	  */

	 public Iterator iterator() {
		  return new KEY_ITERATOR_NAME() {
					 int pos = 0, last = -1;
					 
					 { 
						  final byte state[] = HASHSET_NAME.this.state;
						  final int n = HASHSET_NAME.this.n;
						  
						  while( pos < n && state[pos] != BUSY ) pos++;
					 }
					 
					 public boolean hasNext() {
						  return pos < n;
					 }
					 
					 
#if !#keyclass(Object)
					 public KEY_TYPE NEXT_KEY_TYPE_CAP() {
						  KEY_TYPE retVal;
						  final byte state[] = HASHSET_NAME.this.state;
						  final int n = HASHSET_NAME.this.n;
						  
						  if (!hasNext()) throw new NoSuchElementException();
						  retVal = key[last = pos];
						  do pos++; while( pos < n && state[pos] != BUSY );
						  
						  return retVal;
					 }
#endif

					 public Object next() {
						  Object retVal;
						  final byte state[] = HASHSET_NAME.this.state;
						  final int n = HASHSET_NAME.this.n;
						  
						  if (!hasNext()) throw new NoSuchElementException();
						  retVal = KEY2OBJ(key[last = pos]);
						  do pos++; while( pos < n && state[pos] != BUSY );
						  
						  return retVal;
					 }
					 
					 public void remove() {
						  if (last == -1) throw new IllegalStateException();
						  state[last] = REMOVED;
						  count--;
					 }
				};
	 }
	 


	 /** Resizes the set.
	  * @param newP the new size as an index in {@link Hash#primes}.
	  */

	 private void rehash( int newP ) {
		  int i, count = 0, used = 0, h, m;

		  KEY_TYPE k;

		  final int n = this.n, newN = primes[newP], newN2 = prevPrimes[newP];
		  final KEY_TYPE key[] = this.key, newKey[] = new KEY_TYPE[newN];
		  final byte state[] = this.state, newState[] = new byte[newN];

		  for(i=0; i<n; i++) {

				if ( state[i] != BUSY ) continue;

				k = key[i];

				h = (int)(( (HASH(k) % newN) + newN ) % newN);
				m = (int)(( (HASH(k) % newN2 ) + newN2 ) % newN2) + 1;

				while( newState[h] != FREE ) h = ( h + m ) % newN;
				
				newState[h] = BUSY;
				newKey[h] = k;
				count++;
				used++;

		  }

		  this.n = newN;
		  this.n2 = newN2;
		  p = newP;
		  this.key = newKey;
		  this.state = newState;
		  this.count = count;
		  this.used = used;
	 }
	 
	 public int size() {
		  return count;
	 }

	 public boolean isEmpty() {
		  return count == 0;
	 }


	 public boolean contains(Object ok) {
		  final int n = this.n;
		  final KEY_TYPE key[] = this.key, k = KEY2TYPE(ok);
		  final byte state[] = this.state;

		  int h = (int)(( (HASH(k) % n) + n ) % n);
		  final int m = (int)(( (HASH(k) % n2 ) + n2 ) % n2) + 1;
		  
		  while( ! KEY_EQUAL(key[h], k) && state[h] != FREE ) h = ( h + m ) % n;
		  
		  return state[h] == BUSY;
	 }


#if !#keyclass(Object)

	 public boolean contains(KEY_TYPE k) {
		  final int n = this.n;
		  final KEY_TYPE key[] = this.key;
		  final byte state[] = this.state;

		  int h = (int)(( (HASH(k) % n) + n ) % n);
		  final int m = (int)(( (HASH(k) % n2 ) + n2 ) % n2) + 1;
		  
		  while( ! KEY_EQUAL(key[h], k) && state[h] != FREE ) h = ( h + m ) % n;
		  
		  return state[h] == BUSY;
	 }



	 public boolean remove(KEY_TYPE k) {

		  final int n = this.n;
		  final KEY_TYPE key[] = this.key;
		  final byte state[] = this.state;

		  int h = (int)(( (HASH(k) % n) + n ) % n);
		  final int m = (int)(( (HASH(k) % n2 ) + n2 ) % n2) + 1;
		  
		  while( ! KEY_EQUAL(key[h], k) && state[h] != FREE ) h = ( h + m ) % n;
		  
		  if ( state[h] == BUSY ) {
				state[h] = REMOVED;
				count--;
				
				return true;
		  }
		  else return false;
	 }
	 

#endif

    private void writeObject(java.io.ObjectOutputStream s) throws IOException {
		  final KEY_TYPE key[] = this.key;
		  final byte state[] = this.state;

		  s.defaultWriteObject();

		  for (int i = n; i-- != 0; ) {
				if (state[i] == BUSY) s.WRITE_KEY_TYPE_CAP(key[i]);
		  }
    }

    private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
		  int count;

		  s.defaultReadObject();
		  this.n = primes[p];
		  this.n2 = prevPrimes[p];
		  count = this.count;

		  this.key = new KEY_TYPE[n];
		  this.state = new byte[n];
		  this.count = 0;
		  this.used = 0;

		  for (int i = count; i-- != 0; ) {
				add(s.READ_KEY_TYPE_CAP());
		  }
    }

#ifndef NDEBUG

	 private static void speedTest( int n ) {
		  int i;
		  SET_NAME m;
		  Set t;
		  Random r = new Random();
		  Object o;
		  long v, fm, ct;

		  for(int k=0; k<10; k++) {

				t = new HashSet(n);
				m = new HASHSET_NAME(n);
		  /* First of all, we measure the time that is necessary to produce the inputs. */
		  
		  v = System.currentTimeMillis();
		  
		  for( i=0; i<n;  i++ ) {
				
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
				new KEY_CLASS((KEY_TYPE)(r.nextInt())) 
#elif ! #keyclass(Object)
					 new KEY_CLASS(r.NEXT_KEY_TYPE_CAP()) 
#else
						  new Long(r.nextLong()) 
#endif
								;
		  }
		  
		  ct = System.currentTimeMillis() - v;
		  
		  System.gc();
		  fm = Runtime.getRuntime().freeMemory();
		  v = System.currentTimeMillis();
		  

		  /* Then we add pairs to t. */

		  for( i=0; i<n;  i++ ) {
				t.add( 
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
						new KEY_CLASS((KEY_TYPE)(r.nextInt())) 
#elif ! #keyclass(Object)
						new KEY_CLASS(r.NEXT_KEY_TYPE_CAP()) 
#else
						r.nextInt() % 100 == 0 ? null : new Long(r.nextLong()) 
#endif
							 );
		  }

		  System.out.println("Added "+n+" pairs in HashSet in "+((System.currentTimeMillis() - v) % 100000) / 1000.0+"s" + 
									" (actual time: "+((System.currentTimeMillis() - v - ct) % 100000) / 1000.0+"s)" );
		  System.gc();
		  System.gc();
		  System.out.println("Memory used: "+ (fm - Runtime.getRuntime().freeMemory()) );

		  v = System.currentTimeMillis();

		  /* Then we check for elements in t. */

		  for( i=0; i<n;  i++ ) {
				t.contains( 
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
						new KEY_CLASS((KEY_TYPE)(r.nextInt())) 
#elif ! #keyclass(Object)
						new KEY_CLASS(r.NEXT_KEY_TYPE_CAP())
#else
							 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
								 );
		  }

		  System.out.println("Examined "+n+" elements in HashSet in "+((System.currentTimeMillis() - v) % 100000) / 1000.0+"s"+
									" (actual time: "+((System.currentTimeMillis() - v - ct) % 100000) / 1000.0+"s)" );

		  t = null;
		  System.gc();
		  System.gc();
		  fm = Runtime.getRuntime().freeMemory();

		  v = System.currentTimeMillis();

		  /* Then we add elements to m. */

		  for( i=0; i<n;  i++ ) {
				m.add( 
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
						new KEY_CLASS((KEY_TYPE)(r.nextInt())) 
#elif ! #keyclass(Object)
						new KEY_CLASS(r.NEXT_KEY_TYPE_CAP()) 
#else
						r.nextInt() % 100 == 0 ? null : new Long(r.nextLong()) 
#endif
							);
		  }
		  
		  System.out.println("Added "+n+" pairs in specialized HashSet in "+((System.currentTimeMillis() - v) % 100000) / 1000.0+"s"+
									" (actual time: "+((System.currentTimeMillis() - v - ct) % 100000) / 1000.0+"s)" );
		  System.gc();
		  System.gc();
		  System.out.println("Memory used: "+ (fm - Runtime.getRuntime().freeMemory()) );

		  v = System.currentTimeMillis();

		  /* Then we check for elements in m. */

		  for( i=0; i<n;  i++ ) {
				m.contains( 
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
							  (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
							  r.NEXT_KEY_TYPE_CAP()
#else
							  r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
									);
		  }
		  
		  System.out.println("Examined "+n+" pairs in specialized HashSet in "+((System.currentTimeMillis() - v) % 100000) / 1000.0+"s" +
									" (actual time: "+((System.currentTimeMillis() - v - ct) % 100000) / 1000.0+"s)" );
	 
		  }
	 }




	 private static void regressionTest( int n ) {
		  SET_NAME m = new HASHSET_NAME();
		  Set t = new HashSet();
		  Random r = new Random();

		  /* First of all, we fill t with random data. */

		  for(int i=0; i<n;  i++ ) {
				t.add( 
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
						new KEY_CLASS((KEY_TYPE)(r.nextInt())) 
#elif ! #keyclass(Object)
						new KEY_CLASS(r.NEXT_KEY_TYPE_CAP()) 
#else
						r.nextInt() % 100 == 0 ? null : new Long(r.nextLong()) 
#endif
										);
		  }
		  
		  /* Now we add to m the same data */
		  
		  m.addAll(t); 

		  /* Now we check that m actually holds that data. */
		  
		  for(Iterator i=t.iterator(); i.hasNext();  ) {
				Object e = i.next();
		      if (!m.contains(e)) {
					 System.err.println("Error: m and t differ on a key ("+e+") after insertion (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  
		  for(Iterator i=m.iterator(); i.hasNext();  ) {
				Object e = i.next();
		      if (!t.contains(e)) {
					 System.err.println("Error: m and t differ on a key ("+e+") after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		  }


		  /* Now we put and remove random data in m and t, checking that the result is the same. */

		  for(int i=0; i<n;  i++ ) {
				KEY_TYPE T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY_TYPE_CAP()
#else
					 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
						  ;
				if (m.add(KEY2OBJ(T)) != t.add(KEY2OBJ(T))) {
					 System.err.println("Error: divergence in add() between t and m.\n");
					 System.exit(-1);
				}
				T =
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
					 (KEY_TYPE)r.nextInt()
#elif ! #keyclass(Object)
					 r.NEXT_KEY_TYPE_CAP()
#else
					 r.nextInt() % 100 == 0 ? null : new Long(r.nextLong())
#endif
						  ;
				if (m.remove(KEY2OBJ(T)) != t.remove(KEY2OBJ(T))) {
					 System.err.println("Error: divergence in remove() between t and m.\n");
					 System.exit(-1);
				}
		  }




		  /* Now we check that m actually holds that data. */
		  
		  for(Iterator i=t.iterator(); i.hasNext();  ) {
				Object e = i.next();
		      if (!m.contains(e)) {
					 System.err.println("Error: m and t differ on a key ("+e+") after insertion (iterating on t).\n");
					 System.exit(-1);
				}
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  
		  for(Iterator i=m.iterator(); i.hasNext();  ) {
				Object e = i.next();
		      if (!t.contains(e)) {
					 System.err.println("Error: m and t differ on a key ("+e+") after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		  }


		  /* Now we make m into an array, make it again a set and check it is OK. */
		  KEY_TYPE a[] = m.TO_KEY_TYPE_CAP_ARRAY();

		  
		  if (!new HASHSET_NAME(a).equals(m)) {
				System.err.println("Error: toArray() output (or array-based constructor) is not OK.\n");
				System.exit(-1);
		  }


		  /* Now we save and read m. */

		  try {
				java.io.File f = new java.io.File("regressionTest");
				java.io.OutputStream os = new java.io.FileOutputStream(f);
				java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);
				
				oos.writeObject(m);
				oos.close();
				
				java.io.InputStream is = new java.io.FileInputStream(f);
				java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);
				
				m = (SET_NAME)ois.readObject();
				ois.close();
				f.delete();
		  }
		  catch(Exception e) {
				e.printStackTrace();
				System.exit(-1);
		  }

		  /* Now we check that m actually holds that data, but iterating on m. */
		  
		  for(Iterator i=m.iterator(); i.hasNext();  ) {
				Object e = i.next();
		      if (!t.contains(e)) {
					 System.err.println("Error: m and t differ on a key ("+e+") after insertion (iterating on m).\n");
					 System.exit(-1);
				}
		  }


		  /* Now we take out of m everything, and check that it is empty. */

		  //for(Iterator i=t.iterator(); i.hasNext(); ) m.remove(i.next()); 

		  for(Iterator i=m.iterator(); i.hasNext(); ) { i.next(); i.remove();} 

		  if (!m.isEmpty())  {
				System.err.println("Error: m is not empty (as it should be).\n");
				System.exit(-1);
		  }

		  System.err.println("Regression test OK.\n");
		  System.exit(0);
	 }


	 public static void main( String args[] ) {
		  int n  = Integer.parseInt(args[1]);
		  
		  if (args[0].equals("speedTest")) speedTest(n);
		  else if (args[0].equals("regressionTest")) regressionTest(n);
	 }

#endif

}


// Local Variables:
// mode: java
// End:
